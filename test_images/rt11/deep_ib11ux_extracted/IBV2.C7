/*
 * This software is provided solely for use with
 * the National Instruments GPIB11V-2.
 *
 * Copyright 1980, 1983 National Instruments
 *
 * Jeffrey Kodosky
 * REV D:  10/04/83
 * (Unix v7 mods)
 */

#include "../h/param.h"
#include "../h/callo.h"
#include "../h/dir.h"
#include "../h/inode.h"
#include "../h/buf.h"
#include "../h/conf.h"
#include "../h/user.h"
#include "../h/proc.h"
#include "../h/tty.h"
#include "../h/reg.h"
#include "../h/systm.h"

#define IB	((struct ib *) 0167710) /* Q-bus address */

#define PPENAB	0	/* Leave PPENAB undefined to eliminate PP code */
#define TRI	0	/* 4 for Three-state highspeed timing; 0 for Normal timing */
#define SAC	0	/* Leave SAC undefined if the GPIB11V-2 is not the System Controller */
#define EXT	1	/* 2 for Extended; 1 for Normal GPIB addressing */
#define MSA	0140	/* Msa&037 for Extended; 0140 for Normal GPIB addressing */
#define MA	025	/* GPIB address */
/*#define ONLYC	  0	  /* ONLYC may be defined (as anything) if there is but a */
			/* single Controller on the GPIBus.  ONLYC implies SAC. */
/*#define PHYSODD 0	  /* PHYSODD may be defined (as anything) if physio supports odd addresses/counts */
#define TRACE	0	/* Leave TRACE undefined to eliminate tracing code */
/*#define DEBUG	  0	  /* DEBUG may be defined (as anything) to include diagnostic printfs */


#define SIGSRQ	SIGINT

struct buf ibbuf;
extern int HZ;

#ifndef PHYSODD
static char iboddc, ibodda;
#endif

#ifndef TRACE
#define T
#else
#define T	tracer();
#endif

#ifndef DEBUG
#define printf
#endif

#define in(a)		IB->a
#define out(a,v)	IB->a=(v)
#define Exclude		sps=spl5()
#define Unexclude	splx(sps)
#define Try(f)		if((x=(f))<0) return x


#define INACTIVE   0		/* Software controller states */
#define IDLE	   1
#define INCHARGE   2
#define STANDBY	   3

#define GO	1		/* Control/status register bits */
#define OUT	2
#define SEL	4
#define ECC	010
#define IE	0100
#define LMR	0200
#define CIC	0400
#define ATN	01000
#define EOI	02000
#define OCSW	02000
#define TCS	04000
#define DAV	04000
#define SRQ_IE	010000
#define SRQ	010000
#define INT	020000
#define DMA_ENAB 020000
#define NEX	040000
#define REN	040000
#define IFC	0100000

#define DIR	0		/* Internal register addresses */
#define DOR	0
#define ISR1	1
#define IMR1	1
#define ISR2	2
#define IMR2	2
#define SPS	3
#define SPM	3
#define ADS	4
#define ADM	4
#define CPT	5
#define AUX	5
#define AD0	6
#define ADR	6
#define AD1	7
#define EOS	7

#define ERR_IE	    4		/* Internal register bits */
#define END_IE	  020
#define CPT_IE	 0200
#define DMAI_ENAB 020
#define DMAO_ENAB 040
#define SRQS	 0100
#define RSV	 0100
#define TA	    2
#define LA	    4
#define LON	 0100
#define TON	 0200
#define DL	  040
#define DT	 0100
#define ARS	 0200

#define _CLKR	  040		/* Hidden register addresses & offsets */
#define _PPR	 0140
#define _AUXA	 0200
#define _AUXB	 0240
#define CLKR	    0
#define PPR	    1
#define AUXA	    2
#define AUXB	    3

#define U	  020		/* Hidden register bits */
#define BIN	  020
#define S	  010
#define REOS	    4
#define HLDE	    2
#define HLDA	    1
#define CPT_ENAB    1
#define PACS	    1		/* Software status bits */
#define MON	    2

#define IST	011		/* Special interface functions */
#define NIST	  1
#define VSC	017
#define NVSC	  7
#define SEOI	  6
#define FH	  3
#define IR	  2
#define PON	  0

#define OK	   1	/* Error codes */
#define ENONE	  -1	/* No command byte available (READCOMMAND) */
#define ECACFLT	  -2	/* ATN not unasserted after IFC sent (bus problem) */
#define ENOTCAC	  -3	/* Not Active Controller for operation requiring CAC (software problem) */
#define ENOTSAC	  -4	/* Not System Controller for operation requiring SAC (software problem) */
#define EIFCLR	  -5	/* IFC caused operation to abort (bus problem) */
#define ETIMO	  -6	/* Operation did not complete within allotted time (bus problem) */
#define ENOFUN	  -7	/* Non-existent function code (software problem) */
#define ETCTIMO	  -8	/* Take control not completed within allotted time (bus problem) */
#define ENOIBDEV  -9	/* No Listeners addressed or no devices connected (bus problem) */
#define EIDMACNT -10	/* Internal DMA completed without bcr going to 0 (hardware problem) */
#define ENOPP	 -11	/* PP operation attempted on three-state GPIB (software problem) */
#define EITIMO	 -12	/* Internal DMA did not complete within allotted time (hardware problem) */
#define EINEXM	 -13	/* Internal DMA aborted due to non-existent memory (software/hardware problem) */
#define ENEXMEM	 -14	/* GPIB DMA aborted due to non-existent memory (software/hardware problem) */
#define ECNTRS	 -15	/* Bar and bcr are inconsistent following GPIB DMA (hardware problem) */

#define RQC_STB	 (RSV | 1)	/* Service request status bytes */
#define RQT_STB	 (RSV | 2)
#define RQL_STB	 (RSV | 4)

#define RQC	1		/* Asynchronous op codes */
#define CAC	2
#define TAC	3
#define LAC	4
#define CWT	5
#define WSRQ	6

#define TCT	011		/* GPIB multiline messages */
#define PPC	5
#define PPU	025
#define SCG	0140

#define IN	0
#define ITIMO	25		/* Internal loopcount timeout */
#define GTIMO	10		/* Default GPIB timeout in seconds */
#define TCTIMO	100
#define MONHWAT 32

#define RD	(DMA_ENAB|TCS|IN|GO)
#define WT	(DMA_ENAB|TCS|OUT|GO)
#define RDIR	(DMA_ENAB|IN|SEL|GO)
#define WTIR	(DMA_ENAB|OUT|SEL|GO)


struct	ib {
	int	bcr, bar, csr;	/* Q-bus device registers		*/
	char	ccf, xba;
	char	internal[8];	/* Internal registers			*/
	char	hidden[4];	/* Hidden registers			*/

	char	cstate;
	char	istr, op;
	int	ans;
	int	timo;		/* Watchdog timer */
	struct proc *owner;	/* GPIB owning process			*/
	int	rdbcr, rdbar, rdcsr;
	char	rdinternal[8];
#ifndef ONLYC
	struct clist monq;
#endif
	int	arg[3];
#ifdef TRACE
#define TRSZ	32
	int	trin;
	int	trbuf[TRSZ];
#endif
	} ib;

struct { int ureg[4]; };

static int status(), spbyte();
static int command(), transfer(), clear(), remote(), local(), ppoll();
static int passctrl(), setstat(), monitor(), readcmd(), setparam(), testsrq();

int (*ibfn[])()= {
	command, transfer, clear, remote, local, ppoll,
	passctrl, setstat, monitor, readcmd, setparam, testsrq,
	status, spbyte };

#define NFNS	((sizeof ibfn)/(sizeof ibfn[0]))


ibopen(dev,rw){
	register int sps;

	Exclude;
printf("open (%o)\n",ibopen);
	if(ib.owner) u.u_error= ENXIO;
	else {	T
		if((ib.ans=init())<0) u.u_error= EIO;
		else ib.owner= u.u_procp;
		}
	Unexclude; }

ibclose(dev){
	register int sps;

	Exclude;
printf("close (%o)\n",ibclose);
	T
	ib.cstate= INACTIVE;
	ib.csr= 0;
	out(csr,LMR);
	ib.owner= 0;
	Unexclude; }

ibioctl(dev,cmd,av) int *av;{
	register int sps, x;

	Exclude;
printf("ioctl (%o)\n",ibioctl);
	switch(cmd){
	case TIOCGETP:
		T
		ib.arg[0]= ib.ans;
		ib.arg[1]= in(csr);
		ib.arg[2]= in(bcr);
printf("\tgtty: %o %o %o\n",ib.arg[0],ib.arg[1],ib.arg[2]);
		if(copyout(ib.arg,av,sizeof ib.arg)) u.u_error= EFAULT;
		break;
	case TIOCSETP:
		T
		if(copyin(av,ib.arg,sizeof ib.arg)){
			u.u_error= EFAULT;
			break; }
printf("\tstty: %o %o %o\n",ib.arg[0],ib.arg[1],ib.arg[2]);
		if((x=ib.arg[0])<0 || x>=NFNS){
			ib.ans= ENOFUN; u.u_error= EIO; }
		else if((ib.ans= (*ibfn[x])())<0) u.u_error= EIO;
		break;
	default: u.u_error= ENOTTY;
		break;
		}
	Unexclude; }

static command(){
	T
	ib.op= CWT;
	return OK; }

static transfer(){
	T
	return gts(EXT); }

static clear(){
	register int x;

	T
	Try(unhold());
#ifdef SAC
	out(csr, ib.csr | IFC);
	wait100us();
	if(in(csr)&ATN) return ECACFLT;
	ib.cstate= INCHARGE;
	out(csr, (ib.csr |= ATN | SRQ_IE | CIC));
	T
	return lun(TON); }
#else
	return ENOTSAC; }
#endif

static remote(){
	T
#ifdef SAC
	out(csr, (ib.csr |= REN));
	return OK; }
#else
	return ENOTSAC; }
#endif

static local(){
	T
#ifdef SAC
	out(csr, (ib.csr &= ~REN));
	return OK; }
#else
	return ENOTSAC; }
#endif

static ppoll(){
	register int x;

	T
#ifdef PPENAB
	Try(tcs());
	Try(lun(LON));
	T
	out(csr, (ib.csr |= EOI));
	Try(xfer(RDIR, &ib.rdinternal[CPT], 1, CPT));
	out(csr, (ib.csr &= ~EOI));
	return (ib.rdinternal[CPT]&0377|0400); }
#else
	return ENOPP; }
#endif

static passctrl(){
	register int x;

	T
#ifdef ONLYC
	return ENOIBDEV; }
#else
	if(ib.cstate!=INCHARGE) return ENOTCAC;
	Try(lun(EXT));
	T
	out(csr, (ib.csr &= ~(SRQ_IE | ATN | CIC)));
	ib.cstate= IDLE;
	return OK; }
#endif

static setstat(){
	T
#ifndef ONLYC
#ifdef PPENAB
	if((ib.istr&S) && ib.arg[1]==0){
		ib.istr &= ~S; return ldaux(NIST); }
	if((ib.istr&S)==0 && ib.arg[1]){
		ib.istr |= S; return ldaux(IST); }
#endif
#endif
	return OK; }

static monitor(){
	T
#ifndef ONLYC
	if(ib.arg[1]) ib.istr |= MON;
	else ib.istr &= ~MON;
#endif
	return OK; }

static readcmd(){
	register x;

	T
#ifndef ONLYC
	if((x=getc(&ib.monq))>=0) return (x|0400);
#endif
	return ENONE; }

static setparam(){
	T
	ib.timo= ib.arg[1];
	ib.internal[0]= ib.arg[2];
	ib.internal[EOS]= ib.arg[2]>>8;
	return OK; }

static testsrq(){
	int ibtimer();

	T
	if(in(csr)&SRQ) return OK;
	if(ib.csr&CIC) out(csr, (ib.csr |= SRQ_IE));
	if(ib.arg[1]){
		ib.op= WSRQ;
		if(ib.timo) timeout(ibtimer,0,ib.timo*HZ);
		sleep(&ibbuf,10);
		return ib.ans; }
	return ENONE; }

static status(){
	register char *c;
	register int ct;

	T
	c= &ib;
	u.u_base= ib.arg[1];
	if((u.u_count=ib.arg[2]) > sizeof ib)
		u.u_count= sizeof ib;
	ct= u.u_count;
	while(passc(*c++)>=0) ;
	return ct; }

static spbyte(){
	register int x;

	T
#ifndef ONLYC
	Try(rqs(ib.arg[1]));
#endif
	return OK; }

static init(){
	register char *cp;
	register int x;

	out(csr, LMR);
	ib.csr= 0;
	ib.ccf= 0;
	ib.xba= 0;
	cp= &ib.hidden[0];
	*cp++= _CLKR | 5;
	*cp++= _PPR | U;
	*cp++= _AUXA;
	*cp++= _AUXB | TRI | CPT_ENAB;

	cp= &ib.internal[0];
	*cp++= 0;
	*cp++= CPT_IE | ERR_IE;
	*cp++= 0;
	*cp++= 0;
	*cp++= EXT;
	*cp++= ib.hidden[CLKR];
	*cp++= ARS | MSA;
	*cp++= 0;

	ib.istr= 0;
	ib.op= 0;
	ib.ans= 0;
	ib.timo= GTIMO;
#ifdef TRACE
	ib.trin= 0;
#endif
	Try(irload());
	T
	ib.cstate= IDLE;
	out(csr, ib.csr= IE);
#ifndef ONLYC
	while(getc(&ib.monq)>=0) ;
#endif
	return 0; }

static ibstop(){
	register int x;

	T
	out(csr, (ib.csr &= ~(DMA_ENAB|GO)));
	ib.op= 0;
	iodone(&ibbuf);
#ifndef ONLYC
	Try(rqs(0));
#endif
	return ETIMO; }

static irload(){
	register int x;

	Try(xfer(WTIR,&ib.internal[ISR1],7,ISR1));
	ib.internal[AUX]= ib.hidden[AUXA];
	ib.internal[ADR]= MA;
	Try(xfer(WTIR,&ib.internal[AUX],2,AUX));
	Try(xfer(WTIR,&ib.hidden[AUXB],1,AUX));
	x= ib.internal[ADM];
	ib.internal[ADM]= 0;
	return lun(x); }

static lun(newadm) char newadm;{	/* Note: rsv is cleared and not restored*/
	register int x;

	if(ib.internal[ADM]==newadm) return OK;
	ib.internal[ADM]= newadm;
	ib.internal[AUX]= PON;
	Try(xfer(WTIR,&ib.internal[ADM],2,ADM));
	Try(xfer(WTIR,&ib.hidden[PPR],1,AUX));
	return (ib.istr&S)? ldaux(IST): OK; }

ibwrite(dev){
	register int sps;
	int ibstrategy();

	Exclude;
	T
	if((ib.ans=wsetup())>=0)
		physio(ibstrategy, &ibbuf, dev, B_WRITE);
	ib.op= 0;
	if(ib.ans<0) u.u_error= EIO;
	Unexclude; }

static wsetup(){
	register x;

	ib.ccf= 0;
	ib.csr &= ~ECC;
	if(ib.op==CWT)
		if((x=tcs())<0){
			T
#ifndef ONLYC
			if(u.u_count==0 || x!=ENOTCAC) return x;
			Try(rqs(RQC_STB));
			ib.op= RQC; }
#else
			return x; }
#endif
		else {	T
			Try(lun(TON));
			ib.op= CAC; }
	else {	T
		if((x=gts(TON))<0){
			T
#ifndef ONLYC
			if(u.u_count==0 || x!=ENOTCAC) return x;
			Try(rdads());
			if((ib.rdinternal[ADS]&TA)==0)
				Try(rqs(RQT_STB));
			}
#else
			return x; }
#endif
		if(ib.internal[0]&2){
			ib.ccf= SEOI; ib.csr |= ECC; }
		ib.op= TAC; }
#ifndef PHYSODD
	ibodda= (int)u.u_base&1;
	u.u_base -= ibodda;
	iboddc= ((ibodda + u.u_count + 1)&~1) - u.u_count;
	u.u_count += iboddc;
#endif
	return OK; }

ibread(dev){
	register int sps;
	int ibstrategy();

	Exclude;
	T
	if((ib.ans=rsetup())>=0)
		physio(ibstrategy, &ibbuf, dev, B_READ);
	ib.op= 0;
	if(ib.ans<0) u.u_error= EIO;
	Unexclude; }

static rsetup(){
	register int x;

	ib.ccf= 0;
	ib.csr &= ~ECC;
	if((x=gts(LON))<0){
		T
#ifndef ONLYC
		if(u.u_count==0 || x!=ENOTCAC) return x;
		Try(rdads());
		if((ib.rdinternal[ADS]&LA)==0)
			Try(rqs(RQL_STB));
		}
#else
		return x; }
#endif
	ib.hidden[AUXA] |= (ib.internal[0]&(2<<4)? REOS:0) | (ib.internal[0]&(1<<4)? BIN:0);
	if(ib.internal[0]&(4<<4)) ib.internal[IMR1] &= ~END_IE;
	else {	T
		ib.internal[IMR1] |= END_IE;
		if(ib.cstate==STANDBY) ib.hidden[AUXA] |= HLDE; }
	ib.internal[AUX]= ib.hidden[AUXA];
	Try(xfer(WTIR, &ib.internal[IMR1], 7, IMR1));
	if(ib.cstate==STANDBY){
		T
		ib.ccf= ib.hidden[AUXA]= ib.hidden[AUXA]&~HLDE|HLDA;
		ib.csr |= ECC; }
	ib.op= LAC;
#ifndef PHYSODD
	ibodda= (int)u.u_base&1;
	u.u_base -= ibodda;
	iboddc= ((ibodda + u.u_count + 1)&~1) - u.u_count;
	u.u_count += iboddc;
#endif
	return OK; }

ibstrategy(abp){
	register int x, rw;
	register struct buf *bp;

	T
	bp= abp;
	ib.xba= bp->b_xmem;
	rw= bp->b_flags&B_READ? RD:(ib.op==RQC? OUT:WT);
#ifndef PHYSODD
	if((x=xfer(rw, bp->b_un.b_addr+ibodda, bp->b_bcount-iboddc, 0))<0){
#else
	if((x=xfer(rw, bp->b_un.b_addr, bp->b_bcount, 0))<0){
#endif
		T
		ib.ans= x;
		iodone(bp);
	}	}

#ifndef ONLYC
static rdads(){
	return xfer(RDIR, &ib.rdinternal[ADS], 1,ADS); }

static rqs(r) char r;{
	if(ib.internal[SPM]==r) return OK;
	ib.internal[SPM]= r;
	return xfer(WTIR, &ib.internal[SPM], 1,SPM); }

static valid(){
	return ldaux(VSC); }
#endif

static gts(newadm) char newadm;{
	register int x;

	T
	Try(unhold());
	if(ib.cstate==STANDBY)
		return (ib.internal[ADM]==newadm)? OK : ENOIBDEV;
	T
	if(ib.cstate==IDLE) return ENOTCAC;
	Try(lun(newadm));
	out(csr, (ib.csr &= ~ATN));
	ib.cstate= STANDBY;
	return OK; }

static tcs(){
	if(ib.cstate==INCHARGE) return OK;
	T
	if(ib.cstate==IDLE) return ENOTCAC;
	out(csr, (ib.csr |= ATN));
	ib.cstate= INCHARGE;
	return unhold(); }

static unhold(){
	register int x;

	if(ib.hidden[AUXA]&(HLDE|HLDA)){
		T
		ib.hidden[AUXA]= _AUXA;
		Try(ldaux(FH));
		return xfer(WTIR, &ib.hidden[AUXA], 1, AUX); }
	return OK; }

xfer(rw,bp,n,fr){	/* fr is internal reg addr  */
	register int i, x;
	int ibtimer();

	if(n<=0) return OK;
	if(rw&SEL){
		T
		out(bcr, (-n<<8) | fr & 7);
		out(bar, bp);
		out(ureg[3], 0);
		out(csr, ib.csr & (REN|SRQ_IE|EOI|ATN|CIC) | rw);
		for(i=ITIMO; !((x=in(csr))&DONE); )
			if(--i<=0) return EITIMO;
		if(x&NEX) return EINEXM;
		if(in(bcr)&0177400) return EIDMACNT;
		out(csr, ib.csr & (REN|SRQ_IE|ATN|CIC|IE));
		return n; }
	ib.internal[IMR2]= rw&OUT? DMAO_ENAB:DMAI_ENAB;
	Try(xfer(WTIR,&ib.internal[IMR2],1,IMR2));
	T
	out(bcr, ib.bcr= -n);
	out(bar, ib.bar= bp);
	out(ureg[3], ib.ureg[3]);
	out(csr, (ib.csr= ib.csr & (REN|SRQ_IE|TCS|ATN|CIC|ECC) | IE | rw));
	ib.ans= 0;
	if(ib.timo) timeout(ibtimer,0,ib.timo*HZ);
	return OK; }

static ldaux(a){
	ib.internal[AUX]= a;
	return xfer(WTIR, &ib.internal[AUX], 1, AUX); }

ibtimer(id){
	int sps;

	Exclude;
printf("timer (%o)\n",ibtimer);
	T
	ib.ans= ibstop();
	Unexclude; }

ibintr(){
	register int x, i;

printf("intr (%o)",ibintr);
	ib.rdcsr= in(csr);
	ib.rdbcr= in(bcr);
	ib.rdbar= in(bar);
printf("\trdbcr,rdbar,rdcsr= %o %o %o\n",ib.rdbcr,ib.rdbar,ib.rdcsr);
	T
#ifndef SAC
	if(ib.rdcsr<0){
		T
		out(csr, (ib.csr &= ~(DMA_ENAB|SRQ_IE|TCS|ATN|CIC|GO)));
		if(ib.cstate!=INACTIVE){
			T
			ib.cstate= IDLE;
			ib.hidden[AUXA]= _AUXA;
			ib.internal[AUX]= FH;
			ib.internal[ADM]= EXT;
			ib.internal[IMR2]= 0;
			ib.internal[SPM]= 0;
			if((ib.ans=irload())>=0) ib.ans= EIFCLR;
			ib.op= 0;
			iodone(&ibbuf); }
		return; }
#endif
	if((ib.rdcsr&SRQ) && (ib.csr&SRQ_IE)){
printf("srq intr\n");
		T
		out(csr, (ib.csr &= ~SRQ_IE) & ~GO);
		if(ib.op==WSRQ){
			ib.op= 0;
			ib.ans= OK;
			rmtimo(ibtimer);
			wakeup(&ibbuf); }
		else if(ib.owner) psignal(ib.owner,SIGSRQ); }
	if(ib.rdcsr&INT){
		T
printf("int intr");
		x= in(bcr);
		out(csr, ib.csr & ~(DMA_ENAB|GO));
		ib.rdcsr= in(csr);
		ib.rdbcr= in(bcr);
		if(ib.rdbcr || x) ib.rdbcr--;	/* bcr increments when DMA disabled */
		ib.rdbar= in(bar);
printf("\trdbcr,rdbar,rdcsr,oldbcr= %o %o %o %o\n",ib.rdbcr,ib.rdbar,ib.rdcsr,x);
		if((x=xfer(RDIR, &ib.rdinternal[ISR1], 5, ISR1))<0) goto quit;
		if(ib.rdinternal[ISR1]&ERR_IE) ib.ans= ENOIBDEV;
#ifndef ONLYC
		else if(ib.rdinternal[IMR1]&CPT_IE){
			T
			if((ib.istr&MON) && ib.monq.c_cc<MONHWAT)
				putc(ib.rdinternal[CPT], &ib.monq);
#ifdef PPENAB
			if((ib.istr&PACS) && ib.rdinternal[CPT]>=SCG){
				T
				ib.istr &= ~PACS;
				ib.hidden[PPR]= ib.rdinternal[CPT];
				goto ldlpe; }
#endif
			switch(ib.rdinternal[CPT]){
				case TCT:
					T
					if((ib.rdinternal[ADS]&TA)==0) break;
					if((x=valid())<0) goto quit;
					for(i=TCTIMO; in(csr)&ATN; i--)
						if(i==0){ x= ETCTIMO; goto quit; }
					out(csr, (ib.csr |= SRQ_IE|ATN|CIC) & ~GO);
					ib.cstate= INCHARGE;
					break;
#ifdef PPENAB
				case PPC:
					T
					if(ib.rdinternal[ADS]&LA) ib.istr |= PACS;
					break;
				case PPU:
					T
					ib.hidden[PPR]= _PPR | U;
				ldlpe:	if((ib.rdcsr&OCSW)==0) break;
					if((x=xfer(WTIR,&ib.hidden[PPR],1,AUX))<0)
						goto quit;
					break;
#endif
				}
			if((x=valid())<0) goto quit;
			}
#endif
		if(ib.internal[IMR1]&END_IE){
			T
			ib.internal[IMR1] &= ~END_IE;
			if((x=xfer(WTIR,&ib.internal[IMR1],1,IMR1))<0) goto quit;
		}	}
	if((ib.rdcsr&DONE) && (ib.csr&GO)){
		T
		ib.csr &= ~GO;
		if(ib.timo) rmtimo(ibtimer);
		if(ib.rdcsr&NEX) ib.ans= ENEXMEM;
#ifndef ONLYC
		if((x=rqs(0))<0) goto quit;
#endif
		x= ib.rdbcr - ib.bcr;
		if(ib.rdbar - ib.bar != x) x= ECNTRS;
		ibbuf.b_resid= -ib.rdbcr;
		if(ib.ans==0)
quit:			ib.ans= x;
		ib.op= 0;
		T
		iodone(&ibbuf); }
#ifndef ONLYC
	else if(ib.op==RQC && (ib.rdcsr&CIC)){
		T
		if((x=lun(TON))<0) goto quit;
		ib.op= CAC;
		out(csr, ib.csr |= WT);
		return; }
#endif
	}

static wait100us(){
	register int i;

	for(i=100; i-->0; ) ; }

rmtimo(fn) register int (*fn)();{
	register struct callo *p1, *p2;
	int s;

	s= spl7();
	p1= &callout[0];
	while(p1->c_func!=0 && p1->c_func!=fn)
		p1++;
	if(p1->c_func!=0){
		(p1+1)->c_time=+ p1->c_time;
		do {	p1->c_time= (p1+1)->c_time;
			p1->c_func= (p1+1)->c_func;
			p1->c_arg= (p1+1)->c_arg;
			p1++;
			} while(p1->c_func!=0);
		}
	splx(s); }

#ifdef TRACE
tracer(a){
	register int s;

	s= spl7();
printf("\tT %o\n", *(&a-1));
	ib.trbuf[ib.trin++]= *(&a -1);	/* save caller pc */
	if(ib.trin>=TRSZ) ib.trin= 0;
	splx(s); }
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         