	.enabl	lc
	.title	IBUDP - GPIB11-Series Interface Handler Front-end
	.nlist	bex, ttm, cnd

;	This software is provided solely for use with
;	the National Instruments GPIB11-series interfaces.

;	Copyright 1980 National Instruments

;	Jeffrey Kodosky
;	April	1980
;	Edit	09/26/81
;	REV C:	01/01/82
;	REV D:	12/20/82
;	V1:	04/18/83	Read and write are now done with spfun

; Edit the following assignments to reflect the desired software environment.
BASIC=	0	; 0 for FORTRAN/MACRO interface, 1 for BASIC
DVR=	1	; 1 if driver is an RT handler, 2 if RSX handler, 0 otherwise.


.iif eq,DVR,	.error handler front-end only
.iif eq,DVR-1,	.mcall .lookup, .spfun, .close
.iif eq,DVR-2,	.mcall qiow$s, alun$s

RTCHAN=	  13.
RSXCHAN=   1
RSXEFN=	   2

.if ne,BASIC
.if eq,DVR-2
RSXCHAN=   4
.endc
.endc


; Error codes
OK=	      1
ENONE=	     -1
ENOFUN=	     -7
EOPEN=	    -17.	; Handler is already open.
EHDLR=	   -100.	; Handler access error.

r0=%0
r1=%1
r2=%2
r3=%3
r4=%4
r5=%5
sp=%6
pc=%7

.if eq,DVR-2
COM=	5*256.
WT=	1*256.	;IO.WLB
RD=	2*256.	;IO.RLB
TR=	6*256.
CL=	7*256.
REM=	8.*256.
LOC=	9.*256.
PP=	10.*256.
PCT=	11.*256.
SST=	12.*256.
MON=	13.*256.
RDC=	14.*256.
SPM=	15.*256.
TSR=	16.*256.
FIN=	17.*256.
STA=	18.*256.
SPB=	19.*256.
.endc

.if eq,DVR-1
COM=	-1
WT=	-2
RD=	-3
TR=	-4
CL=	-5
REM=	-6
LOC=	-7
PP=	-8.
PCT=	-9.
SST=	-10.
MON=	-11.
RDC=	-12.
SPM=	-13.
TSR=	-14.
FIN=	-15.
STA=	-16.
SPB=	-17.
.endc

	.macro	spfn	code buffer count
.if eq,DVR-2
.if nb,buffer
	qiow$s	#code, ib+chan, ib+efn, , #ib+iost, , <buffer,count>
.iff
	qiow$s	#code, ib+chan, ib+efn, , #ib+iost
.endc
	mov	ib+iost+2,r0
	bmi	.+16
	cmpb	#IS.SUC,ib+iost
	beq	.+6
	mov	#EHDLR,r0
.endc
.if eq,DVR-1
	clr	ib+iost
	.spfun	#area, ib+chan, #code, buffer, count, #ib+iost
	mov	ib+iost,r0
	bmi	.+10
	bcc	.+6
	mov	#EHDLR,r0
.endc
	.endm	spfn

	.macro	cjmp t f
	.macro	j't' a ?b
	b'f'	b
	jmp	a
b:
	.endm	j't'
	.macro	j'f' a ?b
	b't'	b
	jmp	a
b:
	.endm	j'f'
	.endm	cjmp
	.irp	j,<<eq,ne>,<cc,cs>>
	cjmp	j
	.endr

	.csect	ibudp
ib:	-1, 0, 0, 0
	.byte	-1, 0, -1, 10.
	.even
	.csect
chan=0				;struct ib {
efn=2				;	int	chan, efn, iost[2];
iost=4
rmd=8.				;	char	rmd, eod, wmd, timo;
eod=9.
wmd=10.				;	} ib;
timo=11.

begin= .
	.globl	gpib
gpib:

.if ne,BASIC
.if eq,DVR-2
	jsr	pc,gpib0
	mov	@2(r5),r1	; if called with extra arg then put return value in
	cmp	r1,#NFNS
	bcc	1$
	cmpb	@r5,fcntbl(r1)
	ble	1$
	movb	@r5,r1
	beq	1$
	asl	r1
	add	r5,r1
	mov	r0,@(r1)+
1$:	rts	pc

fcntbl: .byte	3, 4, 5, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 3, 2
	.even
.iff
	.globl	$arger, $bomb, $find, $alc, $store, $dealc, $msg
	cmpb	1(r5),#202
	jne	gpib0
	mov	@-2(r5),r4
	bic	#200,r4
	cmp	r4,#1023
	bne	argerr
	mov	@2(r5),r0
	cmp	r0,#NFNS
	jcc	b9$
	cmpb	@r5,bcntbl(r0)
	bne	argerr
	movb	fcntbl(r0),fblk
	mov	2(r5),fblk+2
	mov	-2(r5),r4
	asl	r0
	jmp	@pretbl(r0)

b.write:mov	4(r4),r4
	bic	#200,r4
	cmp	r4,#1023
	bne	argerr
	mov	6(r5),fblk+10
	mov	-2(r5),r4
b.command:
	mov	2(r4),r4
	bit	#1,r4
	bne	argerr
	mov	(r4)+,r1
	mov	@r4,r0
	bic	#200,r1
	cmp	r1,#1100
	bne	argerr
	mov	#100,r1
	jsr	pc,$find
	mov	r0,fblk+4
	mov	#fblk+16,fblk+6
	mov	r1,fblk+16
	br	b.call

argerr: jmp	$arger

b.read: tst	(r4)+
	mov	(r4)+,r3
	bit	#1,r3
	bne	argerr
	cmp	(r3)+,#1100
	bne	argerr
	mov	@r3,strref
	mov	#tmpstr,fblk+4
	mov	#fblk+6,r3
	mov	r5,r2
	add	#6,r2
	mov	#3,r0
	br	b.t2
b.setstatus: b.monitor: b.setparm:
	mov	#1,r0
	tst	(r4)+
	mov	#fblk+4,r3
	mov	r5,r2
	cmp	(r2)+,(r2)+
b.t2:	mov	(r4)+,r1
	bic	#200,r1
	cmp	r1,#1023
	bne	argerr
	mov	(r2)+,(r3)+
	dec	r0
	bgt	b.t2
	br	b.call
b.parallel:
	cmp	2(r4),#1023
	bne	argerr
	;br	b.call

b.call: mov	r5,-(sp)
	mov	#fblk,r5
	jsr	pc,gpib0
	mov	(sp)+,r5
	cmp	r0,#ENONE
	blt	b10$
	mov	@2(r5),r1
	asl	r1
	jmp	@postbl(r1)

b.rd:	tst	r0
	bpl	1$
	clr	r0
1$:	mov	#100,r1
	jsr	pc,$alc
	bcs	b11$
	mov	#tmpstr,r3
2$:	dec	r1
	bmi	3$
	movb	(r3)+,(r0)+
	br	2$
3$:	mov	sp,r0
	mov	strref,r1
	jsr	pc,$store
	jsr	pc,$dealc
	rts	pc
b.pp: b.rc: b.sr:
	mov	r0,@4(r5)
b.rtn:	rts	pc
b9$:	mov	#ENOFUN,r0
b10$:	com	r0
b11$:	asl	r0
	mov	bemsg(r0),r1
	jsr	pc,$bomb
	;no return

bemsg:	bemsg1, emsg2, emsg3, emsg4, emsg5, emsg6, emsg7, emsg8, emsg9
	emsg10, emsg11, emsg12, emsg13, emsg14, emsg15, emsg16
bemsg1: .asciz	/alc--no space/
emsg2:	.asciz	/CAC conflict/
emsg3:	.asciz	/not CAC/
emsg4:	.asciz	/not SAC/
emsg5:	.asciz	/IFC abort/
emsg6:	.asciz	/timeout/
emsg7:	.asciz	/bad fctn code/
emsg8:	.asciz	/?/
emsg9:	.asciz	/no listeners/
emsg10: .asciz	/bcr error/
emsg11: .asciz	/no PP/
emsg12: .asciz	/ir timeout/
emsg13: .asciz	/ir nex memory/
emsg14: .asciz	/nex memory/
emsg15: .asciz	/bar-bcr error/
emsg16: .asciz	/umr error/
emsg17: .asciz	/open err/
	.even
	.csect	gpib
tmpstr: .blkb	256.
strref: 0
fblk:	.blkw	8.
	.csect
bcntbl: .byte	2, 3, 5, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 3, 1
fcntbl: .byte	3, 4, 5, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 3, 1
pretbl: b.command, b.write, b.read, b.call, b.call, b.call, b.call
	b.parallel, b.call, b.setstatus, b.monitor, b.call, b.setparm
	b.call, b.call
postbl: b.rtn, b.rtn, b.rd, b.rtn, b.rtn, b.rtn, b.rtn, b.pp, b.rtn
	b.rtn, b.rtn, b.rc, b.rtn, b.sr, b.rtn
.endc

gpib0:
.endc

				;gpib(f,a1,a2,a3,a4)
	tst	ib+chan		;	if(ib.chan<0 && (x=ibopen())<0)
	bpl	1$		;		return x;
	jsr	pc,ibopen
	bcs	10$
1$:	mov	@2(r5),r0	;	if(f<0 || f>=NFNS) return ENOFUN;
	cmp	r0,#NFNS
	bhis	9$
	asl	r0		;	return (*ibfn[f])(a1,a2,a3,a4);
	jmp	@ibfn(r0)
9$:	mov	#ENOFUN,r0
10$:	rts	pc

ibfn:				;int (*ibfn[])()= {
	command			;	&command,	&write,		&read,		&transfer,
	write			;	&clear,		&remote,	&local,		&parallel,
	read			;	&passcontrol,	&setstatus,	&monitor,	&readcommand,
	transfer		;	&setparameters, &testsrq,	&finish		};
	clear
	remote
	local
	parallel
	passcontrol
	setstatus
	monitor
	readcommand
	setparameters
	testsrq
	finish
	status
	spbyte
NFNS=	<.-ibfn>/2

ibopen:				;ibopen()
.if eq,DVR-1
	.lookup #area, #RTCHAN, #devblk
	bcs	10$
	mov	#RTCHAN,ib+chan
	rts	pc
10$:	mov	#EOPEN,r0
	rts	pc
area:	.blkw	12.
devblk: .rad50	/IB/
	.word	0, 0, 0
.endc
.if eq,DVR-2
	alun$s	#RSXCHAN, #"IB, #0
	bcs	10$
	mov	#RSXCHAN,ib+chan
	mov	#RSXEFN,ib+efn
	rts	pc
10$:	mov	#EOPEN,r0
	rts	pc
.endc

command:			;command(bp,n) char bp[n];
	spfn	COM, 4(r5), @6(r5)
	rts	pc

status:				;status(bp,n) char bp[n];
	spfn	STA, 4(r5), @6(r5)
	rts	pc

write:				;write(bp,n,mode) char bp[n];
	cmpb	ib+wmd,@10(r5)
	beq	1$
	movb	@10(r5),ib+wmd
	jsr	pc,setmodes
	tst	r0
	bmi	10$
1$:	spfn	WT, 4(r5), @6(r5)
10$:	rts	pc

read:				;read(bp,n,mode,eod) char bp[n];
	movb	@10(r5),r0
	cmpb	r0,ib+rmd
	bne	1$
	bit	#2,r0
	beq	2$
	cmpb	@12(r5),ib+eod
	beq	2$
1$:	movb	r0,ib+rmd
	movb	@12(r5),ib+eod
	jsr	pc,setmodes
	tst	r0
	bmi	10$
2$:	spfn	RD, 4(r5), @6(r5)
10$:	rts	pc

setmodes:
	movb	ib+rmd,r0
	.rept	4
	asl	r0
	.endr
	bic	#177417,r0
	mov	r0,worksp
	movb	ib+wmd,r0
	bic	#177760,r0
	bis	r0,worksp
	movb	ib+eod,worksp+1
	movb	ib+timo,worksp+2
.if eq,DVR-2
	spfn	SPM, worksp, worksp+2
.endc
.if eq,DVR-1
	spfn	SPM, #worksp, #3
.endc
	rts	pc

transfer:			;transfer()
	spfn	TR
	rts	pc

clear:				;clear()
	spfn	CL
	rts	pc

remote:				;remote()
	spfn	REM
	rts	pc

local:				;local()
	spfn	LOC
	rts	pc

parallel:			;parallel()
	spfn	PP
	rts	pc

passcontrol:			;passcontrol()
	spfn	PCT
	rts	pc

spbyte:				;spbyte(s)
	spfn	SPB, 0, @4(r5)
	rts	pc

setstatus:			;setstatus(s)
	spfn	SST, 0, @4(r5)
	rts	pc

setparameters:			;setparameters(t)
	movb	@4(r5),ib+timo
	jsr	pc,setmodes
	rts	pc

testsrq:			;testsrq()
	spfn	TSR, 0, @4(r5)
	rts	pc

monitor:			;monitor(m)
	spfn	MON, 0, @4(r5)
	rts	pc

readcommand:			;readcommand()
	spfn	RDC
	rts	pc

finish:				;finish()
	spfn	FIN
	;br	ibclose

ibclose:
.if eq,DVR-1
	mov	r0,r1
	.close	ib+chan
	mov	r1,r0
.endc
	mov	#-1,ib+chan
	rts	pc

worksp: 0,0

size= .-begin
	.end
                                          