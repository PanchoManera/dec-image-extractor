	.enabl  lc
	.title  IBUP - GPIB11-Series Interface Utility Routine
	.nlist  bex, ttm, cnd

;       This software is provided solely for use with
;       the National Instruments GPIB11-series interfaces.

;       Copyright 1980 National Instruments

;       Jeffrey Kodosky
;       April   1980
;       Edit    09/26/81
;       REV C:  01/01/82
;       REV D:  01/01/83
;       V1:     02/22/83        IBUP POLL -1 now passes a 0 to GPIB TESTSRQ

; Edit the following assignments to reflect the desired software environment.
BASIC=  0       ; 0 for FORTRAN/MACRO interface, 1 for BASIC
DVR=    1       ; 1 if driver is an RT handler, 2 if RSX handler, 0 otherwise.


; Command Messages
DCL=    024
GET=    010
GTL=    001
LLO=    021
PPC=    005
PPD=    0160
PPE0=   0140
PPU=    025
SDC=    004
SPD=    031
SPE=    030
TCT=    011
UNL=    077
UNT=    0137

; Error Codes
OK=          1
ENOTSAC=    -4
ENOFUN=    -20.
ENODEV=    -21.
ENOLAD=    -22.
ENOTAD=    -23.

r0=%0
r1=%1
r2=%2
r3=%3
r4=%4
r5=%5
sp=%6
pc=%7

	.macro  device ta la sa rd eod wt
.narg na
.if ne,na
  .if ne,ta
  .iif lt,ta-0100, .error illegal GPIB Talk address
  .iif ge,ta-0137, .error illegal GPIB Talk address
  .endc
	.byte   ta
  .if ne,la
  .iif lt,la-040, .error illegal GPIB Listen address
  .iif ge,la-077, .error illegal GPIB Listen address
  .endc
	.byte   la
  .if ne,sa
  .iif lt,sa-0140, .error illegal GPIB Secondary address
  .iif ge,sa-0177, .error illegal GPIB Secondary address
  .endc
	.byte   sa
	.byte   rd, eod, wt
.iff
	.byte   0,0,0,0,0,0
.endc
	.endm   device

	.macro  callf subr a0p a1p a2p a3p a4p a5p a6p a7p
na=0
	jsr     r5,rsav
.irp    ap,<a7p,a6p,a5p,a4p,a3p,a2p,a1p,a0p>
.if nb,ap
	mov     ap,-(sp)
na= na+1
.endc
.endr
	mov     #na,-(sp)
	mov     sp,r5
	jsr     pc,subr
.if eq,na
	tst     (sp)+
.iff
.iif eq,na-1,   cmp     (sp)+,(sp)+
.iif ne,na-1,   add     #<na+1>*2,sp
.endc
	jsr     r5,rres
	.endm   callf

	.macro  mul6 x
	asl     x
	mov     x,-(sp)
	asl     x
	add     (sp)+,x
	.endm   mul6

	.macro  Exclude
.iif eq,DVR-2,  jsr     pc,excl
	.endm   Exclude

	.macro  Unexclude
.iif eq,DVR-2,  jsr     pc,unexcl
	.endm   Unexclude

	.macro  Sx instr src dst
.if nb,dst
	instr   ib11+devtbl+src,dst
.iff
	instr   ib11+devtbl+src
.endc
	.endm   Sx

	.macro  cjmp t f
	.macro  j't' a ?b
	b'f'    b
	jmp     a
b:
	.endm   j't'
	.macro  j'f' a ?b
	b't'    b
	jmp     a
b:
	.endm   j'f'
	.endm   cjmp
	.irp    j,<<eq,ne>,<cc,cs>>
	cjmp    j
	.endr

ib11:   .word   0, NDV-1
; Device table
; One line per device, the GPIB interface must be the 0-th entry.
; Format is:
;       device  Talk_adr Listen_adr Secondary_adr Read_mode Eod_char Write_mode

	device  'U, '5, 0, 0, 0, 0      ; GPIB interface: must be entry 0.
	device                          ; empty slot
	device                          ; empty slot
	device                          ; empty slot
	device                          ; empty slot
	device                          ; empty slot
	device                          ; empty slot
	device                          ; empty slot
	device                          ; empty slot
NDV= <.-ib11-4>/6

open=0                  ;struct ib11 {
ndev=2                  ;       int     open, ndev;
devtbl=4                ;       struct device {
tad=0                   ;               char    tad, lad, sad;  /* GPIB addresses */
lad=1
sad=2
rmd=3                   ;               char    rmd, eod, wmd;  /* read write modes */
eod=4                   ;               } devtbl[ndev+1];
wmd=5                   ;       } ib11;

NFNS=   11.

begin= .
	.globl  ibup, gpib
ibup:

.if ne,BASIC
.if eq,DVR-2
	jsr     pc,ibup0
	mov     @2(r5),r1       ; if called with extra arg then put return value in
	cmp     r1,#NFNS
	bcc     1$
	cmpb    @r5,fcntbl(r1)
	ble     1$
	movb    @r5,r1
	beq     1$
	asl     r1
	add     r5,r1
	mov     r0,@(r1)+
1$:     rts     pc

fcntbl: .byte   4,4,2,2,2,2,2,4,2,7,1
	.even
.iff
	.globl  $arger,$bomb,$find,$alc,$store,$dealc,$msg
	cmpb    1(r5),#202
	jne     ibup0
	mov     @-2(r5),r4
	bic     #200,r4
	cmp     r4,#1023
	bne     argerr
	mov     @2(r5),r0
	cmp     r0,#NFNS
	jcc     b9$
	cmpb    @r5,bcntbl(r0)
	bne     argerr
	movb    fcntbl(r0),fblk
	mov     2(r5),fblk+2
	mov     -2(r5),r4
	cmpb    fblk,#1
	ble     1$
	mov     2(r4),r3
	bic     #200,r3
	cmp     r3,#1023
	bne     argerr
	mov     4(r5),fblk+4
1$:     asl     r0
	jmp     @pretbl(r0)

b.write:mov     4(r4),r4
	bit     #1,r4
	bne     argerr
	mov     (r4)+,r1
	mov     @r4,r0
	bic     #200,r1
	cmp     r1,#1100
	bne     argerr
	mov     #100,r1
	jsr     pc,$find
	mov     r0,fblk+6
	mov     #fblk+14.,fblk+8.
	mov     r1,fblk+14.
	br      b.call
b.read: cmp     (r4)+,(r4)+
	mov     (r4)+,r3
	bit     #1,r3
	bne     argerr
	cmp     (r3)+,#1100
	bne     argerr
	mov     @r3,strref
	mov     #tmpstr,fblk+6
	mov     #fblk+8.,r3
	mov     r5,r2
	add     #8.,r2
	mov     #1,r0
	br      b.t2

argerr: jmp     $arger

b.configure:mov #2,r0
	br      b.t1
b.define:mov    #5,r0
b.t1:   mov     #fblk+6,r3
	mov     r5,r2
	add     #6,r2
	cmp     (r4)+,(r4)+
b.t2:   mov     (r4)+,r1
	bic     #200,r1
	cmp     r1,#1023
	bne     argerr
	mov     (r2)+,(r3)+
	dec     r0
	bgt     b.t2
	br      b.call
b.poll: cmp     4(r4),#1023
	bne     argerr
	;br     b.call

b.call: mov     r5,-(sp)
	mov     #fblk,r5
	jsr     pc,ibup0
	mov     (sp)+,r5
	cmp     r0,#ENOFUN
	ble     b10$
	mov     @2(r5),r1
	asl     r1
	jmp     @postbl(r1)

b.rd:   tst     r0
	bpl     1$
	clr     r0
1$:     mov     #100,r1
	jsr     pc,$alc
	bcs     b11$
	mov     #tmpstr,r3
2$:     dec     r1
	bmi     3$
	movb    (r3)+,(r0)+
	br      2$
3$:     mov     sp,r0
	mov     strref,r1
	jsr     pc,$store
	jsr     pc,$dealc
	rts     pc

b.pp:   mov     r0,@6(r5)
b.rtn:  rts     pc

b9$:    mov     #ENOFUN,r0
b10$:   com     r0
	add     #ENOFUN+1,r0
b11$:   asl     r0
	mov     emsg(r0),r1
	jsr     pc,$bomb
	;no return

emsg:   bemsg1,emsg2,emsg3,emsg4,emsg5
bemsg1: .asciz  /alc--no space/
emsg2:  .asciz  /bad ibup fctn code/
emsg3:  .asciz  /no device/
emsg4:  .asciz  /device not L/
emsg5:  .asciz  /device not T/
	.even
	.csect  gpib
tmpstr: .blkb   256.
strref: 0
fblk:   .blkw   8.
	.csect
bcntbl: .byte   3,4,2,2,2,2,3,4,2,7,1
fcntbl: .byte   4,4,2,2,2,2,2,4,2,7,1
pretbl: b.write, b.read, b.call, b.call, b.call, b.call, b.poll, b.configure
	b.call, b.define, b.call
postbl: b.rtn, b.rd, b.rtn, b.rtn, b.rtn, b.rtn, b.pp, b.rtn, b.rtn, b.rtn, b.rtn
.endc

ibup0:
.endc
				;ibup(f,d,a2,a3,a4)
	tst     ib11            ;       if(ib11.open==0 && (x=init())<0) return x;
	bne     1$
	jsr     pc,init
	bcs     10$
1$:     mov     @2(r5),r0       ;       if(f<0 || f>=NFNS) return ENOFUN;
	cmp     r0,#NFNS
	bhis    9$
	cmpb    @r5,#1          ;       if(nargs()>1 && (d>ib11.ndev || d<lb[f]))
	ble     2$              ;               return ENODEV;
	mov     @4(r5),r1
	cmp     r1,ib11+ndev
	bgt     11$
	cmpb    r1,lb(r0)
	blt     11$
	mul6    r1
2$:     asl     r0              ;       return (*ibfn[f])(d,a2,a3,a4);
	jmp     @ibfn(r0)
9$:     mov     #ENOFUN,r0
10$:    rts     pc
11$:    mov     #ENODEV,r0
	rts     pc

ibfn:                           ; int (*ibfn[])()= {
	write                   ;       &write,     &read,      &clear,
	read                    ;       &trigger,   &remote,    &local,
	clear                   ;       &poll,      &configure, &passcontrol,
	trigger                 ;       &define,    &finish     };
	remote
	local
	poll
	configure
	passcontrol
	define
	finish
lb:     .byte 1, 1, -1, 0, -1, -1, -1, 0, 1, 0, 0
	.even

init:                           ;init()
	callf   gpib #Clearg    ;       if((x=gpib(Clearg))>=0)
	tst     r0
	bmi     1$
	callf   gpib #Remotg    ;               x= gpib(Remotg);
	tst     r0              ;       if(x<0 && x!=ENOTSAC) return x;
	bpl     2$
1$:     cmp     r0,#ENOTSAC
	beq     2$
	sec
	rts     pc
2$:     inc     ib11            ;       ib11.open++;
	clr     r0              ;       return OK;
	rts     pc

write:                          ;write(d,bp,n) char bp[n];
	mov     #cbf,r0         ;       s= &cbf[0];
	movb    #UNL,(r0)+      ;       *s++= UNL;
	movb    #UNT,(r0)+      ;       *s++= UNT;
    Sx  movb    tad,(r0)+       ;       *s++= ib11.devtbl[0].tad;
    Sx  movb    sad,@r0         ;       if(*s= ib11.devtbl[0].sad) s++;
	beq     1$
	inc     r0
1$:     jsr     pc,ltns         ;       if((s= ltns(s,d))<0) return s;
	bcs     10$
	Exclude                 ;       exclude();
	jsr     pc,cmd          ;       if((x=cmd(s))<0 ||
	tst     r0
	bmi     2$
    Sx  movb    wmd(r1),mode    ;               (x= ans= gpib(Writeg,bp,n,ib11.devtbl[d].wmd))<0
	callf   gpib #Writeg 6(r5) 10(r5) #mode
	mov     r0,r1           ;               || (x=gtsun())<0) ans= x;
	bmi     2$
	jsr     pc,gtsun
	tst     r0
	bmi     2$
	mov     r1,r0
2$:     Unexclude               ;       unexclude();
10$:    rts     pc              ;       return ans;

read:                           ;read(d,bp,n) char bp[n];
	mov     #cbf,r0         ;       s= &cbf[0];
	movb    #UNL,(r0)+      ;       *s++= UNL;
	movb    #UNT,(r0)+      ;       *s++= UNT;
    Sx  movb    tad(r1),(r0)+   ;       if((*s++= ib11.devtbl[d].tad)==0)
	beq     10$             ;               return ENOTAD;
    Sx  movb    sad(r1),@r0     ;       if(*s= ib11.devtbl[d].sad) s++;
	beq     1$
	inc     r0
1$: Sx  movb    lad,(r0)+       ;       *s++= ib11.devtbl[0].lad;
    Sx  movb    sad,@r0         ;       if(*s= ib11.devtbl[0].sad) s++;
	beq     4$
	inc     r0
4$:     Exclude                 ;       exclude();
	jsr     pc,cmd          ;       if((x=cmd(s))<0 ||
	tst     r0
	bmi     2$
    Sx  movb    rmd(r1),mode    ;               (x= ans= gpib(Readg,bp,n,ib11.devtbl[d].rmd,ib11.devtbl[d].eod))<0
    Sx  movb    eod(r1),mode+2
	callf   gpib #Readg 6(r5) 10(r5) #mode #mode+2
	mov     r0,r1           ;               || (x=gtsun())<0) ans= x;
	bmi     2$
	jsr     pc,gtsun
	tst     r0
	bmi     2$
	mov     r1,r0
2$:     Unexclude               ;       unexclude();
	rts     pc              ;       return ans;
10$:    mov     #ENOTAD,r0
	rts     pc

clear:                          ;clear(d)
	tst     r1              ;       if(d<0) return gpib(Clear);
	bpl     1$
	callf   gpib #Clearg
	rts     pc
1$:     mov     #cbf,r0         ;       s= &cbf[0];
	tst     r1              ;       if(d)   *s++= UNL;
	beq     3$
	movb    #UNL,(r0)+
	movb    #UNT,(r0)+      ;               *s++= UNT;
	jsr     pc,ltns         ;               if((s= ltns(s,d))<0) return s;
	bcs     10$
	movb    #SDC,(r0)+      ;               *s++= SDC;
	br      5$
3$:     movb    #DCL,(r0)+      ;       else *s++= DCL;
5$:     jmp     cmd             ;       return cmd(s);
10$:    rts     pc

trigger:                        ;trigger(d)
	mov     #cbf,r0         ;       s= &cbf[0];
	movb    #UNL,(r0)+      ;       *s++= UNL;
	movb    #UNT,(r0)+      ;       *s++= UNT;
	jsr     pc,ltns         ;       if((s= ltns(s,d))<0) return s;
	bcs     10$
	movb    #GET,(r0)+      ;       *s++= GET;
	jmp     cmd             ;       return cmd(s);
10$:    rts     pc

remote:                         ;remote(d)
	callf   gpib #Remotg    ;       if((x=gpib(Remote))<0) return x;
	tst     r0
	bmi     10$
	mov     #cbf,r0         ;       s= &cbf[0];
	tst     r1              ;       if(d<0) *s++= LLO; d++;
	bpl     1$
	movb    #LLO,(r0)+
	add     #6,r1
1$:     jsr     pc,ltns         ;       if((s= ltns(s,d))<0) return s;
	bcs     10$
	jmp     cmd             ;       return cmd(s);
10$:    rts     pc

local:                          ;local(d)
	tst     r1              ;       if(d<0) return gpib(Local);
	bpl     1$
	callf   gpib #Localg
	rts     pc
1$:     mov     #cbf,r0         ;       s= &cbf[0];
	movb    #UNL,(r0)+      ;       *s++= UNL;
	movb    #UNT,(r0)+      ;       *s++= UNT;
	jsr     pc,ltns         ;       if((s= ltns(s,d))<0) return s;
	bcs     10$
	movb    #GTL,(r0)+      ;       *s++= GTL;
	jmp     cmd             ;       return cmd(s);
10$:    rts     pc

poll:                           ;poll(d)
	tst     r1              ;       if(d<0) return gpib(Testsrq, 0);
	bpl     1$
	callf   gpib #Testsrq #zero
	rts     pc
1$:     bgt     2$              ;       if(d==0) return gpib(Parallel);
	callf   gpib #Parallel
	rts     pc
2$:     mov     #cbf,r0         ;       s= &cbf[0];
	movb    #UNL,(r0)+      ;       *s++= UNL;
	movb    #UNT,(r0)+      ;       *s++= UNT;
	movb    #SPE,(r0)+      ;       *s++= SPE;
    Sx  movb    tad(r1),(r0)+   ;       if((*s++= ib11.devtbl[d].tad)==0)
	beq     10$             ;               return ENOTAD;
    Sx  movb    sad(r1),@r0     ;       if(*s= ib11.devtbl[d].sad) s++;
	beq     5$
	inc     r0
5$: Sx  movb    lad,(r0)+       ;       *s++= ib11.devtbl[0].lad;
    Sx  movb    sad,@r0         ;       if(*s= ib11.devtbl[0].sad) s++;
	beq     6$
	inc     r0
6$:     Exclude                 ;       exclude();
	jsr     pc,cmd          ;       if((x=cmd(s))>=0
	tst     r0
	bmi     3$              ;               && (x=gpib(Readg, &mode, 1,0,0))>=0
	callf   gpib #Readg #mode #one #zero #zero
	tst     r0
	bmi     3$
	mov     #cbf,r0         ;               && (cbf[0]=SPD, (x=cmd(&cbf[1]))>=0))
	movb    #SPD,(r0)+
	jsr     pc,cmd
	tst     r0
	bmi     3$
	mov     mode,r0         ;               x= mode;
3$:     Unexclude               ;       unexclude();
	rts     pc              ;       return x;
10$:    mov     #ENOTAD,r0
	rts     pc

configure:                      ;configure(d,sense,line)
	mov     #cbf,r0         ;       s= &cbf[0];
	tst     r1              ;       if(d)   *s++= UNL;
	beq     2$
	movb    #UNL,(r0)+
	movb    #UNT,(r0)+      ;               *s++= UNT;
	jsr     pc,ltns         ;               if((s= ltns(s,d))<0) return s;
	bcs     10$
	movb    #PPC,(r0)+      ;               *s++= PPC;
	movb    #PPE0,@r0       ;               if(sense>=0) *s++= PPE0 | (line-1)&7 | (sense? 010:0);
	mov     @6(r5),r1
	bmi     44$
	beq     1$
	bisb    #010,@r0
1$:     mov     @10(r5),r1
	dec     r1
	bic     #177770,r1
	bisb    r1,(r0)+
	br      4$
44$:    movb    #PPD,(r0)+      ;               else    *s++= PPD;
	br      4$
2$:     movb    #PPU,(r0)+      ;       else *s++= PPU;
4$:     jmp     cmd             ;       return cmd(s);
10$:    rts     pc

passcontrol:                    ;passcontrol(d)
	mov     #cbf,r0         ;       s= &cbf[0];
	movb    #UNL,(r0)+      ;       *s++= UNL;
	movb    #UNT,(r0)+      ;       *s++= UNT;
    Sx  movb    tad(r1),(r0)+   ;       if((*s++= ib11.devtbl[d].tad)==0)
	beq     11$             ;               return ENOTAD;
    Sx  movb    sad(r1),@r0     ;       if(*s= ib11.devtbl[d].sad) s++;
	beq     1$
	inc     r0
1$:     movb    #TCT,(r0)+      ;       *s++= TCT;
	Exclude                 ;       exclude();
	jsr     pc,cmd          ;       if((x=cmd(s))>=0)
	tst     r0
	bmi     10$
	callf   gpib #Passg     ;               x= gpib(Passg);
10$:    Unexclude               ;       unexclude();
	rts     pc              ;       return x;
11$:    mov     #ENOTAD,r0
	rts     pc

define:                         ;define(d,tad,lad,sad,rmd,eod,wmd)
	add     #ib11+devtbl,r1
	movb    @6(r5),r2       ;       if(tad && (tad<0100 || tad>=0137))
	beq     1$              ;               return ENOTAD;
	cmpb    r2,#0100
	blt     11$
	cmpb    r2,#0137
	bge     11$
1$:     movb    @10(r5),r3      ;       if(lad && (lad<040 || lad>=077))
	beq     2$              ;               return ENOLAD;
	cmpb    r3,#040
	blt     12$
	cmpb    r3,#077
	bge     12$
2$:     movb    @12(r5),r4      ;       if(sad && (sad<0140 || sad>=0177))
	beq     3$              ;               return ENOTAD;
	cmpb    r4,#0140
	blt     11$
	cmpb    r4,#0177
	bge     11$
3$:     movb    r2,(r1)+        ;       ib11.devtbl[d].tad= tad;
	movb    r3,(r1)+        ;       ib11.devtbl[d].lad= lad;
	movb    r4,(r1)+        ;       ib11.devtbl[d].sad= sad;
	movb    @14(r5),(r1)+   ;       ib11.devtbl[d].rmd= rmd;
	movb    @16(r5),(r1)+   ;       ib11.devtbl[d].eod= eod;
	movb    @20(r5),@r1     ;       ib11.devtbl[d].wmd= wmd;
	mov     #OK,r0          ;       return OK;
	rts     pc
11$:    mov     #ENOTAD,r0
	rts     pc
12$:    mov     #ENOLAD,r0
	rts     pc

finish:                         ;finish()
	clr     ib11            ;       ib11.open= 0;
	callf   gpib #Finshg    ;       return gpib(Finshg);
	rts     pc

zero:
Command: 0
one:
Writeg:  1
Readg:   2
Transfg: 3
Clearg:  4
Remotg:  5
Localg:  6
Parallel:7
Passg:   8.
Testsrq: 13.
Finshg:  14.

cbf:    .blkb   35.     ; 2*max number of devices +7
	.even
cnt:    0
mode:   0,0

ltns:                           ;ltns(s,d) char *s;
	tst     r1              ;       if(d)   if((*s++= ib11.devtbl[d].lad)==0)
	beq     1$              ;                       return ENOLAD;
    Sx  movb    lad(r1),(r0)+
	beq     11$
    Sx  movb    sad(r1),@r0     ;               if(*s= ib11.devtbl[d].sad) s++;
	beq     10$
	inc     r0
	br      10$
1$:     mov     ib11+ndev,r2    ;       else for(d++, n=ib11.ndev; n-->0; d++)
	beq     10$
2$:     add     #6,r1
    Sx  movb    lad(r1),@r0     ;               if(*s= ib11.devtbl[d].lad)
	beq     4$
	inc     r0              ;                       s++;
    Sx  movb    sad(r1),@r0     ;                       if(*s= ib11.devtbl[d].sad) s++;
	beq     4$
	inc     r0
4$:     dec     r2
	bgt     2$
10$:    clc                     ;       return s;
	rts     pc
11$:    mov     #ENOLAD,r0
	sec
	rts     pc

cmd:    sub     #cbf,r0         ;cmd(s)
	mov     r0,cnt          ;       return gpib(Command, &cbf[0], s- &cbf[0]);
	callf   gpib #Command #cbf #cnt
	tst     r0
	bmi     1$
	mov     #OK,r0
1$:     rts     pc

gtsun:  mov     #cbf,r0         ;gtsun()
	movb    #UNL,(r0)+      ;       s= &cbf[0];
	movb    #UNT,(r0)+      ;       *s++= UNL; *s++= UNT;
	jsr     pc,cmd          ;       if((x=cmd(s))<0) return x;
	tst     r0
	bmi     10$
	callf   gpib #Transfg   ;       return gpib(Transfer);
10$:    rts     pc

rsav:   .irp    a,<r4,r3,r2,r1,10(sp)>
	mov     a,-(sp)
	.endr
	rts     r5
rres:   tst     (sp)+
	.irp    a,<r1,r2,r3,r4>
	mov     (sp)+,a
	.endr
	rts     r5

.if eq,DVR-2
	.mcall  qiow$s
excl:   mov     r0,-(sp)
	mov     #3*256.,r0      ; IO.ATT
	br      exq
unexcl: mov     r0,-(sp)
	mov     #4*256.,r0      ; IO.DET
exq:    qiow$s  r0, ib+chan, ib+efn
	mov     (sp)+,r0
	rts     pc

	.csect  ibudp
ib:                     ;struct ib {    int chan,efn,iost[2];
chan=0
efn=2
	.csect
.endc

size= .-begin
	.end
                                                                                                                                                                                                                                                                                                                                                                                      