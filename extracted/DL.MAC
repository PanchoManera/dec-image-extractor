.MCALL .MODULE
.MODULE	DL,VERSION=21,COMMENT=<RL01/RL02 Disk Handler>,AUDIT=YES

;                   COPYRIGHT (c) 1984,1985,1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
.SBTTL	CONDITIONAL ASSEMBLY SUMMARY
	.SBTTL	MACROS AND DEFINITIONS
	.ENABL	LC
	.MCALL	.DRDEF,	.MTPS,	.ASSUME, .ADDR, .BR
	NXM.V	=: 4
.IIF NDF VENU$C, VENU$C == 0
.IF NE MMG$T
.ASSUME	VENU$C EQ 0 MESSAGE=<; no VENUS support under extended memory >
.ENDC
.IF NE ERL$G
.ASSUME VENU$C EQ 0 MESSAGE=<; no VENUS support under error logger>
.ENDC
.IIF NDF DL$UN, DL$UN	== 2
.IIF GT	DL$UN-4, DL$UN	== 4
.IIF LE	DL$UN,	DL$UN	== 1
	.IRP	X,<\DL$UN>
	.SBTTL	*** THIS HANDLER SUPPORTS X UNITS ***
	.ENDR
.IIF NE VENU$C, FN$GET =: 370
	FN$SIZ	=: 373
	FN$REP	=: 374
	FN$WRT	=: 376
	FN$RED	=: 377
	DLRCNT	=: 8.
	DLREG	=: 6
	DLBPT	=: 20.
	DLWPT	=: 256.*DLBPT
	DLNBAD	=: 10.
	DLSIZE	=: <256.*2-1>*DLBPT-DLNBAD
	DLSIZ2	=: <512.*2-1>*DLBPT-DLNBAD
	DLTSIZ	=: DLNBAD*4.+2
.IF	EQ	VENU$C
	.DRDEF	DL,5,FILST$!SPFUN$!VARSZ$,DLSIZE,174400,160
	.DRPTR
	.DREST	CLASS=DVC.DK,REPLACE=RTABLE
.IFF
	.DRDEF	DL,5,FILST$!SPFUN$!VARSZ$,DLSIZ2,174400,130
	.DRPTR
	.DREST	CLASS=DVC.DK
.ENDC
	.DRSPF
.IIF NE VENU$C, .DRSPF <FN$GET>
	.DRSPF	<FN$SIZ>
	.DRSPF	<FN$REP>
	.DRSPF	<FN$WRT>
	.DRSPF	<FN$RED>
.IIF	NDF	EIS$I	EIS$I = MMG$T
.IIF	EQ	EIS$I	.MCALL	SOB
	.SBTTL	HARDWARE DEFINITIONS
.IF	EQ	VENU$C
	RLCS	=: 0
	RLBA	=: 2
	RLDA	=: 4
	RLMP	=: 6
	RLBAE	=: 10
.IFF
	RLCS	=: 174400
	RLBA	=: 174402
	RLDA	=: 174404
	RLMP	=: 174406
	RLBAE	=: 174410
.ENDC
	CSERR	=: 100000
	CSDE	=: 040000
	CSNXM	=: 020000
	CSDLT	=: 010000
	CSHNF	=: 010000
	CSDCRC	=: 004000
	CSHCRC	=: 004000
	CSOPI	=: 002000
	CSDS01	=: 001400
	CSDS0	=: 000400
	CSCRDY	=: 000200
	CSIE	=: 000100
	CSBA17	=: 000040
	CSBA16	=: 000020
	CSFUN	=: 000016
	CSDRDY	=: 000001
	FNNOP	=: 0*2
	FNWCHK	=: 1*2
	FNGSTS	=: 2*2
	FNSEEK	=: 3*2
	FNRDH	=: 4*2
	FNWRITE	=: 5*2
	FNREAD	=: 6*2
	FNRDNH	=: 7*2
	STWDE	=: 100000
	STCHE	=: 040000
	STWL	=: 020000
	STSKTO	=: 010000
	STSP	=: 004000
	STWGE	=: 002000
	STVC	=: 001000
	STDSE	=: 000400
	STDT	=: 000200
	STHS	=: 000100
	STCO	=: 000040
	STHO	=: 000020
	STBH	=: 000010
	STST	=: 000007
	STSLM	=: 000005
	SKCADF	=: 077600
	SKCA0	=: 000200
	SKHS	=: 000020
	SKDIR	=: 000004
	SKMARK	=: 000001
	IOCA	=: 077600
	IOCA0	=: 000200
	IOHS	=: 000100
	IOSA	=: 000077
	GSRST	=: 000010
	GSGS	=: 000002
	GSMARK	=: 000001
SYSPTR	=:	54
	CONFG2	=:	370
		PROS$	=:	020000
.READ	=:	375
	..READ	=:	010
.WRITE	=:	375
	..WRIT	=:	011
SYSCHN	=:	17
.IF	NE	VENU$C
	.SBTTL	QBUS/RL GENERIC ACCESS MACROS
	.MACRO	MOVTORL	SRC,DST
	.IIF	DIF	<SRC>,<R5>	MOV	SRC,R5
	JSR	R4,TORL
	.WORD	DST
	.ENDM	MOVTORL
	.MACRO 	MOVFMRL	SRC,DST
	JSR	R4,FMRL
	.WORD	SRC
	.IF	NB,DST
	.IIF	DIF	<DST>,<R5>	MOV	R5,DST
	.ENDC
	.ENDM	MOVFMRL
	.MACRO	HANTORL	SRC,DST
	.IIF	DIF	<SRC>,<R4>	MOV	SRC,R4
	CALL	HTORL
	.WORD	DST
	.ENDM	HANTORL
	.MACRO	HANFMRL	SRC,DST
	CALL	HFMRL
	.WORD	SRC
	.IIF	DIF	<DST>,<R4>	MOV	R4,DST
	.ENDM	HANFMRL
.ENDC
.IF	NE	VENU$C
	.SBTTL	QBUS Interface registers and bit definitions
	BIT0	=:	000001
	BIT1	=:	000002
	BIT2	=:	000004
	BIT3	=:	000010
	BIT4	=:	000020
	BIT5	=:	000040
	BIT6	=:	000100
	BIT7	=:	000200
	BIT8	=:	000400
	BIT9	=:	001000
	BIT10	=:	002000
	BIT11	=:	004000
	BIT12	=:	010000
	BIT13	=:	020000
	BIT14	=:	040000
	BIT15	=:	100000
	$QCSR0	=:	176400
	$QCSR1	=:	176401
	$QCSR2	=:	176402
	$QCSR3	=:	176403
	$QDAT0	=:	176404
	$QDAT1	=:	176405
	$QADR0	=:	176406
	$QADR1	=:	176407
	REQMASTER	=:	BIT0
	MSTRPEND	=:	BIT1
	QBAWRT		=:	BIT2
	QBAREAD		=:	BIT3
	QBAIE		=:	BIT4
	DMAENA		=:	BIT5
	QBAINIT		=:	BIT6
	DIAGMODE	=:	BIT7
.ENDC
.IF	EQ	VENU$C
	.SBTTL	INSTALLATION CODE
	.DRINS	DL
	BR	10$
				.ASSUME	. EQ INSSYS
	BR	20$
10$:	MOV	@#SYSPTR,R0
	BIT	#PROS$,CONFG2(R0)
	BNE	30$
20$:	TST	(PC)+
30$:	SEC
	RETURN
O.SYWL:
	MOV	@SP,R0
	INC	R0
	CMPB	#BR/400,(R0)+
	BNE	O.BAD
	MOV	R0,@SP
	BR	O.BAD
RTABLE:	.BYTE	0,10.,5.,2.,40.,1.
.Assume	. LE 400,MESSAGE=<;Install code overflow>
.ENDC
.IF	EQ	VENU$C
	.SBTTL	SET OPTIONS
	.DRSET	CSR,	160000,	O.CSR,	OCT
	.DRSET	VECTOR,	500,	O.VEC,	OCT
	.DRSET	RETRY,	DLRCNT,	O.RTRY,	NUM
	.IF NE ERL$G
	.DRSET	SUCCES,	-1,	O.SUCC,	NO
	.ENDC
	BTCSR	= <DLEND-DLSTRT>+<BOTCSR-DLBOOT>+1000
O.CSR:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,INSCSR
	MOV	R0,DISCSR
	.ADDR	#BAREA+4,R1
	.ADDR	#1000,R2
	MOV	R2,(R1)
	MOV	#BTCSR/1000,-(R1)
	TST	-(R1)
	MOV	R0,R3
	MOV	R1,R0
	EMT	.READ
	BCS	O.BAD
	MOV	R3,<BTCSR&777>(R2)
	MOV	R1,R0
					.ASSUME ..READ+1 EQ ..WRIT
	INCB	1(R0)
	EMT	.WRITE
	BCS	O.SYWL
	MOV	R1,R0
					.ASSUME ..WRIT-1 EQ ..READ
	DECB	1(R0)
	MOV	#1,2(R0)
	EMT	.READ
	BCS	O.BAD
	MOV	R3,DLCSR
O.GOOD:	TST	(PC)+
O.BAD:	SEC
	RETURN
O.VEC:	CMP	R0,R3
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	MOV	R0,DLSTRT
	BR	O.GOOD
O.RTRY:	MOV	R0,DRETRY
	BNE	O.GOOD
	BR	O.BAD
	.IF NE ERL$G
O.SUCC:	MOV	#0,R3
	MOV	R3,SCSFLG
	BR	O.GOOD
	.ENDC
BAREA:	.BYTE	SYSCHN,..READ
	.BLKW
	.BLKW
	.WORD	256.
	.WORD	0
.Assume	. LE 1000,MESSAGE=<;Set area overflow>
.ENDC
	.SBTTL	REQUEST ENTRY POINT
	.ENABL	LSB
	.DRBEG	DL
	MOV	DLCQE,R5
	MOV	(PC)+,R4
					.ASSUME .-DLSTRT LT 1000
DLCSR:	 .WORD	DL$CSR
	.IF NE MMG$T
	ASL	#100000
	BCC	30$
	.MTPS	#340
	MOV	@#NXM.V,-(SP)
	.ADDR	#$DLNXM,-(SP)
	MOV	(SP)+,@#NXM.V
	TST	RLBAE(R4)
	MOV	(SP)+,@#NXM.V
	ROL	-(SP)
	.MTPS	#0
	ROR	(SP)+
	BCS	30$
	 .IF EQ ERL$G
	MOV	#NOP,$RLV1A
	 .IFF
	MOV	#NOP,R0
	MOV	R0,$RLV1A
	MOV	R0,$RLV1B
	MOV	R0,$RLV1C
	 .ENDC
30$:
	.ENDC
	MOV	Q$FUNC(R5),R0
	MOVB	R0,R2
	BIC	#^C<7*400>,R0
	CMP	R0,#DL$UN*400
	BHIS	DLELNK
	MOV	R0,DLUNIT
					.ASSUME	CSDS01	EQ	3*400
	MOV	#FNREAD!CSIE,DLCODE
	.IF NE	MMG$T
	CMPB	R2,#FN$SIZ
	BEQ	102$
					.ASSUME Q$BLKN+4 EQ Q$BUFF
	CMP	(R5)+,(R5)+
					.ASSUME Q$BUFF+2 EQ Q$WCNT
	CALL	@$MPPTR
					.ASSUME Q$WCNT-2 EQ Q$BUFF
	MOV	(SP)+,-(R5)
					.ASSUME Q$BUFF-4 EQ Q$BLKN
	CMP	-(R5),-(R5)
	MOV	(SP)+,Q$PAR(R5)
	.ENDC
102$:
	.ADDR	#DLBBUF-<DLTSIZ+2>,R3
	SWAB	R0
1$:	ADD	#DLTSIZ+2,R3
	DEC	R0
	BPL	1$
	MOV	R3,(PC)+
DLCC:	 .WORD	0
	TST	(R3)+
					.ASSUME .+4 EQ DLUSIZ
.IF	EQ	VENU$C
	MOV	#DLSIZE,(PC)+
.IFF
	MOV	#DLSIZ2,(PC)+
.ENDC
DLUSIZ:	 .WORD	0
.IF	EQ	VENU$C
	CALL	DLGST
	TSTB	R1
	BPL	101$
	MOV	#DLSIZ2,DLUSIZ
101$:	TST	R0
	BMI	2$
	BIT	#STVC,R1
	BEQ	3$
2$:	MOV	#-1,-(R3)
	MOV	(R3)+,@R3
.IFF
	CMPB	R2,#FN$GET
	BEQ	DLGSTA
	CALL	DLGST
	TST	R0
	BMI	2$
	CALL	INVVC
	BR	3$
2$:	CALL	INVAL
.ENDC
3$:	CMPB	R2,#FN$REP
	BLT	DLGSIZ
	BEQ	4$
	BHI	5$
	TST	Q$WCNT(R5)
	BEQ	DLFLNK
	TST	@R3
	BPL	DLTRAN
4$:	MOV	#1,R1
	MOV	#DLTSIZ/2,R2
	CALL	DLSQUE
	.IF NE	MMG$T
	CLR	Q$PAR(R5)
	.ENDC
	MOV	#-1,@R3
	MOV	@R3,-(R3)
	BR	DLADDR
5$:	INCB	R2
					.ASSUME	FN$RED	EQ	377
	BEQ	DLADDR
	MOV	#FNWRITE!CSIE,DLCODE
	BR	DLADDR
DLELNK:	JMP	DLEROR
.IF	EQ	VENU$C
$DLNXM:	BIS	#1,2(SP)
	RTI
.ENDC
	.IF NE ERL$G
	.ASSUME .-DLSTRT LT 1000
SCSFLG:	.WORD	0
	.ENDC
	.DSABL	LSB
.IF	NE	VENU$C
	.SBTTL	GET SPECIAL DEVICE STATUS
DLGSTA:
	MOV	@R5,R4
	CMP	#4,R4
	BLO	DLELNK
	ASL	R4
	ADD	R4,PC
.370.X:
	.ASSUME . EQ .370.X+<0*2>
	BR	.370.0
	.ASSUME	. EQ .370.X+<1*2>
	BR	.370.1
	.ASSUME	. EQ .370.X+<2*2>
	BR	.370.2
	.ASSUME	. EQ .370.X+<3*2>
	BR	.370.3
	.ASSUME	. EQ .370.X+<4*2>
.370.4:
	CLRB	VOLCHK
	BR	DLFLNK
.370.3:
	MOV	R4,#0
.=.-2
VOLCHK:	.BLKB	1
NEWVOL:	.BLKB	1
	BR	DLFLNK
.370.2:
	CALL	DLGST
	CALL 	INVVC
	CALL 	DLRST
	CLRB	NEWVOL
	BR	.370.1
.370.0:
	CALL	DLGST
.370.1:
.IF	EQ	MMG$T
	MOV	Q$BUFF(R5),R4
	MOV	STATCS,(R4)+
	MOV	STATMP,(R4)+
	BR	DLFLNK
.IFF
	MOV	R5,R4
	MOV	STATCS,-(SP)
	CALL	@$PTWRD
	MOV	STATMP,-(SP)
	CALL	@$PTWRD
	BR	DLFLNK
.ENDC
INVVC:
	BIT	#STVC,R1
	BEQ	INVRET
INVAL:	MOV	#-1,-(R3)
	MOV	(R3)+,@R3
	MOVB	@PC,NEWVOL
	TSTB	VOLCHK
	BNE	DLELNK
INVRET:	RETURN
.ENDC
	.SBTTL	GET DEVICE SIZE
DLGSIZ:
	.IF EQ	MMG$T
	MOV	DLUSIZ,@Q$BUFF(R5)
	.IFF
	MOV	DLUSIZ,-(SP)
	MOV	R5,R4
	CALL	@$PTWRD
	.ENDC
DLFLNK:	JMP	DLQCOM
	.SBTTL	INITIALIZE FOR TRANSFER, SET FUNCTION CODE, FIX WORD COUNT
	.ENABL	LSB
DLTRAN:	TST	Q$WCNT(R5)
	BPL	1$
	NEG	Q$WCNT(R5)
	MOV	#FNWRITE!CSIE,DLCODE
1$:	MOV	DLCC,R0
2$:	TST	(R0)+
	MOV	(R0)+,R1
	BEQ	DLADDR
					.ASSUME Q$BLKN EQ 0
	CMP	R1,@R5
	BLO	2$
	MOV	Q$WCNT(R5),R2
	MOV	R2,R3
	ADD	#255.,R3
	CLRB	R3
	SWAB	R3
					.ASSUME Q$BLKN EQ 0
	ADD	@R5,R3
	CMP	R1,R3
	BHIS	DLADDR
	MOV	@R0,R1
	MOV	-(R0),R0
					.ASSUME Q$BLKN EQ 0
	SUB	@R5,R0
	BNE	3$
	INC	R0
	SWAB	R2
	BEQ	5$
	BR	4$
					.ASSUME Q$BLKN EQ 0
3$:	MOV	@R5,R1
4$:	MOV	R0,R2
5$:	SWAB	R2
	MOV	Q$BUFF(R5),R3
					.ASSUME Q$BLKN EQ 0
	ADD	R0,@R5
	SUB	R2,Q$WCNT(R5)
	MOV	R2,R0
	ASL	R0
	ADD	R0,Q$BUFF(R5)
	.IF NE	MMG$T
	MOV	Q$PAR(R5),DLBPAR
	BCC	6$
	ADD	#CSBA16,Q$PAR(R5)
6$:
	.ENDC
	CALL	DLSQUE
	.BR	DLADDR
	.DSABL	LSB
	.SBTTL	COMPUTE DISK ADDRESS AND START TRANSFER
	.ENABL	LSB
DLADDR:	MOV	R5,(PC)+
DLQPTR:	 .WORD	0
					.ASSUME Q$BLKN EQ 0
	MOV	@R5,R2
	BMI	DLELNK
	MOV	#DLBPT,R1
					.ASSUME	DLBPT	EQ	20.
	CLR	R0
	BR	2$
1$:	MOV	R2,R3
	BIC	#^C<17>,R2
	BIC	R2,R3
	ADD	R3,R0
					.ASSUME	IOHS/2/2 EQ	16.
	ASR	R3
	ASR	R3
	SUB	R3,R2
2$:	CMP	R2,R1
	BHIS	1$
	ASL	R0
	BIS	R2,R0
	ASL	R0
	BCS	DLELNK
	BPL	3$
	CMP	DLUSIZ,#DLSIZ2
	BNE	DLELNK
3$:	MOV	R0,DLDA
	SUB	R2,R1
	SWAB	R1
	MOV	R1,DLWTRK
	.IF NE	ERL$G
	MOV	Q$WCNT(R5),DLWC
	.ENDC
	MOV	#1,(PC)+
DLRTY:	 .WORD	0
	CALL	DLRST
	CALL	DLGST
	BMI	DLERJM
	ASR	R0
					.ASSUME	CSDRDY	EQ	1
	BCC	DLERJM
	BIC	#STWL!STHS!STDT,R1
	CMP	#STHO!STBH!STSLM,R1
	BNE	DLERJM
DRETRY	= .+2
	MOV	#DLRCNT,DLRTY
					.ASSUME .-DLSTRT-2 LT 1000
	.BR	DLTRAK
	.DSABL	LSB
	.SBTTL	ENSURE THAT DISK IS ON TRACK BEFORE TRANSFER
	.ENABL	LSB
DLTRAK:	CLR	(PC)+
DLREV:	 .WORD	0
	MOV	@DLCC,R1
	CMP	#-1,R1
	BNE	2$
	MOV	DRETRY,R2
	ASL	R2
1$:	MOV	#FNRDH,R1
	CALL	DLXCT
	BPL	2$
	SOB	R2,1$
	INCB	DLREV
DLERJM:	JMP	DLERRH
2$:	MOV	DLDA,R0
	MOV	#IOSA,R2
	BIC	R2,R0
	BIC	R2,R1
	CMP	R0,R1
	BEQ	DLXFER
	MOV	R0,R3
	INC	R2
					.ASSUME	IOHS	EQ	IOSA+1
	BIC	R2,R0
	BIC	R2,R1
	SUB	R0,R1
					.ASSUME	SKCADF	EQ	IOCA
	BHIS	3$
	NEG	R1
	BIS	#SKDIR,R1
3$:	INC	R1
					.ASSUME	SKMARK	EQ	1
	BIT	R2,R3
	BEQ	4$
	BIS	#SKHS,R1
4$:	MOV	#-1,@DLCC
	CALL	DLSEEK
	BMI	DLERRH
	MOV	DLDA,@DLCC
	.BR	DLXFER
	.DSABL	LSB
	.SBTTL	DLXFER - START AN I/O TRANSFER
	.ENABL	LSB
DLXFER:
.IF	EQ	VENU$C
	ADD	#RLMP,R4
.ENDC
	ADD	#Q$WCNT,R5
	MOV	(PC)+,R3
DLWTRK:	 .WORD	0
	CMP	R3,@R5
	BLOS	1$
	MOV	@R5,R3
1$:	MOV	R3,(PC)+
DLWC:	 .WORD	0
	NEG	R3
.IF	EQ	VENU$C
	MOV	R3,@R4
	MOV	(PC)+,-(R4)
DLDA:	 .WORD	0
	MOV	-(R5),-(R4)
.IFF
	HANTORL	R3,RLMP
	MOV	(PC)+,R4
DLDA:	.WORD	0
	CALL	HTORL
	.WORD	RLDA
	HANTORL	-(R5),RLBA
.ENDC
	MOV	(PC)+,R0
DLCODE:	 .WORD	0
	BIS	(PC)+,R0
DLUNIT:	 .WORD	0
	.IF NE	MMG$T
$RLV1A:	BR	10$
	MOV	Q$PAR-Q$BUFF(R5),-(SP)
	ASR	(SP)
	ASR	(SP)
	ASR	(SP)
	ASR	(SP)
	MOV	(SP)+,RLBAE-RLBA(R4)
	MOV	Q$PAR-Q$BUFF(R5),-(SP)
	BIC	#<^C60>,(SP)
	BIS	(SP)+,R0
	BR	30$
10$:	BIT	#1700,Q$PAR-Q$BUFF(R5)
	BEQ	20$
	JMP	DLEROR
20$:	BIS	Q$PAR-Q$BUFF(R5),R0
30$:
	.ENDC
.IF	EQ	VENU$C
	MOV	R0,-(R4)
.IFF
	HANTORL	R0,RLCS
.ENDC
	RETURN
	.DSABL	LSB
	.SBTTL	DLINT - INTERRUPT ENTRY POINT
	.ENABL	LSB
	.DRAST	DL,5
.IF	NE	VENU$C
	BISB	#QBAIE,@#$QCSR0
	NOP
	NOP
	BICB	#QBAIE,@#$QCSR0
.ENDC
	.FORK	DLFBLK
	MOV	DLCSR,R4
	MOV	DLQPTR,R5
	TSTB	DLREV
	BNE	DLTRAK
.IF	EQ	VENU$C
	TST	@R4
.IFF
	HANFMRL	RLCS,R4
	TST	R4
.ENDC
	BMI	DLERRH
					.ASSUME	CSERR	EQ	100000
	MOV	DLWC,R3
	SUB	R3,Q$WCNT(R5)
	BNE	2$
	CMP	DLCODE,#FNWRITE!CSIE
	BNE	DLEXFR
.IF	EQ	VENU$C
	BIT	#1,RLDA(R4)
.IFF
	HANFMRL	RLDA,R4
	BIT	#1,R4
.ENDC
	BEQ	DLEXFR
	INC	Q$WCNT(R5)
	.ADDR	#DLFILL,-(SP)
	MOV	(SP)+,Q$BUFF(R5)
.IF	EQ	 VENU$C
	MOV	RLDA(R4),DLDA
.IFF
	HANFMRL	RLDA,DLDA
.ENDC
	.IF NE	MMG$T
	CLR	Q$PAR(R5)
	.ENDC
1$:	JMP	DLTRAK
2$:	ASL	R3
	ADD	R3,Q$BUFF(R5)
	.IF NE	MMG$T
	BCC	3$
	ADD	#CSBA16,Q$PAR(R5)
3$:
	.ENDC
	BIS	#77,DLDA
	INC	DLDA
	BEQ	DLEROR
	BPL	301$
	CMP	DLUSIZ,#DLSIZ2
	BNE	DLEROR
301$:	MOV	#DLWPT,DLWTRK
4$:	BR	1$
	.SBTTL	HANDLE THE ERRORS
DLERRH:
	.IF EQ	ERL$G
.IF EQ	VENU$C
	MOV	@R4,R3
.IFF
	HANFMRL	RLCS,R3
.ENDC
	.IFF
	MOV	R4,R1
	.ADDR	#DLRBLK,R2
	MOV	R2,R3
	MOV	(R1)+,(R3)+
	MOV	(R1)+,(R3)+
	MOV	(R1)+,(R3)+
	MOV	(R1)+,(R3)+
	CALL	DLGST
	MOV	R1,(R3)+
	COM	R1
	BIT	#STWL,R1
	BEQ	5$
	MOV	DLDA,(R3)+
$RLV1B:	BR	10$
	MOV	RLBAE(R4),(R3)+
10$:	MOV	DRETRY,R3
	SWAB	R3
	ADD	#DLREG,R3
$RLV1C:	BR	20$
	INC	R3
20$:	JSR	R4,FIXWC
	MOV	DLRTY,R4
	ADD	#DL$COD*400-1,R4
	CALL	@$ELPTR
	MOV	(SP)+,Q$WCNT(R5)
5$:	MOV	DLCSR,R4
	MOV	DLRBLK,R3
	.ENDC
	MOV	#-1,@DLCC
	CALL	DLRST
	TSTB	DLREV
	BEQ	6$
51$:	INCB	DLREV
	MOV	#177600!SKMARK,R1
	CALL	DLSEEK
	BMI	DLEROR
	MOV	DLUNIT,R0
	BIS	#CSIE!FNRDH,R0
.IF	EQ	VENU$C
	MOV	R0,@R4
.IFF
	HANTORL	R0,RLCS
.ENDC
	RETURN
6$:	ASRB	R3
	BCC	51$
					.ASSUME	CSDRDY	EQ	1
	ASL	R3
	ASL	R3
	BMI	DLEROR
					.ASSUME	CSNXM	EQ	020000
	BCC	7$
					.ASSUME	CSDE	EQ	040000
	CALL	DLGST
	BIT	#STWGE,R1
	BEQ	DLEROR
	BIT	#STWL,R1
	BNE	DLEROR
7$:	DEC	DLRTY
	BGT	4$
DLEROR:	MOV	DLCQE,R5
					.ASSUME Q$BLKN-2 EQ Q$CSW
	BIS	#HDERR$,@-(R5)
	BR	DLQCOM
	.DSABL	LSB
	.SBTTL	FINISH SUCCESSFUL OPERATION
	.ENABL	LSB
DLEXFR:	MOV	DLCQE,R5
	CMP	R5,DLQPTR
	BEQ	1$
	CMPB	Q$FUNC(R5),#FN$REP
	BEQ	1$
	TST	Q$WCNT(R5)
	BEQ	1$
	JMP	DLTRAN
1$:
	.IF NE	ERL$G
	JSR	R4,FIXWC
	TST	(SP)+
	TST	SCSFLG
	BNE	DLQCOM
	MOV	#DL$COD*400+377,R4
	CALL	@$ELPTR
	.ENDC
DLQCOM:	.DRFIN	DL
	.DSABL	LSB
	.SBTTL	DLXCT - FUNCTION EXECUTION ROUTINES
	.ENABL	LSB
DLSEEK:
.IF	EQ	VENU$C
	MOV	R1,RLDA(R4)
.IFF
	HANTORL	R1,RLDA
.ENDC
	MOV	#FNSEEK,R1
	BR	DLXCT
DLGST:
.IF	EQ	VENU$C
	MOV	#GSGS!GSMARK,RLDA(R4)
.IFF
	HANTORL	#GSGS!GSMARK,RLDA
.ENDC
	CALL	1$
	BPL	4$
.IF	EQ	VENU$C
	TST	RLBA(R4)
.IFF
	HANFMRL	RLBA,R4
	TST	R4
.ENDC
	BNE	4$
	CALL	DLRST
.IF	EQ	VENU$C
	MOV	#GSGS!GSMARK,RLDA(R4)
.IFF
	HANTORL	#GSGS!GSMARK,RLDA
.ENDC
	BR	1$
DLRST:
.IF	EQ	VENU$C
	MOV	#GSRST!GSGS!GSMARK,RLDA(R4)
.IFF
	HANTORL	#GSRST!GSGS!GSMARK,RLDA
.ENDC
1$:	MOV	#FNGSTS,R1
DLXCT:	BIS	DLUNIT,R1
.IF	EQ	VENU$C
	MOV	R1,@R4
2$:	TSTB	@R4
.IFF
	HANTORL	R1,RLCS
2$:	HANFMRL	RLCS,R4
	TSTB	R4
.ENDC
	BPL	2$
3$:
.IF	EQ	VENU$C
	MOV	RLMP(R4),R1
	MOV	@R4,R0
.IFF
	HANFMRL	RLMP,R1
	MOV	R1,(PC)+
STATMP:	.WORD	-1
	HANFMRL	RLCS,R0
	MOV	R0,(PC)+
STATCS:	.WORD	-1
.ENDC
4$:	RETURN
	.DSABL	LSB
.IF	NE	VENU$C
	.SBTTL	Macro routines to access q-bus adapter (IN_LINE)
HTORL:
	BICB	#QBAWRT!QBAREAD,@#$QCSR0
	BISB	#REQMASTER!QBAWRT!DMAENA,@#$QCSR0
	CALL	HGETQB
	MOV	R4,@#$QDAT0
	BR	HBCYCLE
HFMRL:
	BICB	#QBAWRT!QBAREAD,@#$QCSR0
	BISB	#REQMASTER!QBAREAD!DMAENA,@#$QCSR0
	CALL	HGETQB
HBCYCL:	MOV	(SP)+,R4
	MOV	(R4)+,@#$QADR0
HWAITF:	BITB	#MSTRPEND,@#$QCSR0
	BNE	HWAITF
	MOV	R4,-(SP)
	MOV	@#$QDAT0,R4
	BICB	#REQMASTER,@#$QCSR0
	RETURN
HGETQB:
	BITB	#MSTRPEND,@#$QCSR0
	BEQ	HGETQB
	RTS	PC
.ENDC
	.DSABL	LSB
	.SBTTL	DLSQUE - SETUP PSEUDO QUEUE ELEMENT
DLSQUE:
	.ADDR	#DLBWCT,R0
	MOV	R2,@R0
	MOV	R3,-(R0)
	MOV	Q$FUNC(R5),-(R0)
	MOV	R1,-(R0)
					.ASSUME Q$BLKN-2 EQ Q$CSW
	MOV	-(R5),-2(R0)
	MOV	R0,R5
	RETURN
	.IF NE	ERL$G
	.SBTTL	FIXWC - FIX WORD COUNT FOR LOGGER
FIXWC:	MOV	Q$WCNT(R5),@SP
	MOV	DLWC,Q$WCNT(R5)
	CMP	DLCODE,#FNWRITE!CSIE
	BNE	1$
	NEG	Q$WCNT(R5)
1$:	JMP	@R4
	.ENDC
	.SBTTL	DATA AREAS
	.WORD	-1
	.WORD	-1
	.BYTE	0
	.BYTE	-1
DLBADD:	.WORD	-1
DLBWCT:	.WORD	-1
	.IF NE	MMG$T
	.WORD	0
DLBPAR:	.WORD	-1
	.WORD	0,0
	.ENDC
DLFILL:	 .WORD	0
DLBBUF:
	.REPT	DL$UN
	.WORD	-1
	.WORD	-1
	.BLKB	DLTSIZ-2
	.ENDR
DLFBLK:	.WORD	0,0,0,0
	.IF NE	ERL$G
DLRBLK:	.BLKW	DLREG+1
	.ENDC
	.SBTTL	BOOTSTRAP DRIVER
	.DRBOT	DL,BOOT1,B.READ
	. = DLBOOT+40
BOOT1:	JMP	@#BOOT-DLBOOT
	.SBTTL	BOOTSTRAP READ ROUTINE
	.ENABL	LSB
	. = DLBOOT+210
B.READ:	CLR	R4
1$:	SUB	#DLBPT,R0
	BLO	2$
	ADD	#IOHS,R4
	BR	1$
2$:	ADD	#DLBPT,R0
	ASL	R0
	BIS	R4,R0
.IF	EQ	VENU$C
	MOV	BOTCSR,R5
	ADD	#RLDA,R5
	MOV	RLCS-RLDA(R5),B.DLCS
	BIC	#^C<CSDS01>,B.DLCS
.ENDC
	CALL	B.SEEK
	NEG	R1
.IF	EQ	VENU$C
	MOV	R2,RLBA-RLDA(R5)
.IFF
	MOVTORL	R2,RLBA
.ENDC
DLREAD:
.IF	EQ	VENU$C
	MOV	R1,RLMP-RLDA(R5)
	MOV	R0,@R5
.IFF
	MOVTORL	R1,RLMP
	MOVTORL	R0,RLDA
.ENDC
	JSR	R0,B.XCT
	 .WORD	FNREAD
	CLC
	BPL	5$
.IF	EQ	VENU$C
	MOV	@R5,R3
.IFF
	MOVFMRL	RLDA,R3
	MOV	R3,R4
.ENDC
	BIC	#^C<IOSA>,R3
	CMP	#DLBPT*2,R3
	BNE	BIOERR
.IF	EQ	VENU$C
	MOV	@R5,R3
.IFF
	MOV	R4,R3
.ENDC
	SUB	R0,R3
	SWAB	R3
	ASR	R3
	ADD	R3,R1
.IF	EQ	VENU$C
	MOV	@R5,R0
.IFF
	MOV	R4,R0
.ENDC
	ADD	#IOHS-<DLBPT*2>,R0
	MOV	#DLREAD-DLBOOT,-(SP)
	.BR	B.SEEK
B.SEEK:	JSR	R0,B.XCT
	 .WORD	FNRDH
.IF	EQ	VENU$C
	MOV	RLMP-RLDA(R5),R3
.IFF
	MOVFMRL	RLMP,R3
.ENDC
	BIC	#IOHS!IOSA,R3
	MOV	R0,R4
	BIC	#IOHS!IOSA,R4
	SUB	R4,R3
	BCC	3$
	NEG	R3
	BIS	#SKDIR,R3
3$:	BIT	#IOHS,R0
	BEQ	4$
	BIS	#SKHS,R3
4$:	INC	R3
.IF	EQ	VENU$C
	MOV	R3,@R5
.IFF
	MOVTORL	R3,RLDA
.ENDC
	JSR	R0,B.XCT
	 .WORD	FNSEEK
	BMI	BIOERR
.IF	EQ	VENU$C
	MOV	R0,@R5
.IFF
	MOVTORL	R0,RLDA
.ENDC
5$:	RETURN
B.XCT:	MOV	(R0)+,R3
.IF	EQ	VENU$C
	BIS	(PC)+,R3
B.DLCS:	 .WORD	0
	MOV	R3,RLCS-RLDA(R5)
6$:	BIT	#CSERR!CSCRDY,RLCS-RLDA(R5)
.IFF
	MOVTORL	R3,RLCS
6$:	MOVFMRL	RLCS
	BIT	#CSERR!CSCRDY,R5
.ENDC
	BEQ	6$
	RTS	R0
.IF	NE	VENU$C
	.SBTTL	Macro routines to access q-bus adapter (BOOT)
TORL:
	MOVB	#REQMASTER!QBAWRT!DMAENA,@#$QCSR0
	CALL	GETQB
	MOV	R5,@#$QDAT0
	BR	BCYCLE
FMRL:
	MOVB	#REQMASTER!QBAREAD!DMAENA,@#$QCSR0
	CALL	GETQB
BCYCLE:	MOV	(R4)+,@#$QADR0
WAITF:	BITB	#MSTRPEND,@#$QCSR0
	BNE	WAITF
	MOV	@#$QDAT0,R5
	BICB	#REQMASTER,@#$QCSR0
	RTS	R4
GETQB:
	BITB	#MSTRPEND,@#$QCSR0
	BEQ	GETQB
	RTS	PC
.ENDC
	.DSABL	LSB
	.SBTTL	BOOTSTRAP CONTINUED
.IF	NE	VENU$C
					.ASSUME .-DLBOOT-612 LE 0
	. = DLBOOT+612
.IFF
	. = DLBOOT+600
.ENDC
BOOT:	MOV	#10000,SP
.IF	EQ	VENU$C
	MOV	@(PC)+,-(SP)
BOTCSR:	 .WORD	DL$CSR
	BIC	#^C1400,@SP
	SWAB	@SP
.ENDC
	MOV	#2,R0
	MOV	#4*256.,R1
	MOV	#1000,R2
	CALL	B.READ
	MOV	#B.READ-DLBOOT,@#B$READ
	MOV	#B$DNAM,@#B$DEVN
.IF	EQ	VENU$C
	MOV	(SP)+,@#B$DEVU
.IFF
	CLR	@#B$DEVU
.ENDC
	JMP	@#B$BOOT
	.DREND	DL
	.END
                                                              