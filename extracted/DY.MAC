.MCALL	.MODULE
.MODULE	DY,VERSION=10,COMMENT=<RX02 Floppy Disk Handler>,AUDIT=YES

;                     	  COPYRIGHT (c) 1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
.SBTTL	CONDITIONAL ASSEMBLY SUMMARY
	.SBTTL	MACROS AND DEFINITIONS
	.ENABL	LC
	.MCALL	.DRDEF	.ADDR	.ASSUME	.BR
.DSTATUS=342
	SYSPTR	= 54
		PNPTR	= 404
	.MACRO	BNE.	LABEL,?ALT
	BEQ	ALT
	JMP	LABEL
ALT:
	.ENDM
.IIF NDF DYT$O, DYT$O = 0
.IIF NDF DY$DD, DY$DD = 0
.IIF NDF DY$CS2 DY$CS2	== 177150
.IIF NDF DY$VC2 DY$VC2	== 270
	.DRDEF	DY,6,FILST$!SPFUN$!VARSZ$,494.,177170,264
	.DRPTR
.IIF EQ DY$DD	.DREST	CLASS=DVC.DK,MOD=DVM.DX
.IIF NE DY$DD	.DREST	CLASS=DVC.DK
	.DRSPF	<373>
	.DRSPF	<375>
	.DRSPF	<376>
	.DRSPF	<377>
	CSGO	=      1
	CSUNIT	=     20
	CSDONE	=     40
	CSINT	=    100
	CSTR	=    200
	CSDN	=    400
	CSHEAD	=   1000
	CSRX02	=   4000
	CSINIT	=  40000
	CSERR	= 100000
	DNERR	= 20
	CSFBUF	= 0*2
	CSEBUF	= 1*2
	CSWRT	= 2*2
	CSRD	= 3*2
	CSRDST	= 5*2
	CSWRTD	= 6*2
	CSMAIN	= 7*2
.ASSUME	CSRD&2		NE 0
.ASSUME	CSWRT&2		EQ 0
.ASSUME	CSWRTD&2	EQ 0
	ESCRC	=      1
	ESPAR	=      2
	ESID	=      4
	ESSID1	=     10
	ESDNER	=     20
	ESDN	=     40
	ESDD	=    100
	ESDRY	=    200
	DDNBLK	= DYDSIZ*2
	DYNREG	= 3
	RETRY	= 8.
	SPFUNC	= 100000
	SIZ$FN	= 373
	WDD$FN	= 375
	WRT$FN	= 376
	RED$FN	= 377
	.SBTTL	INSTALLATION CHECKS
	.DRINS	DY
	NOP
	BIT	#CSRX02,@INSCSR
	BNE	O.GOOD
	BR	O.BAD
FINDRV:
	.ADDR	#DEVNAM,R0
	.ADDR	#DAREA+1,-(SP)
	EMT	.DSTATUS
	BCS	O.BAD
	MOV	DAREA+4,R1
	BEQ	O.BAD
	BR	O.GOOD
DAREA:	.BLKW	4
DEVNAM:	.RAD50	/DY /
BAREA:	.BYTE	17,10
	.BLKW
	.BLKW
	.WORD	256.
	.WORD	0
	.IIF GT,<.-356>	.ERROR
	.SBTTL	SET OPTIONS
	.DRSET	CSR,	160000,	O.CSR,	OCT
	.IF EQ DYT$O
	.DRSET	VECTOR,	500,	O.VEC,	OCT
	.IFF; EQ DYT$O
	.DRSET	VECTOR,	+1,	O.VEC,	OCT
	.DRSET	CSR2,	160000,	O.CSR2,	OCT
	.DRSET	VEC2,	+1+6,	O.VEC2,	OCT
	.ENDC
	.DRSET	RETRY	RETRY,	O.RTRY,	NUM
	.IF NE ERL$G
	.DRSET	SUCCES,	-1,	O.SUCC,	NO
	.ENDC
	.DRSET	WRITE,	1,	 O.WP,	NO
	BTCSR	= <DYEND-DYSTRT>+<BOTCSR-DYBOOT>+1000
O.CSR:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,INSCSR
	.ADDR	#BAREA+4,R1
	.ADDR	#1000,R2
	MOV	R2,(R1)
	MOV	#BTCSR/1000,-(R1)
	TST	-(R1)
	MOV	R0,R3
	MOV	R1,R0
	EMT	375
	BCS	O.BAD
	MOV	R3,<BTCSR&777>(R2)
	MOV	R1,R0
	INCB	1(R0)
	EMT	375
	BCS	O.SYWL
	MOV	R1,R0
	DECB	1(R0)
	MOV	#1,2(R0)
	EMT	375
	BCS	O.BAD
	.IF EQ DYT$O
	MOV	R3,DYCSA
	.IFF
	MOV	R3,DYCSR
	.ENDC
O.GOOD:	TST	(PC)+
O.BAD:	SEC
	RETURN
O.SYWL:
	ADD	#2,@SP
	BR	O.BAD
	.IF EQ DYT$O
O.VEC:	CMP	R0,R3
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	MOV	R0,DYSTRT
	BR	O.GOOD
	.IFF; EQ DYT$O
O.CSR2:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,DYCSR2
	BR	O.GOOD
O.VEC:
O.VEC2:	CMP	R0,#500
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	.ADDR	#DY$VTB-1,R3,ADD
	MOV	R0,@R3
	BR	O.GOOD
	.ENDC
O.RTRY:	CMP	R0,R3
	BHI	O.BAD
	MOV	R0,DRETRY
	BNE	O.GOOD
	BR	O.BAD
	.IF NE ERL$G
O.SUCC:	MOV	#0,R3
N.SUCC:
					.ASSUME O.SUCC+4 EQ N.SUCC
	MOV	R3,SCSFLG
	BR	O.GOOD
	.ENDC
O.WP:	NOP
	CLR	R3
N.WP:
					.ASSUME O.WP+4 EQ N.WP
	MOV	R3,O.WPF
	MOV	R1,R3
	CMP	R3,#DYT$O*2+1
	BHI	O.BAD
	.ADDR	#DYWPRO,R0
	ADD	R3,R0
	MOVB	(PC)+,(R0)
O.WPF:	.BLKW	1
	CALL	FINDRV
	BCS	O.GOOD
	CMP	@#SYSPTR,R1
	BHI	10$
	MOV	#100000,DYW1-DYLQE(R1)
10$:
	ADD	R3,R1
	MOVB	O.WPF,DYWPRO-DYLQE(R1)
	BR	O.GOOD
	.IIF GT,<.-1000> .ERROR
	.SBTTL	DRIVER REQUEST ENTRY POINT
	.ENABL	LSB
	.DRBEG	DY
	BR	DYENT
DYWPRO:
	.REPT	DYT$O+1
	.BYTE	0,0
	.ENDR
				.ASSUME	. LE DYSTRT+1000
	.IF NE ERL$G
SCSFLG:	.WORD	0
	.ENDC
				.ASSUME	. LE DYSTRT+1000
	.IF NE	DYT$O
	.DRVTB	DY,DY$VEC,DYINT
	.DRVTB	,DY$VC2,DYINT
				.ASSUME	. LE DYSTRT+1000
	.ENDC
DYENT:	MOV	(PC)+,(PC)+
DRETRY:	 .WORD	RETRY
				.ASSUME	. LE DYSTRT+1000
DYTRY:	 .WORD	0
	MOV	DYCQE,R5
	MOV	(R5)+,R3
	MOV	#CSGO!CSRD!CSINT,R4
	MOVB	(R5)+,R1
	MOVB	(R5)+,R0
	BIC	#^C<7>,R0
	MOV	R0,R2
	ASR	R0
	.IF EQ	DYT$O
	BNE	5$
	.ENDC
	BCC	1$
	BIS	#CSUNIT,R4
1$:
	.IF NE	DYT$O
	MOV	(PC)+,-(SP)
DYCSR = .
	 .WORD	DY$CSR
				.ASSUME	. LE DYSTRT+1000
	ASR	R0
	BNE	5$
	BCC	2$
	MOV	(PC)+,(SP)
DYCSR2 = .
	 .WORD	DY$CS2
				.ASSUME	. LE DYSTRT+1000
2$:	MOV	(SP)+,DYCSA
	.ENDC
	.IF EQ	DY$DD
	ASL	R2
	.ADDR	#SAVDEN,R2,ADD
	MOV	R2,(PC)+
DENPTR:	 .WORD	0
	BIS	@R2,R4
	.IFF
	BIS	#CSDN,R4
	CMPB	R1,#SIZ$FN
	BNE	3$
	 .IF EQ	MMG$T
	MOV	#DDNBLK,@(R5)+
	 .IFF
	MOV	#DDNBLK,-(SP)
	MOV	DYCQE,R4
	CALL	@$PTWRD
	 .ENDC
	JMP	DYDONE
	.ENDC
3$:
	.IF EQ	MMG$T
	MOV	(R5)+,R0
	.IFF
	CALL	@$MPPTR
	MOV	(SP)+,R0
	MOV	R4,(PC)+
35$:	 .BLKW
	MOV	(SP)+,R4
	BIT	#1700,R4
	BNE.	DYERR
	SWAB	R4
	BIS	35$,R4
	.ENDC
	MOV	@R5,WRDCNT
	BPL	4$
	ASL	(PC)+
DYW1:	.WORD	.-.
				.ASSUME . LE DYSTRT+1000
	BCS	33$
	CLR	-(SP)
	MOVB	Q.UNIT-Q.WCNT(R5),(SP)
	BIC	#<^C3>,(SP)
	.ADDR	#DYWPRO,(SP),ADD; TO UNIT OFFSET
	TSTB	@(SP)+
	BNE.	DYERR
33$:	ADD	#CSWRT-CSRD,R4
	NEG	WRDCNT
4$:	ASL	R1
	BEQ	6$
	MOV	R1,R5
	ADD	PC,R1
	ADD	CHGTBL-.(R1),R4
	.IF EQ	DY$DD
	SUB	#377*400!SIZ$FN*2,R5
	BEQ	7$
	.ENDC
	.IF EQ	MMG$T
	CLR	(R0)+
	.IFF
	MOV	R4,-(SP)
	MOV	DYCQE,R4
	CLR	-(SP)
	CALL	@$PTWRD
	TST	(R0)+
	MOV	(SP)+,R4
	.ENDC
	BR	7$
5$:	JMP	DYERR
6$:	ASL	R3
	TST	@R5
	BEQ	DYDONE
	.IF EQ	DY$DD
	TST	@R2
	BNE	7$
	ASL	R3
	.ENDC
7$:	MOV	R0,BUFRAD
	MOV	R3,DYLSN
	MOV	R4,(PC)+
DYFUN2:	 .WORD	0
	.IF EQ	DY$DD
	MOV	R5,(PC)+
SIZFLG:	 .WORD	0
	.ENDC
	MOV	#CSINT,R0
	CALL	INWAIT
	.BR	DYINIT
	.DSABL LSB
	.SBTTL	START TRANSFER OR RETRY
	.ENABL	LSB
DYINIT:
	.IF EQ	DY$DD
	TST	SIZFLG
	BNE	4$
	CALL	INWAIT
	BIT	#ESDRY,(R5)
	BEQ	DYERR
	MOV	#DYDSIZ,-(SP)
	BIT	#ESDN,@R5
	BEQ	3$
	ASL	@SP
3$:
	 .IF EQ	MMG$T
	MOV	(SP)+,@BUFRAD
	 .IFF
	MOV	DYCQE,R4
	CALL	@$PTWRD
	 .ENDC
	BR	DYDONE
	.ENDC
4$:
	.IF NE	MMG$T
	MOV	R0,DYFUN2
	.ENDC
	BIT	#1*2,R0
	BNE	5$
	CALL	DOSILO
5$:	CALL	DOXFER
	BIT	#1*2,R0
	BEQ	7$
	TST	R0
	BPL	6$
	BIT	#ESDD,@R5
	BEQ	6$
	.IF EQ	MMG$T
	MOV	BUFRAD,R2
	INC	-(R2)
	.IFF
	MOV	R4,R1
	MOV	DYCQE,R4
	MOV	#1,-(SP)
	SUB	#2,Q.BUFF-Q.BLKN(R4)
	CMP	Q.BUFF-Q.BLKN(R4),#20000
	BHIS	55$
	ADD	#20000,Q.BUFF-Q.BLKN(R4)
	SUB	#200,Q.PAR-Q.BLKN(R4)
55$:	CALL	@$PTWRD
	MOV	R1,R4
	.ENDC
6$:	CALL	DOSILO
7$:	TST	R0
	BMI	DYDONE
	MOV	R3,R2
	ASL	R2
	ADD	R2,(PC)+
BUFRAD:	 .WORD	0
	.IF NE	MMG$T
	BCC	8$
	ADD	#10000,R0
	.ENDC
8$:	INC	(PC)+
DYLSN:	 .WORD	0
	SUB	R3,(PC)+
WRDCNT:	 .WORD	0
	BHI	4$
	BIT	#1*2,R0
	BNE	DYDONE
	MOV	#1,WRDCNT
	.ADDR	#ZERO,R3
	MOV	R3,BUFRAD
	.IF NE	MMG$T
	BIC	#30000,R0
	.ENDC
	.IF EQ	DY$DD
	MOV	#3,R1
	BIT	#CSDN,R0
	BEQ	9$
	ASR	R1
9$:	BIT	R1,DYLSN
	.IFF
	BIT	#1,DYLSN
	.ENDC
	BNE	4$
	.SBTTL	DONE WITH I/O, FINISH UP AND EXIT
DYDONE:
	.IF NE	ERL$G
	TST	SCSFLG
	BNE	10$
	MOV	DYCQE,R5
	MOV	#DY$COD*400+377,R4
	CALL	@$ELPTR
	.ENDC
10$:	CLR	@DYCSA
11$:	.DRFIN	DY
DYABRT:	MOV	(PC)+,-(SP)
DYCSA:	 .WORD	DY$CSR
				.ASSUME	. LE DYSTRT+1000
	MOV	#CSINIT,@(SP)+
	CLR	DYFBLK+2
	BR	11$
DYERR:	MOV	DYCQE,R4
	BIS	#HDERR$,@-(R4)
	BR	10$
	.DSABL	LSB
	.SBTTL	INWAIT - START FUNCTION AND WAIT FOR INTERRUPT FROM FLOPPY
INWAIT:	MOV	(SP)+,INTRTN
	MOV	R0,@DYCSA
	RETURN
	.SBTTL	INTERRUPT ENTRY POINT
	.DRAST	DY,5,DYABRT
	.FORK	DYFBLK
	CALL	SETDY
	BMI	DYERR2
INTDSP:	JMP	@(PC)+
INTRTN:	 .WORD	0
	.SBTTL	ERROR HANDLING - CHANGE DENSITY, RETRY
DYERR2:
	.IF EQ	DY$DD
	BIT	#ESDNER,@R5
	BEQ	5$
	MOV	DENPTR,R2
	BIC	(R2)+,R0
	NEGB	-(R2)
	INCB	(R2)+
	BIS	-(R2),R0
	BMI	4$
	BCS	3$
	ASR	DYLSN
	BR	4$
3$:	ASL	DYLSN
4$:	MOV	R0,DYFUN2
	CMP	DYTRY,#RETRY
	BNE	5$
	CALL	SETDY
	BR	9$
	.ENDC
5$:
	.IF NE	ERL$G
	.ADDR	#DYRBUF,R3
	MOV	R3,R2
	MOV	@R4,(R3)+
	MOV	@R5,(R3)+
	MOV	#CSMAIN!CSGO,@R4
6$:	BIT	#CSTR,(R4)
	BEQ	6$
	MOV	R3,(R5)
61$:	BIT	#CSDONE,(R4)
	BEQ	61$
	MOV	DRETRY,R3
	SWAB	R3
	ADD	#DYNREG,R3
	MOV	DYCQE,R5
	MOV	DYTRY,R4
	ADD	#DY$COD*400-1,R4
	CALL	@$ELPTR
	MOV	DYCSA,R4
7$:
	.ENDC
	MOV	#CSINIT,@R4
	MOV	#CSINT,R0
	CALL	INWAIT
9$:	DEC	DYTRY
	BEQ	DYERR
	JMP	DYINIT
	.SBTTL	DOSILO - INITIATE A SILO FILL OR EMPTY COMMAND
DOSILO:	MOV	(SP)+,INTRTN
	MOV	WRDCNT,R2
	BIC	#6*2,R0
	BPL	1$
	MOV	R3,R2
1$:	MOV	R0,@R4
	CMP	R3,R2
	BLOS	2$
	MOV	R2,R3
	BEQ	INTDSP
2$:	MOV	BUFRAD,R2
	BR	DYDOFN
	.SBTTL	DOXFER - START A SECTOR READ OR WRITE
DOXFER:	MOV	(SP)+,INTRTN
	MOV	R0,@R4
	MOV	WRDCNT,R2
	MOV	DYLSN,R3
	TST	R0
	BMI	DYDOFN
	MOV	#8.,R2
2$:	CMP	#26.*200,R3
	BHI	3$
	ADD	#-26.*200,R3
3$:	ROL	R3
	DEC	R2
	BGT	2$
	MOVB	R3,R2
	CLRB	R3
	SWAB	R3
	CMP	#12.,R3
	ROL	R3
	ASL	R2
	ADD	R2,R3
	ADD	R2,R3
	ADD	R2,R3
	ASR	R2
	INC	R2
4$:	SUB	#26.,R3
	BGE	4$
	ADD	#27.,R3
	.BR	DYDOFN
	.SBTTL	DYDOFN - START A TRANSFER OR SILO OPERATION
DYDOFN:	BITB	#CSTR!CSDONE,@R4
	BEQ	DYDOFN
	BPL	DYERR2
	MOV	R3,@R5
1$:	BITB	#CSTR!CSDONE,@R4;TRANSFER OR DONE?
	BEQ	1$
	BPL	DYERR2
	MOV	R2,@R5
	RETURN
	.SBTTL	SETDY - SET UP REGISTERS
SETDY:	MOV	DYFUN2,R0
	MOV	#128.,R3
	.IF EQ	DY$DD
	TST	@DENPTR
	BNE	1$
	ASR	R3
1$:
	.ENDC
	MOV	DYCSA,R4
	MOV	R4,R5
	TST	(R5)+
	RETURN
	.SBTTL	TABLES, FORK BLOCK, END OF DRIVER
ZERO:	.WORD	0
	.IF EQ	DY$DD
	.WORD	CSRDST-CSRD+SPFUNC
	.WORD	0
	.ENDC
	.WORD	CSWRTD-CSRD+SPFUNC
	.WORD	CSWRT-CSRD+SPFUNC
	.WORD	CSRD-CSRD+SPFUNC
CHGTBL:
	.IF EQ	DY$DD
SAVDEN:	.WORD	CSDN,CSDN
	 .IF NE	DYT$O
	.WORD	CSDN,CSDN
	 .ENDC
	.ENDC
DYFBLK:	.WORD	0,0,0,0
	.IF NE	ERL$G
DYRBUF:	.BLKW	DYNREG
	.BLKW	4
	.ENDC
	.SBTTL	BOOTSTRAP READ ROUTINE
	.DRBOT	DY,BOOT1,READ1
	. = DYBOOT+40
BOOT1:	JMP	@#BOOT-DYBOOT
	.ENABL LSB
	. = DYBOOT+210
UNTRED:	 .WORD	CSGO+CSRD+CSDN
	 .WORD	CSGO+CSRD+CSDN+CSUNIT
READ1:	MOV	@#B$DEVU,R3
	BR	100$
READ:	MOV	BTUNIT,R3
100$:	ASL	R3
	MOV	UNTRED-DYBOOT(R3),REDCMD
1$:	ASL	R0
2$:	MOV	(PC)+,R5
BOTCSR:	 .WORD	DY$CSR
	MOV	(PC)+,(R5)+
REDCMD:	 .WORD	0
	MOV	R0,-(SP)
	MOV	R0,R3
	MOV	R0,R4
	CLR	R0
	BR	4$
3$:	SUB	#23.,R3
4$:	INC	R0
	SUB	#26.,R4
	BPL	3$
	CMP	#-14.,R4
	ROL	R3
5$:	SUB	#26.,R3
	BPL	5$
	ADD	#27.,R3
	MOV	BOTCSR,R4
	CALL	WAIT
	MOV	R3,@R5
	CALL	WAIT
	MOV	R0,@R5
6$:	BIT	#CSDONE,@R4
	BEQ	6$
	TST	@R4
	BMI	RTRY
	MOV	(PC)+,(R4)
EMTCMD:	 .WORD	CSEBUF+CSGO+CSDN;STORE EMTY BUFFER COMMAND HERE
	MOV	#64.,R3
	BIT	#CSDN,EMTCMD
	BEQ	7$
	ASL	R3
7$:	CMP	R1,R3
	BHIS	8$
	MOV	R1,R3
8$:	CALL	WAIT
	MOV	R3,@R5
	CALL	WAIT
	MOV	R2,@R5
9$:	BIT	#CSDONE,@R4
	BEQ	9$
	TST	@R4
	BMI	RTRY
	MOV	(SP)+,R0
	SUB	R3,R1
	BLE	10$
	ADD	R3,R2
	ADD	R3,R2
	INC	R0
	BR	2$
WAIT:	BITB	#CSTR!CSDONE,@R4;TRANSFER OR DONE?
	BMI	11$
	BEQ	WAIT
RTRY:	MOV	(SP)+,R0
	BITB	#DNERR,@R5
	BEQ	BIOERR
	BIC	#CSDN,REDCMD
	BIC	#CSDN,EMTCMD
	BR	1$
10$:	CLC
11$:	RETURN
	.DSABL	LSB
	. = DYBOOT+576
BOOT:	BIT	#CSDONE,@BOTCSR
	BEQ	BOOT
	MOV	#10000,SP
	MOV	R0,(PC)+
BTUNIT:	 .WORD	0
	MOV	#2,R0
	MOV	#<4*400>,R1
	MOV	#1000,R2
	CALL	READ
	MOV	#READ1-DYBOOT,@#B$READ
	MOV	#B$DNAM,@#B$DEVN
	MOV	BTUNIT,@#B$DEVU
	JMP	@#B$BOOT
	.DREND	DY
	.END
                                                                                                                                                                                                                           