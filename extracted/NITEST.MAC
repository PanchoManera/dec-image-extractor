.MCALL	.MODULE
.MODULE NITEST,VERSION=05,COMMENT=<Ethernet test program>

;                        COPYRIGHT (c) 1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
	.SBTTL	Abstract

;+
;
; NITEST
;	NITEST is a program which may be used to verify that communication
;	is possible between two stations on the Ethernet.
;	
;	When running, it responds to loopback datagrams (protocol 90-00)
;	sent to the station's physical address, broadcast address, or
;	the 'loopback assist' multicast address.
;
;	In addition, it may be used to send a loopback datagram to
;	another station and verify that it returns.
;
; Edit History:
;
; X01 (001) 13-Feb-85	Added HEX macro to make it easy to specify ethernet
;	MBG		addresses and protocol types.
;
; X01 (002) 04-Mar-85	Changes to buffer layout for transmit and receive
;	MBG		required changes here.
;
;-
	.SBTTL	Definitions

; RT-11 Macros we'll be using

	.MCALL	.QSET,	.GVAL,	.GTJB
	.MCALL	.FETCH,	.PRINT,	.LOOKU
	.MCALL	.SPFUN,	.GTLIN,	.MRKT
	.MCALL	.SPND,	.CMKT,	.RSUM
	.MCALL	.TTYOU,	.EXIT

; Define our own macro for HEX strings

	.MACRO	HEX	TEXT
	.TOGL. = 0
	.IRPC ..CHR.,<TEXT>
	 .IF DIF ..CHR.,-		
		.HXCT. = 0
		.FIND. = 0
	  .IRPC ..HEX.,<0123456789ABCDEF>
	   .IF IDN ..CHR.,..HEX.
		.FIND. = 200!.HXCT.
	   .ENDC ;IDN ..CHR.,..HEX.
		.HXCT. = .HXCT. + 1
	  .ENDR ;..HEX.
	  .IF EQ .FIND.
		.ERROR ;Invalid character ''..CHR.'' in hex string ''TEXT''
		.MEXIT
	  .ENDC ;EQ .FIND.
	  .IF EQ .TOGL.
		.FRST. = <.FIND.&17>*20
	  .IFF
		.BYTE	.FRST.!<.FIND.&17>
	  .ENDC ;EQ .TOGL.
		.TOGL. = <-.TOGL.> + 1
	 .IFF
	  .IF NE .TOGL.
		.BYTE	.FRST./20
		.TOGL. = 0
	  .ENDC ;NE .TOGL.
	 .ENDC ;DIF ..CHR.,-
	.ENDR ;.IRPC ..CHR.
	.IF NE .TOGL.
		.BYTE	.FRST./20
		.TOGL. = 0
	.ENDC ;NE .TOGL.
	.ENDM ;MACRO

; RMON Fixed offsets

	CONFG2	= 370			;Configuration word 2
		PRO$	= 020000 ;Running on PRO
		BUS$	= 000100 ;Qbus/Unibus

; Ethernet class handler functions

	SP.POR	= 200			;Allocate/Deallocate unit
	SP.PT	= 202			;Enable/Disable protocol type
	SP.MA	= 203			;Enable/Disable multicast address
	SP.XMT	= 204			;Transmit ethernet frame
	SP.RCV	= 205			;Read ethernet frame
	.SBTTL	NITEST

	.PSECT	.CODE.

	.ENABL	LSB

NITEST:	.QSET	#QELEM,#4.		;We'll need extra queue elements
	.GVAL	#AREA,#CONFG2		;Get contents of config word 2
	MOV	#<^RNC >,DBLK		;Assume PRO
	BIT	#PRO$,R0		;Correct assumption?
	BNE	10$			;Yep...
	MOV	#<^RNQ >,DBLK		;No, so assume Qbus
	BIT	#BUS$,R0		;Correct assumption?
	BNE	10$			;Yep...
	MOV	#<^RNU >,DBLK		;Nope, must be unibus after all
10$:	.GTJB	#AREA,#JOBDAT		;Get info on this job
	MOV	JOBNUM,R0		;R0 = Job number (*2)
	ASR	R0			;Convert to job number 0-7
	ADD	#36,R0			;Make it final RAD50 digit
	ADD	R0,DBLK			;And add it to the device name
	.FETCH	#FREE,#DBLK		;Fetch the handler we need
	BCC	20$
	MOV	#M.IVD,R0		;R0 -> 'Invalid device'
FATAL:	.PRINT				;Print the error message
	.EXIT				;And go away

20$:	.LOOKU	#AREA,#0,#DBLK		;Open a channel to the ethernet
	BCC	21$
	MOV	#M.LERR,R0		;R0 -> 'Lookup error'
	BR	FATAL

21$:	.SPFUN	#AREA,#0,#SP.POR,#ALBUFF,#0,#1 ;Allocate the unit for our use
	BCC	22$
	MOV	#M.UAER,R0		;R0 -> 'Unit allocation error'
	BR	FATAL

22$:	MOV	ALBUFF+2,XADDR		;Save the station's address
	MOV	ALBUFF+4,XADDR+2
	MOV	ALBUFF+6,XADDR+4
	.SPFUN	#AREA,#0,#SP.PT,#PTBUFF,#0,#1 ;Enable loopback protocol
	BCC	23$
	MOV	#M.EPER,R0		;R0 -> 'Protocol enable error'
	BR	FATAL

23$:	.SPFUN	#AREA,#0,#SP.MA,#MABUFF,#0,#1 ;Loopback assist multicast
	BCC	24$
	MOV	#M.EMER,R0		;R0 -> 'Multicast enable error'
	BR	FATAL

24$:	.PRINT	#M.STAT			;Announce station's address
	MOV	#ALBUFF+2,R1
	CALL	EAOUT
	.PRINT	#M.CRLF
30$:	CALL	XMTCMP			;Prime the loopback assist pump
	.PRINT	#M.LOOP			;Announce loopback is enabled
	.PRINT	#M.CRLF

	.DSABL	LSB
	.SBTTL	LOOPFW	- Initiates a loopback datagram

	.ENABL	LSB

LOOPFW:	.GTLIN	#CMDBUF,#M.PROM		;Prompt for the test station
10$:	CLR	RECVFG			;Reset the receive flag
	.MRKT	#TAREA,#TIMBLK,#TIMCMP,#1 ;Start a timer
	BCC	15$
	MOV	#M.QELM,R0		;R0 -> 'No queue element'
	JMP	FATAL

15$:	.SPFUN	#XAREA,#0,#SP.XMT,#XBUFF,#759.,#0,#1 ;Transmit the datagram
					; (Can't use 'wait' mode because
					;  of outstanding calls using
					;  completion mode)
	.SPND				;Suspend until the packet returns
					; or we timeout waiting for it
	TST	(PC)+			;Did we get a response?
RECVFG:	 .WORD	0			; : Receive flag
	BNE	30$			;Yes...
	.PRINT	#M.NORE			;Nope, 'No response'
	.PRINT	#M.CRLF
	BR	LOOPFW

30$:	.PRINT	#M.RECV			;'Response received from'
	MOV	#RBUFF+EF.SRC,R1	;R1 -> Datagram source field
	CALL	EAOUT			;Print the station address
	MOV	#XDATA,R0		;R0 -> Data transmitted
	MOV	#RBUFF+<XDATA-XBUFF>,R1	;R1 -> Data received
	MOV	#DATASZ,R2		;R2 = Count of data words
40$:	CMP	(R0)+,(R1)+		;Is the received data correct?
	BNE	50$			;Nope...
	DEC	R2			;Yes, more to check?
	BGT	40$			;Yep...
	.PRINT	#M.OK			;'data correct'
45$:	.PRINT	#M.CRLF
	.SPND				;Wait for timer to expire
	CALL	XMTCMP			;Reprime the loopback assist pump
	BR	LOOPFW

50$:	.PRINT	#M.NOK			;'data corrupt'
	BR	45$

	.DSABL	LSB
	.SBTTL	Completion routines

;+
;
; RCVCMP
;	Entered on completion of posted read due to reception of
;	a packet destined for this physical station, the loopback
;	assist multicast address, or the broadcast address with
;	a protocol type of 90-00.
;
;	The received packet is processed, and if it is to be
;	forwarded, a transmit is posted with completion at XMTCMP.
;	If the datagram indicates that it has arrived at its
;	destination, a flag is set to indicate a received packet and
;	the mainline code is resumed so that the data may be verified.
;
; XMTCMP
;	Entered on the following:
;
;	1) From top level code.  Used to prime the loopback
;	   assist receive pump (completion driven).
;	2) Completion of the write posted in RCVCMP to forward
;	   a loopback packet.
;	3) From RCVCMP when a packet is not to be forwarded
;	   because it has reached its destination or is to
;	   be forwarded to a multicast address (a no-no).
;
;	Posts another read with completion at RCVCMP.
;
; TIMCMP
;	Entered when timer expires, indicating no response from
;	remote station.
;	
;-

	.ENABL	LSB

RCVCMP:	MOV	#RBUFF+EF.SKP,R0	;R0 -> Skip count field
	MOV	(R0),-(SP)		;Get the skip count
	ADD	#8.,(R0)+		;Update field
	ADD	(SP)+,R0		;Point to encapsulated data
	BIT	#1,R0			;Skip count getting us to odd address?
	BNE	XMTCMP			;Yes, drop the packet...
	CMP	(R0),#1			;Reply packet?
	BNE	10$			;Nope...
	MOV	SP,RECVFG		;Yes, set the receive flag
TIMCMP:	.RSUM				;Resume the mainline
	RETURN

10$:	CMP	(R0)+,#2		;Forward packet?
	BNE	XMTCMP			;Nope, ignore it
	BIT	#1,(R0)			;Is destination a multicast address?
	BNE	XMTCMP			;Yes, then ignore it
	MOV	#RBUFF+EF.DST,R1	;R1 -> Destination field
	MOV	(R0)+,(R1)+		;Set next destination
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+
	CLR	(R1)+			;Force the station's physical address
	CLR	(R1)+			; to be used
	CLR	(R1)+
	MOV	RBUFF+2,R1		;Get actual frame size
	INC	R1			;Bump size in case of odd-sized frame
	ASR	R1			;Convert byte to word count
	.SPFUN	#RAREA,#0,#SP.XMT,#RBUFF,R1,#0,#XMTCMP ;Pass the packet
	RETURN

XMTCMP:	.SPFUN	#RAREA,#0,#SP.RCV,#RBUFF,#759.,#0,#RCVCMP ;Post a read
	RETURN

	.DSABL	LSB
	.SBTTL	HEX OUTPUT ROUTINES

	.ENABL	LSB

TYPOUT:	MOV	#2,R2			;Protocol is two octets
	BR	10$

EAOUT:	MOV	#6,R2			;Addresses are six octets
	BR	10$

5$:	.TTYOU	#'-			;Delimiter
10$:	MOVB	(R1)+,-(SP)		;Save a byte of the address
	MOVB	(SP),R0			;Get the byte
	ASR	R0			;Shift high nybble to where we want it
	ASR	R0
	ASR	R0
	ASR	R0
	BIC	#^C<17>,R0		;Isolate it
	.TTYOU	HEX(R0)			;Print the hex character
	MOVB	(SP)+,R0		;Get the address byte again
	BIC	#^C<17>,R0		;Isolate the low nybble
	.TTYOU	HEX(R0)			;Print the hex character
	DEC	R2			;More to do?
	BGT	5$			;Yep...
	RETURN

	.DSABL	LSB
	.SBTTL	Messages

	.PSECT	.TEXT.

	.NLIST	BEX

M.PROM:	.ASCII	/Type <RETURN> to test: /<200>
M.IVD:	.ASCIZ	/?NITEST-U-Invalid device/
M.LERR:	.ASCIZ	/?NITEST-U-Lookup error/
M.UAER:	.ASCIZ	/?NITEST-U-Unit allocation error/
M.EPER:	.ASCIZ	/?NITEST-U-Enable protocol error/
M.EMER:	.ASCIZ	/?NITEST-U-Enable multicast address error/
M.QELM:	.ASCIZ	/?NITEST-U-No queue element/
M.NORE:	.ASCIZ	/?NITEST-W-No response/
M.RECV:	.ASCII	/?NITEST-I-Response received from /<200>
M.OK:	.ASCIZ	/, data correct/
M.NOK:	.ASCIZ	/, data corrupt/

M.STAT:	.ASCII	/Station address = /<200>
M.LOOP:	.ASCII	/Loopback assist is enabled/
M.CRLF:	.BYTE	0

HEX:	.ASCII	/0123456789ABCDEF/
	.EVEN

	.LIST	BEX
	.SBTTL	Impure data area

	.PSECT	.DATA.

AREA:	.BLKW	10.			;General purpose EMT area
RAREA:	.BLKW	6.			;EMT area for receive .SPFUN
XAREA:	.BLKW	6.			;EMT area for transmit .SPFUN
TAREA:	.BLKW	4			;EMT area for timer

CMDBUF:	.BLKB	82.			;Response buffer

QELEM:	.BLKW	4*10.			;Extra queue elements

TIMBLK:	.WORD	0,2*60.			;Timer block

JOBDAT:					;Job data area
JOBNUM:	.BLKW	12.

DBLK:	.WORD	0,0,0,0			;Device block

ALBUFF:	.BLKW	4			;Unit allocation buffer

MABUFF:	.BLKW				;Enable multicast address buffer
	HEX	<CF-00-00-00-00-00>	;Loopback assist multicast address

PTBUFF:	.BLKW				;Enable protocol type buffer
	HEX	<90-00>			;Protocol type = Loopback

RBUFF:	.BLKW	759.			;Receive buffer

	EF.DST	= 4
	EF.SRC	= EF.DST+6
	EF.PT	= EF.SRC+6
	EF.SKP	= EF.PT+2

XBUFF:	.BLKW				;Status word
	.BLKW				;reserved
	HEX	<CF-00-00-00-00-00>	;Destination = loopback assist
					; (Change this if you wish to send
					;  to a specific station)
	.WORD	0,0,0			;Source = station physical address
	HEX	<90-00>			;Protocol type = Loopback

	.WORD	0			;Skip count

	.WORD	2			;Forward
XADDR:	.WORD	0,0,0			;Ultimate destination

	.WORD	1			;Reply
	.WORD	1			;Receipt number
XDATA:	.ASCIZ	/Loopback datagram data area/
	.EVEN

	DATASZ	= <.-XDATA>/2

	.BLKW	759.-<<.-XBUFF>/2>

FREE == .

	.END	NITEST
                                                                                                                                                                                                                                                                                                                                                                                                        