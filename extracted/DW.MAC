.MCALL	.MODULE
.MODULE	DW,VERSION=27,COMMENT=<RD50C Mini-winchester disk for PC>,AUDIT=YES

;                 COPYRIGHT (c) 1984,1985,1986 BY
;          DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;		       ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
	.SBTTL	Conditional assembly summary
.REM	%
		The DW handler is formally designated the
		  Martin B. Gentry Commemorative Handler
		 in recognition of their mutual reduction
			of excessive avoirdupois.
	%
	.PSECT	DWDVR
	.PSECT	SETOVR
	.PSECT	DWBOOT
.SBTTL	DESCRIPTION
.ENABL	LC
	.SBTTL	USAGE
	.SBTTL	MACRO DEFINITIONS
.MACRO	MAXVAL BITS, VAL
VAL	= 1
.REPT	BITS
VAL	= VAL * 2
.ENDR
.ENDM
.MACRO	BITMSK ARG, CMASK, BITS
.IIF EQ ARG,	.ERROR
N	= ARG
MASK	= 1
BITS	= 0
FLAG	= 0
.REPT	16
 .IF EQ FLAG
MASK	= MASK * 2
BITS	= BITS + 1
N	= N / 2
  .IF	EQ N
FLAG	= 1
  .ENDC
 .ENDC
.ENDR
CMASK	= ^C<MASK - 1>
.ENDM
.MACRO	$TYPE$	CODE,HEADS,TOTCYL,RSIZE,USIZE,HASIZ,LASIZ,USIZ,?L1
L1:
	.WORD	CODE
	.WORD	HEADS
	.WORD	TOTCYL
	.WORD	LASIZ
	.WORD	USIZ
TSIZE=.-L1
.ENDM
	.SBTTL	PRIMARY DECLARATIONS
PC$CSR	=: 174000
PC$VEC	=: 300
PC$IC1	=: 173206
PC$IC2	=: 173212
MMUSR0	=: 177572
MMUSR3	=: 172516
.IRPC	X <01234567>
KISAR'X	=: 172340+<2*X>
KISDR'X	=: 172300+<2*X>
.ENDR
  AP$ACF=: 077406
PROCFG	=: 37776
  CTI	=: -10.
  SLOT0	=: -14.
PC$PRI	=: 4
DW$ID	=: 401
DW$SEC	=: 16.
SECIDMX	=: 5
SRFIDMX	=: 3
CYLIDMX	=: 10.
MAXVAL	SECIDMX, MAXSEC
MAXVAL	SRFIDMX, MAXSRF
MAXVAL	CYLIDMX, MAXCYL
.IIF GT <DW$SEC - MAXSEC> .ERROR
	.SBTTL	BLOCK LAYOUT ON THE RD50C DISK
	.SBTTL	PREAMBLE SECTION
	.MCALL	.DRDEF, .ASSUME, .ADDR	.BR	.CKXX
	.CKXX	<R0,R1,R2,R3,R4,R5>
	.DRDEF	DW,53,FILST$!SPFUN$!VARSZ$,0,0,0
	.DRPTR	FETCH=FETCH,LOAD=FETCH
	.DREST	CLASS=DVC.DK
	.DRSPF	<373>
	.DRSPF	<376>
	.DRSPF	<377>
.SBTTL	CONSTANT DEFINITIONS
SYSPTR	=: 54
		P1EXT	=: 432
		GETVEC	=: 436
			$GTVEC=:0
			$GTCSR=:2
			$GTSLT=:4
		DWTYPE	=: 440
			TYP50	=:	1.
			TYP51	=:	2.
			TYP31	=:	3.
			TYP52C	=:	4.
			TYP52Q	=:	5.
			TYP52A	=:	6.
			TYP53	=:	7.
DPT.BT	=:	12
ICOPND	=: PC$IC1
ICDRQ	=: PC$IC2
DWID	=: 0
DWERR	=: 4
DWPRE	=: 4
DWREV	=: 6
DWSEC	=: 6
DWBUF	=: 10
DWCYL	=: 12
DWHEAD	=: 14
DWST2	=: 16
DWCMD	=: 16
DWSTAT	=: 20
DWINIT	=: 20
.IF NE	ERL$G
ERLRGS	=: 6
.ENDC
EDWM	=: 0400
ERTR0	=: 01000
ERABO	=: 02000
ERIDNF	=: 10000
ERICRC	=: 20000
EDWCRC	=: 40000
BITMSK	DW$SEC-1,SECMSK,SECBIT
BITMSK	MAXSEC-1,MXSECM,MXSECB
.IIF NE <SECIDMX-MXSECB>	.ERROR
BITMSK	MAXSRF-1,MXSRFM,MXSRFB
.IIF NE <SRFIDMX-MXSRFB>	.ERROR
BITMSK	MAXCYL-1,MXCYLM,MXCYLB
.IIF NE <CYLIDMX-MXCYLB>	.ERROR
S2ERR	=: 400
S2DRQ	=: 4000
S2SEK	=: 10000
S2WRF	=: 20000
S2DWY	=: 40000
CMREST	=: 20
CMREAD	=: 40
CMWRIT	=: 60
CMFORM	=: 120
STOPND	=: 1
STDRQ	=: 200
STDCAP	=: 400
STBUSY	=: 100000
STINIT	=: 10
RETRYS	=: 8.
WREQ	=: 100000
AREQ	=:    200
RREQ	=:      1
RDAWRT	=:      1
.SBTTL	INSTALLATION VERIFICATION ROUTINE
	.DRINS	-DW
	.ENABL	LSB
	BR	10$
	MOV	#DW$ID,-(SP)
	CALL	@R3
	BR	20$
10$:	NOP
	MOV	#DW$ID,-(SP)
	MOV	@#SYSPTR,R0
	CALL	@GETVEC(R0)
20$:
	MOV	(SP)+,R1
	MOV	INSCSR,R0
	BNE	30$
	BCS	50$
	BR	40$
30$:
	TST	@R0
	NOP
	BCS	50$
	CMP	@R0,#DW$ID
	BNE	50$
40$:
I.GOOD:	TST	(PC)+
I.BAD:
50$:	SEC
	RETURN
	.ENABLE	LSB
FINDRV:
	.ADDR	#DEVNAM,R0
	.ADDR	#DAREA,-(SP)
	EMT	342
	BCS	I.BAD
	MOV	DAREA+4,R1
	BEQ	I.BAD
	BR	I.GOOD
DAREA:	.BLKW	4
DEVNAM:	.RAD50	/DW /
I.SLOT:
	CMPB	(R3)+,(R3)+
	BIC	R3,CLRIRR
	BIC	R3,CLRIMR
	BIC	R3,SETIMR
	BIS	R1,CLRIRR
	BIS	R1,CLRIMR
	BIS	R1,SETIMR
	CLRB	DWTYPE(R2)
	RETURN
.ASSUME	. LE 400,MESSAGE=<;Install area overflow>
	.DSABL	LSB
.SBTTL	HANDLER SET OPTIONS
	.DRSET	RETRY,	RETRY,	O.RTRY,	NUM
	.IF NE ERL$G
	.DRSET	SUCCES,	-1,	O.SUCC,	NO
	.ENDC
	.DRSET	WRITE,1,O.WP,NO
	.DRSET	WCHECK,1,SETW,NO
	.DRSET	SLOT,5,SETSLT,NUM
.SBTTL	HANDLER MODIFICATION ROUTINES
O.RTRY:	CMP	R0,R3
	BHI	O.BAD
	MOV	R0,DRETRY
	BNE	O.GOOD
	BR	O.BAD
	.IF NE ERL$G
O.SUCC:	MOV	#0,R3
N.SUCC:	MOV	R3,SCSFLG
					.ASSUME O.SUCC+4 EQ N.SUCC
	BR	O.GOOD
	.ENDC
	.ENABLE	LSB
O.WP:	NOP
	TST	(PC)+
	SEC
	ROL	(PC)+
O.WPF:	 .WORD	0
	BIC	#<^C1>,O.WPF
	MOVB	R1,R0
	BNE	O.BAD
	MOV	R0,-(SP)
	.ADDR	#DWWPRO,R0,ADD
	MOVB	O.WPF,@R0
	CALL	FINDRV
	MOV	(SP)+,R0
	BCS	O.GOOD
	CMP	@#SYSPTR,R1
	BHI	10$
	MOV	#100000,DWW1-DWLQE(R1)
10$:
	ADD	#DWWPRO-DWLQE,R1
	ADD	R0,R1
	MOVB	O.WPF,@R1
O.GOOD:	TST	(PC)+
O.BAD:	SEC
	RETURN
	.DSABLE	LSB
	.ENABLE	LSB
SETW:	BR	10$
 .	= SETW+4
	CLR	DWWCHK
	BR	20$
10$:	MOV	#-1,DWWCHK
20$:	CLC
	RETURN
	.DSABLE	LSB
	.ENABLE	LSB
SETSLT:
	MOV	@#SYSPTR,R2
	INC	R2
	CMP	R0,R3
	BGT	O.BAD
	CMP	R0,#-1
	BEQ	10$
	TST	R0
	BMI	O.BAD
	MOV	R0,R1
	ASH	#7,R0
	ADD	#PC$CSR,R0
	BR	20$
10$:
	CLR	R0
	DEC	R2
20$:
	MOV	R0,DWCSR
	MOV	R0,INSCSR
	BEQ	30$
	MOV	#<XW$VTB-<DWSTRT>>/2.-1+^o100000,DWSTRT
	MOV	R1,R0
	ASH	#3,R0
	ADD	#PC$VEC,R0
	MOV	R0,XW$VTB+0
	CMP	(R0)+,(R0)+
	MOV	R0,XW$VTB+6
	BR	40$
30$:
	MOV	#<DW$VTB-<DWSTRT>>/2.-1+^o100000,DWSTRT
	CLR	R1
40$:
	JMP	I.SLOT
	.DSABLE	LSB
.ASSUME	. LE 1000,MESSAGE=<;Set area overflow>
.SBTTL	HEADER SECTION
	.DRBEG	DW
DWBASE=:DWSTRT+6
	BR	DWENT
DWWPRO: .WORD	0
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
	.IF NE ERL$G
SCSFLG:	.WORD	0
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
	.ENDC
DWWCHK:	.WORD	0
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
DWFBLK:	.WORD	0,0,0,0
DRETRY:	.WORD	RETRYS
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
RETRY:	.WORD	0
INREST:	.WORD	0
FNFLAG:	.WORD	0
WRFLAG:	.WORD	0
WCNT:	.WORD	0
CRNTCYL:.WORD	0
CRNTHD:	.WORD	0
CRNTSEC:.WORD	0
RDTYP:
$TYPE$	0 0  177777	177777	177777	177777  177777	177777
DW$TYP	=:	RDTYP+0
DW$SRF	=:	RDTYP+2
DW$CYL	=:	RDTYP+4
DWASIZ	=:	RDTYP+6
DWUSIZ	=:	RDTYP+8.
.IF EQ	MMG$T
BUFF:	.WORD	0
.ENDC
.IF NE	ERL$G
ERLIST:	.BLKW	ERLRGS
.ENDC
.SBTTL	VECTOR TABLE
DW$VEC	=:	PC$VEC
	.DRVTB	XW,300,DWINT
	.DRVTB	  ,304,DWINT
	.DRVTB	DW,0,DWINT,SLOTID=DW$ID
	.DRVTB	,4,DWINT
.SBTTL	I/O INITIATION SECTION
	.ENABL	LSB
DWENT:
	MOV	#.-.,R4
DWCSR	=:.-2
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
							CK.R4=DWID
							CK.R4 DWID
	TST	DWSTAT(R4)
	.ASSUME <STBUSY> EQ 100000
	BMI	JMPFD1
	MOV	#.-.,R0
DRETR1	=:.-2
							CK.R0=DRETRY
							CK.R0 DRETRY,+2
							CK.R0 RETRY,+2
	MOV	(R0)+,(R0)+
							CK.R0 INREST,+2
	CLR	(R0)+
							CK.R0 FNFLAG,+2
	CLR	(R0)+
							CK.R0 WRFLAG,+2
	CLR	(R0)+
	MOV	DWCQE,R5
							CK.R5=Q$BLKN
							CK.R5 Q$BLKN
	MOV	@R5,R3
							CK.R5 Q$BLKN
	MOVB	Q$UNIT(R5),R0
	BIC	#^C<7>,R0
	BNE	JMPFU1
XRETRY:
							CK.R5 Q$BLKN
	MOVB	Q$FUNC(R5),R0
	ADD	#FNEG,R0
	CMP	R0,#FNUM
	BLO	DISPAT
JMPFU1:	JMP	DWFUE
JMPFD1:	JMP	DWFDE
	.DSABL	LSB
.SBTTL	COMMAND DISPATCH
DISPAT:	ASL	R0
	ADD	#.-.,R0
FNTBL1	=:.-2
	ADD	@R0,PC
JMPREF:
FNTBL:
	.WORD	<DSIZ - JMPREF>
	.WORD	<DWFUE- JMPREF>
	.WORD	<DWFUE- JMPREF>
	.WORD	<ABSW - JMPREF>
	.WORD	<ABSR - JMPREF>
FTBZER:	.WORD	<RW - JMPREF>
FTBEND:
FNEG	=: <FTBZER - FNTBL>/2
FNUM	=: <FTBEND - FNTBL>/2
				.Assume FNEG+1 EQ FNUM
.SBTTL	HANDLER FUNCTIONS SECTION
.SBTTL	ABSRW - Read/write absolute sector
ABSW:
							CK.R5 Q$BLKN
	NEG	Q$WCNT(R5)
ABSR:
	BIS	#AREQ,FNFLAG
	.BR	RW
.SBTTL	- READ(X)/WRIT(X) FUNCTION
	.ENABLE	LSB
RW:
							CK.R5 Q$BLKN
	BIT	#1,Q$BUFF(R5)
	BNE	JMPFU1
							CK.R5 Q$BLKN
	TST	Q$WCNT(R5)
	BMI	10$
	BNE	25$
	BR	INTRQS
10$:
							CK.R4 DWID
	BIT	#S2WRF,DWST2(R4);Has a write fault occured?
	BNE	JMPFD1
	ASL	(PC)+
DWW1:	.WORD	.-.
				.ASSUME . LE DWSTRT+1000
	BCS	20$
	TST	DWWPRO
	BNE	JMPFU1
20$:	MOV	#S2WRF,WRFLAG
	BIS	#WREQ,FNFLAG
							CK.R5 Q$BLKN
	NEG	Q$WCNT(R5)
	BR	RWNEXT
25$:
	BIS	#RREQ,FNFLAG
	.BR	RWNEXT
RWNEXT:
	INC	R3
	TSTB	FNFLAG
	BPL	30$
				.Assume AREQ EQ 200
	CMP	R3,DWASIZ
	BHIS	JMPFU1
	BR	40$
30$:	CMP	R3,DWUSIZ
	BHI	JMPFU1
40$:	MOV	R3,R1
	BIC	#SECMSK,R1
	ASH	#-SECBIT,R3
				.Assume SECBIT EQ 4
	BIC	#170000,R3
	CLR	R2
	DIV	DW$SRF,R2
	CMP	R2,DW$CYL
	BHIS	JMPFU1
	MOV	#.-.,R0
CRNT1	=:.-2
							CK.R0=CRNTCYL
							CK.R0 CRNTCYL,+2
	MOV	R2,(R0)+
							CK.R0 CRNTHD,+2
	MOV	R3,(R0)+
							CK.R0 CRNTSEC,+2
	MOV	R1,(R0)+
	.BR	RWRTRY
RWRTRY:
	CALL	DSKADR
	TST	FNFLAG
				.Assume WREQ EQ 100000
	BMI	50$
DOREAD:
	MOV	#110,@#ICDRQ
CLRIRR	=:.-4
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
							CK.R4 DWID
	MOV	#CMREAD,DWCMD(R4)
	MOV	#050,@#ICDRQ
CLRIMR	=:.-4
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
	RETURN
50$:
	BIC	#RDAWRT,FNFLAG
	MOV	CLRIRR,@#ICOPND
							CK.R4 DWID
	MOV	#CMWRIT,DWCMD(R4)
	JSR	R0,MTFILL
	  MOV	(R2)+,@R4
	  CLR	@R4
	CALLR	CLRPND
	.DSABL	LSB
.SBTTL	DSIZ - Get disk size
	.ENABLE	LSB
DSIZ:
.IF EQ MMG$T
								CK.R5 Q$BLKN
	MOV	DWUSIZ,@Q$BUFF(R5)
.IFF
	MOV	DWUSIZ,-(SP)
								CK.R5 Q$BLKN
								CK.R4=CK.R5
	MOV	R5,R4
	CALL	@$PTWRD
.ENDC
	.BR	INTRQS
	.DSABL	LSB
.SBTTL	INTERRUPT SERVICE SECTION
	.ENABLE	LSB
INTRQS:	JMP	DWRQS
	.DRAST	DW,PC$PRI
	MOV	#070,@#ICOPND
SETIMR	=:.-4
		.Assume . LE DWSTRT+1000,MESSAGE=<;SET object not in block 1>
	MOV	SETIMR,@#ICDRQ
	.FORK	DWFBLK
	MOV	DWCQE,R5
								CK.R5=Q$BLKN
	MOV	DWCSR,R4
								CK.R4=DWID
								CK.R4 DWID
	TST	DWSTAT(R4)
	BMI	DWFD1
								CK.R4 DWID
	BIT	WRFLAG,DWST2(R4)
	BNE	DWFD1
								CK.R4 DWID
	BIT	#S2ERR,DWST2(R4);Error status?
	BNE	70$
	TST	INREST
	BNE	90$
.IF NE	ERL$G
	TST	SCSFLG
	BNE	10$
	MOV	R5,-(SP)
								S.TOP=CK.R5
	MOV	R4,-(SP)
								S.TOP2=CK.R4
	MOV	#<<DW$COD*400>!377>,R4
	CALL	@$ELPTR
	MOV	(SP)+,R4
								CK.R4=S.TOP2
	MOV	(SP)+,R5
								CK.R5=S.TOP
.ENDC
10$:	MOV	FNFLAG,R0
				.Assume WREQ!RDAWRT!RREQ NE 0
	BEQ	INTRQS
				.Assume RDAWRT GT 0
	BPL	30$
	TST	DWWCHK
	BEQ	40$
				.Assume RREQ EQ 1
	ASR	R0
	BCC	20$
	CALL	DUMP
	BR	40$
				.Assume RREQ EQ 1
20$:	INC	FNFLAG
	BR	110$
30$:	BMI	40$
	JSR	R0,MTFILL
	  MOV	@R4,(R2)+
	  MOV	@R4,R5
								CK.R5 Q$BLKN
40$:	MOV	WCNT,Q$WCNT(R5)
	BEQ	INTRQS
.IF NE	MMG$T
								CK.R5 Q$BLKN
	MOV	PARVAL,Q$PAR(R5)
.IFF
								CK.R5 Q$BLKN
	MOV	BUFF,Q$BUFF(R5)
.ENDC
	TST	FNFLAG
				.Assume WREQ EQ 100000
	BPL	50$
	ASL	(PC)+
	.WORD	100000
	BCS	60$
50$:
								CK.R5 Q$BLKN
	INC	@R5
60$:
								CK.R5 Q$BLKN
	MOV	@R5,R3
	MOV	DRETRY,RETRY
	JMP	RWNEXT
70$:	TST	INREST
DWFD1:	BNE	DWFDE
								CK.R4 DWID
	BIT	#<ERTR0!ERABO>,DWERR(R4)
	BNE	DWFDE
.IF NE	ERL$G
	MOV	R5,-(SP)
								S.TOP=CK.R5
	MOV	R4,-(SP)
								S.TOP2=CK.R4
	CALL	ERLSET
	BISB	RETRY,R4
	CALL	@$ELPTR
	MOV	(SP)+,R4
								CK.R4=S.TOP2
	MOV	(SP)+,R5
								CK.R5=S.TOP
.ENDC
								CK.R4 DWID
	TSTB	DWSTAT(R4)
	BPL	80$
	CALL	DUMP
80$:
								CK.R4 DWID
	BIT	#ERIDNF,DWERR(R4)
	BEQ	90$
								CK.R4 DWID
	MOV	DWST2(R4),R3
	BIT	#S2WRF,R3
	BNE	DWFDE
	BIC	#^C<S2SEK!S2DWY>,R3
	CMP	#<S2SEK!S2DWY>,R3
	BNE	DWFDE
	MOV	SP,INREST
	MOV	CLRIRR,@#ICOPND
								CK.R4 DWID
	MOV	#CMREST,DWCMD(R4)
CLRPND:
	MOV	CLRIMR,@#ICOPND
	RETURN
90$:	DEC	RETRY
	BEQ	DWFDE
	CLR	INREST
	TST	FNFLAG
				.Assume RREQ!WREQ NE 0
	BEQ	120$
				.Assume WREQ EQ 100000
	BPL	100$
	BIT	#RDAWRT,FNFLAG
	BNE	110$
100$:	JMP	RWRTRY
110$:
	CALL	DSKADR
	CALLR	DOREAD
120$:	JMP	XRETRY
	.DSABLE	LSB
.SBTTL	I/O COMPLETION SECTION
	.ENABL	LSB
DWFDE:
.IF NE	ERL$G
	MOV	R5,-(SP)
								S.TOP=CK.R5
	CALL	ERLSET
	CALL	@$ELPTR
	MOV	(SP)+,R5
								CK.R5=S.TOP
.ENDC
DWFUE:
								CK.R5 Q$BLKN
	BIS	#HDERR$,@Q$CSW(R5)
DWRQS:
	.DRFIN	DW
	.DSABLE LSB
.SBTTL	EMPTY/FILL THE CONTROLLER'S SECTOR BUFFER SUBROUTINE
	.ENABL	LSB
MTFILL:
								S.TOP=CK.R5
	MOV	R5,-(SP)
								S.TOP2=CK.R4
	MOV	R4,-(SP)
	MOV	(R0)+,60$
	MOV	(R0)+,100$
								CK.R4 DWID
	MOV	R4,R3
								CK.R3=CK.R4
	ADD	#DWSTAT,R3
							CK.R3 DWID,+DWSTAT
	ADD	#DWBUF,R4
							CK.R4 DWID,+DWBUF
								CK.R5 Q$BLKN
	MOV	Q$BUFF(R5),R2
								CK.R5 Q$BLKN
	MOV	Q$WCNT(R5),R1
	BEQ	90$
	MOV	R1,WCNT
	CMP	R1,#256.
	BLOS	10$
	MOV	#256.,R1
10$:	TST	FNFLAG
				.Assume WREQ EQ 100000
	BPL	20$
	ASL	(PC)+
	.WORD	100000
	BCS	30$
20$:	SUB	R1,WCNT
30$:
.IF NE	MMG$T
								CK.R5 Q$BLKN
	MOV	Q$PAR(R5),PARVAL
	JSR	R0,@#.-.
$P1EXT	=:.-2
	.WORD	PARVAL-.
.IFF
	MOV	R2,BUFF
	TST	FNFLAG
				.Assume WREQ EQ 100000
	BPL	40$
	ASL	(PC)+
	.WORD	100000
	BCS	50$
40$:	ADD	#512.,BUFF
.ENDC
50$:
								CK.R3 DWSTAT
	MOVB	@R3,R5
	BPL	50$
60$:	 .WORD	0
	SOB	R1,50$
.IF NE	MMG$T
PARVAL:	.WORD	0
	TST	FNFLAG
				.Assume WREQ EQ 100000
	BPL	70$
	ASL	(PC)+
	.WORD	100000
	BCS	80$
70$:	ADD	#<256./32.>,PARVAL
80$:
.ENDC
90$:
								CK.R3 DWSTAT
	MOV	@R3,R5
				.Assume STBUSY EQ 100000
	BMI	110$
				.Assume STOPND EQ 1
	ASR	R5
	BCS	110$
				.Assume STDRQ EQ 200
	ASLB	R5
	BPL	90$
100$:	 .WORD	0
	BR	90$
110$:
	MOV	(SP)+,R4
								CK.R4=S.TOP2
	MOV	(SP)+,R5
								CK.R5=S.TOP
	RTS	R0
	.DSABL	LSB
.SBTTL	DUMP THE CONTROLLER'S SECTOR BUFFER SUBROUTINE
	.ENABLE	LSB
DUMP:
								CK.R4 DWID
								CK.R2=CK.R4
	MOV	R4,R2
	ADD	#DWSTAT,R2
							CK.R2 DWID,+DWSTAT
	MOV	R4,R3
								CK.R3=CK.R4
	ADD	#DWBUF,R3
							CK.R3 DWID,+DWBUF
10$:
								CK.R2 DWSTAT
	MOV	@R2,R1
	ASR	R1
				.Assume STOPND EQ 1
	BCS	20$
	ASLB	R1
				.Assume STDRQ EQ 200
	BPL	10$
								CK.R3 DWBUF
	MOV	@R3,R1
	BR	10$
20$:
	RETURN
	.DSABL	LSB
DSKADR:
	MOV	#.-.,R0
CRNT2	=:.-2
							CK.R0=CRNTCYL
							CK.R0 CRNTCYL,+2
							CK.R4 DWID
	MOV	(R0)+,DWCYL(R4)
							CK.R0 CRNTHD,+2
							CK.R4 DWID
	MOV	(R0)+,DWHEAD(R4)
							CK.R0 CRNTSEC,+2
							CK.R4 DWID
	MOV	(R0)+,DWSEC(R4)
	RETURN
.IF NE	ERL$G
.SBTTL	ERROR LOGGING SETUP SUBROUTINE
	.ENABLE	LSB
ERLSET:
	.ADDR	#ERLIST,R2
	MOV	R2,R3
								CK.R4 DWID
	MOV	DWSTAT(R4),(R3)+
				.Assume STBUSY EQ 100000
	BMI	10$
								CK.R4 DWID
	MOV	DWCYL(R4),(R3)+
								CK.R4 DWID
	MOV	DWHEAD(R4),(R3)+
								CK.R4 DWID
	MOV	DWSEC(R4),(R3)+
								CK.R4 DWID
	MOV	DWERR(R4),(R3)+
								CK.R4 DWID
	MOV	DWST2(R4),@R3
	BR	20$
10$:	MOV	#-1,@R3
	MOV	(R3)+,@R3
	MOV	(R3)+,@R3
	MOV	(R3)+,@R3
	MOV	(R3)+,@R3
20$:	MOV	DRETRY,R3
	SWAB	R3
	BISB	#ERLRGS,R3
	MOV	#<DW$COD*400>,R4
	RETURN
	.DSABL	LSB
.ENDC
	.SBTTL	BOOTSTRAP READ ROUTINE
	.DRBOT	DW,BOOT1,READ,CONTROL=<CBUS>
	.ENABL	LSB
.=DWBOOT+14
DSKTYP:
	MOV	#7,R3
								CK.R4=DWID
	CLR	DWSEC(R4)
 10$:
								CK.R5=CK.R4
	 MOV	R4,R5
	 BR	20$
.=DWBOOT+40
BOOT1:	JMP	@#<BOOT-DWBOOT>
 20$:
							CK.R5 DWID,+DWCYL
	 ADD	#DWCYL,R5
							CK.R5 DWCYL,+2
	 CLR	(R5)+
							CK.R5 DWHEAD,+2
	 MOV	R3,(R5)+
							CK.R5 DWCMD,+2
	 MOV	#CMREAD,(R5)+
	 BR	25$
.Assume	. LE DWBOOT+120,MESSAGE=<;Bootstrap overlap>
.=DWBOOT+120
 25$:
  30$:
							CK.R5 DWSTAT
	  TST	@R5
				.Assume STBUSY EQ 100000
	  BMI	30$
							CK.R4 DWID
	 BIT	#S2ERR,DWST2(R4)
	 BEQ	40$
							CK.R4 DWID
	 BIT	#ERIDNF!ERABO,DWERR(R4)
	 BEQ	40$
	 SOB	R3,10$
	BR	60$
 40$:
							CK.R5 DWSTAT
	 BIT	#STOPND,@R5
	 BNE	50$
							CK.R5 DWSTAT
	 TSTB	@R5
				.Assume STDRQ EQ 200
	 BPL	40$
							CK.R4 DWID
	 TST	DWBUF(R4)
	 BR	40$
50$:
	INC	R3
	MOV	R3,DW$HD
	TST	(PC)+
60$:
	SEC
	RETURN
HITYP:
	.DSABL	LSB
	.ENABL	LSB
READ:	ASRB	(PC)+
	 .WORD	1
	BCC	READX
	CLR	R5
	BISB	@#173050,R5
	SWAB	R5
	ASL	R5
	SUB	#200,R5
	MOV	R5,@#KISAR1
	MOV	#AP$ACF,R5
	MOV	R5,@#KISDR1
	CLR	@#KISAR0
	MOV	R5,@#KISDR0
	MOV	#177600,@#KISAR7
	MOV	R5,@#KISDR7
	BIS	#20,@#MMUSR3
	INC	@#MMUSR0
	MOV	#CTI+PROCFG,R3
				.ASSUME	SLOT0 EQ CTI-4
	MOV	@R3,R4
	MOV	R4,R5
 10$:
	 TST	-(R3)
	 CMP	-(R3),#DW$ID
	 BEQ	20$
	 SOB	R5,10$
	CLR	@#MMUSR0
	BR	ERRX
20$:
	CLR	@#MMUSR0
	SUB	R5,R4
	ASH	#7.,R4
	ADD	R4,DWCSR1
	MOV	DWCSR1,R4
								CK.R4=DWID
								CK.R4 DWID
	BIT	#STDCAP,DWSTAT(R4)
	BNE	READX
	MOV	#-1,DW$CY1
	CALL	DSKTYP
	BCS	ERRX
	.DSABL	LSB
	.ENABL	LSB
READX:
	MOV	(PC)+,R4
DWCSR1:	 .WORD	PC$CSR
								CK.R4=DWID
								CK.R4 DWID
	TST	DWSTAT(R4)
				.Assume STBUSY EQ 100000
	BMI	ERRX
10$:
	MOV	R0,-(SP)
	MOV	R1,-(SP)
 BOTNXT:
	 MOV	@SP,R3
	 CMP	R3,#256.
	 BLOS	20$
	 MOV	#256.,R3
 20$:
	 SUB	R3,@SP
	 MOV	2(SP),R1
	 INC	R1
	 INC	2(SP)
	 MOV	R1,R5
	 BIC	#SECMSK,R5
								CK.R4 DWID
	 MOV	R5,DWSEC(R4)
 	 ASH	#-SECBIT,R1
				.Assume SECBIT EQ 4
	 BIC	#170000,R1
	 CLR	R0
	 DIV	#4,R0
DW$HD	=:.-2
	 CMP	R0,(PC)+
DW$CY1:  .WORD	153.
	 BLO	30$
ERRX:
	JMP	@#<BIOERR-DWBOOT>
 30$:
								CK.R4 DWID
	 MOV	R4,R5
								CK.R5=CK.R4
							CK.R5 DWID,+DWCYL
	 ADD	#DWCYL,R5
							CK.R5 DWCYL,+2
	 MOV	R0,(R5)+
							CK.R5 DWHEAD,+2
	 MOV	R1,(R5)+
							CK.R5 DWCMD,+2
	 MOV	#CMREAD,(R5)+
	.DSABL	LSB
	.ENABL	LSB
  10$:
								CK.R5 DWSTAT
	  TST	@R5
				.Assume STBUSY EQ 100000
	  BMI	10$
								CK.R4 DWID
	 BIT	#S2ERR,DWST2(R4)
	 BNE	ERRX
  20$:
   30$:
								CK.R5 DWSTAT
	   TSTB	@R5
				.Assume STDRQ EQ 200
	   BPL	30$
	  MOV	DWBUF(R4),(R2)+
	  SOB	R3,20$
  40$:
								CK.R5 DWSTAT
	  BIT	#STOPND,@R5
	  BNE	50$
	  TSTB	@R5
				.Assume STDRQ EQ 200
	  BPL	40$
								CK.R4 DWID
	  TST	DWBUF(R4)
	  BR	40$
 50$:
	 TST	@SP
	 BNE	BOTNXT
	CMP	(SP)+,(SP)+
	CLC
	RETURN
.Assume	. LE DWBOOT+612,MESSAGE=<;Bootstrap overlap>
.DSABL	LSB
.=DWBOOT+612
BOOT:	MOV	#10000,SP
	MOV	#2,R0
	MOV	#<4*256.>,R1
	MOV	#1000,R2
	CALL	READ
	MOV	#<READ-DWBOOT>,@#B$READ
	MOV	#B$DNAM,@#B$DEVN
	CLR	@#B$DEVU
	JMP	@#B$BOOT
	.DREND	DW
.SBTTL	FETCH/LOAD code
.PSECT	SETOVR
SETOVR:
	.ENABLE	LSB
FETCH:
	NOP
	MOV	@R5,R5
								CK.R5=DWBASE
	MOV	@#SYSPTR,R2
								CK.R2=SYSPTR
.IF	NE	MMG$T
								CK.R2 SYSPTR
								CK.R5 DWBASE
	MOV	P1EXT(R2),$P1EXT-DWBASE(R5)
.ENDC
								CK.R5 DWBASE
	MOV	DWCSR-DWBASE(R5),R0
								CK.R0=DWID
	BNE	15$
	MOV	#DW$ID,-(SP)
								CK.R1=$GTVEC
								CK.R1 ,+2
	TST	(R1)+
								CK.R1 $GTCSR
	CALL	@R1
	MOV	(SP)+,R0
								CK.R0=DWID
	BCS	FETERR
								CK.R0 DWID
								CK.R5 DWBASE
	MOV	R0,DWCSR-DWBASE(R5)
	MOV	#DW$ID,-(SP)
							CK.R1 $GTCSR,+2
	TST	(R1)+
								CK.R1 $GTSLT
	CALL	@R1
								CK.R5 DWBASE
	BIS	@SP,CLRIMR-DWBASE(R5)
								CK.R5 DWBASE
	BIS	@SP,SETIMR-DWBASE(R5)
								CK.R5 DWBASE
	BIS	(SP)+,CLRIRR-DWBASE(R5)
	BR	17$
15$:
	INC	DWTYPX
17$:
	MOV	R5,R1
								CK.R1=CK.R5
	ADD	#DRETRY-DWBASE,R1
							CK.R1 ,+DRETRY-DWBASE
								CK.R1 DRETRY
								CK.R5 DWBASE
	MOV	R1,DRETR1-DWBASE(R5)
								CK.R1 DRETRY
	ADD	#CRNTCYL-DRETRY,R1
							CK.R1 ,+CRNTCYL-DRETRY
								CK.R1 CRNTCYL
								CK.R5 DWBASE
	MOV	R1,CRNT1-DWBASE(R5)
								CK.R1 CRNTCYL
								CK.R5 DWBASE
	MOV	R1,CRNT2-DWBASE(R5)
								CK.R1 CRNTCYL
	ADD	#FNTBL-CRNTCYL,R1
							CK.R1 ,+FNTBL-CRNTCYL
								CK.R1 FNTBL
								CK.R5 DWBASE
	MOV	R1,FNTBL1-DWBASE(R5)
	CMP	#DPT.BT,R3
	BNE	20$
	MOV	@#DW$HD-DWBOOT,R3
	BR	HEADCK
.SBTTL	Use the DSKTYP routine in DRBOT
								CK.R2 SYSPTR
20$:
	MOV	DWTYPE(R2),R3
	BIT	#1,DWTYPX
	BEQ	23$
	SWAB	R3
23$:
	MOVB	R3,R3
	BNE	FETUPD
	.DSABL	LSB
	.ENABL	LSB
	MOV	R4,-(SP)
								S.TOP=CK.R4
	MOV	R5,-(SP)
								S.TOP2=CK.R5
								CK.R0 DWID
	MOV	R0,R4
								CK.R4=CK.R0
								CK.R4 DWID
	CALL	DSKTYP
	MOV	(SP)+,R5
								CK.R5=S.TOP2
	MOV	(SP)+,R4
								CK.R4=S.TOP
	BCS	FETERR
HEADCK:
	CMP	#4,R3
	BNE	30$
							CK.R3=4
							CK.R0 DWID
	BIT	#STDCAP,DWSTAT(R0)
	BEQ	30$
.rem	%	enable for RD31 support
	BNE	20$
	DEC	R3
							CK.R3 ,-1
							CK.R3 TYP31
	.ADDR	#BUFHOM,R2
	MOV	#256.,R1
	MOV	#BLKHOM,R0
	CALL	@R4
	BCS	FETERR
	.ADDR	#BUFWRP,R2
	MOV	#SIZWRP,R1
	MOV	#BLKR51,R0
	CALL	@R4
	BCS	FETERR
	MOV	#SIZWRP,R0
	.ADDR	#BUFHOM,R1
	.ADDR	#BUFWRP,R2
 10$:
	 CMP	(R1)+,(R2)+
	 BNE	FETUPD
	 SOB	R0,10$
	DEC	R3
								CK.R3 ,-1
								CK.R3 TYP51
	COM	BUFHOM+2
	COM	BUFHOM+4
%
20$:
	MOV	#TYP50,R3
	BR	FETUPD
	.DSABL	LSB
30$:
.REM	%	enable for RD31 support
	.DSABL	LSB
	.ENABL	LSB
	CMP	#8.,R3
	BNE	FETXLT
%
	.ENABL	LSB
FETXLT:
	.ADDR	#DWTAB-4,R3,ADD
	MOVB	@R3,R3
FETUPD:
	.ADDR	#DEVCHR,R1
 10$:
	 CMPB	@R1,R3
	 BEQ	20$
	 ADD	#TSIZE,R1
	 BR	10$
20$:
	MOV	#TSIZE/2,R0
								CK.R5 DWBASE
	ADD	#RDTYP-DWBASE,R5
 30$:
	 MOV	(R1)+,(R5)+
	 SOB	R0,30$
40$:
								CK.R2 SYSPTR
	MOVB	R3,DWTYPE(R2)
DWTYPX=:.-2
FETXIT:
	TST	(PC)+
FETERR:
	SEC
	BIC	R0,R0
	RETURN
	.DSABL	LSB
DWTAB:	.BYTE	      2,4,0,6,5
	.EVEN
DEVCHR:
$TYPE$	TYP50  4.  153.    9792.   9727.      0.  9792.  9727.
$TYPE$	TYP51  4.  306.   19584.  19519.      0. 19584. 19519.
$TYPE$  TYP31  4.  615.   39360.  39295.      0. 39360. 39295.
$TYPE$	TYP52C 5.  697.   55760.  55679.      0. 55760. 55679.
$TYPE$	TYP52Q 8.  512.   65536.  65407.      1. 65535. 65407.
$TYPE$	TYP52A 7.  645.   72240.  72127.   6705. 65535. 65535.
$TYPE$  TYP53  8. 1024.  131072. 130943.  65535. 65535. 65535.
SIZWRP	=:	10.
BLKHOM	=:	1.
BLKR51	=:	<306.+1.>*16.+BLKHOM
BUFWRP:	.BLKW	SIZWRP
BUFHOM:
.ASSUME	BUFHOM+1000 LE SETOVR+2000,MESSAGE=<;FETCH area overflow>
.ASSUME	.+<HITYP-DWBOOT> LE SETOVR+2000,MESSAGE=<;DSKTYP not all in FETCH blocks>
.END
                                                                                                                                                                                                                       