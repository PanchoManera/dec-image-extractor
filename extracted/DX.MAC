.MCALL	.MODULE
.MODULE	DX,VERSION=08,COMMENT=<RX01 Floppy Disk Handler>,AUDIT=YES

;                     	 COPYRIGHT (c) 1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
.SBTTL	CONDITIONAL ASSEMBLY SUMMARY
	.SBTTL	DEFINITIONS
	.ENABL	LC
	.MCALL	.DRDEF	.ASSUME	.BR	.ADDR
.DSTATUS=:342
.READ	=:375
	..READ	=:010
.WRITE	=:375
	..WRIT	=:011
SYSCHN	=:17
	JSW	=:44
	SYSPTR	=:54
		P1EXT	=: 432
.IIF NDF DXT$O, DXT$O=0
.IIF NDF DX$CS2, DX$CS2	== 177174
.IIF NDF DX$VC2, DX$VC2	== 270
	.DRDEF	DX,22,FILST$!SPFUN$!DX$COD,494.,177170,264
	.DRPTR
	.DREST	CLASS=DVC.DK,MOD=DVM.DX
	.DRSPF	<377>
	.DRSPF	<376>
	.DRSPF	<375>
	CSGO	=:     1
	CSUNIT	=:    20
	CSDONE	=:    40
	CSINT	=:   100
	CSTR	=:   200
	CSRX02	=:  4000
	CSINIT	=: 40000
	CSERR	=:100000
	CSFBUF	=:0*2
	CSEBUF	=:1*2
	CSWRT	=:2*2
	CSRD	=:3*2
	CSRDST	=:5*2
	CSWRTD	=:6*2
	CSMAIN	=:7*2
	CSREAD	=:CSEBUF&CSRD&CSRDST&CSMAIN
.ASSUME	CSRD&2		NE 0
.ASSUME	CSWRT&2		EQ 0
.ASSUME	CSWRTD&2	EQ 0
	ESCRC	=:     1
	ESPAR	=:     2
	ESID	=:     4
	ESDD	=:   100
	ESDRY	==   200
	DXNREG	=:3
	RETRY	=:8.
	SPFUNC	=:100000
	.SBTTL	INSTALLATION CHECKS
	.DRINS	DX
	NOP
	BIT	#CSRX02,@INSCSR
	BEQ	O.GOOD
	BR	O.BAD
FINDRV:
	.ADDR	#DEVNAM,R0
	.ADDR	#DAREA+1,-(SP)
	EMT	.DSTATUS
	BCS	O.BAD
	MOV	DAREA+4,R1
	BNE	O.GOOD
	BR	O.BAD
DAREA:	.BLKW	4
DEVNAM:	.RAD50	/DX /
BAREA:	.BYTE	SYSCHN,..READ
	.BLKW
	.BLKW
	.WORD	256.
	.WORD	0
X.WP:
	.ADDR	#DXWPRO,R0
	ADD	R3,R0
	MOVB	(PC)+,(R0)
O.WPF:	.BLKW	1
	CALL	FINDRV
	BCS	O.GOOD
	CMP	@#SYSPTR,R1
	BHI	10$
	MOV	#100000,DXW1-DXLQE(R1)
10$:
	ADD	R3,R1
	MOVB	O.WPF,DXWPRO-DXLQE(R1)
	BR	O.GOOD
	.IIF GT,<.-376>	.ERROR
	.SBTTL	SET OPTIONS
	.DRSET	CSR,	160000,	O.CSR,	OCT
	.DRSET	VECTOR,	500,	O.VEC,	OCT
	.IF NE DXT$O
	.DRSET	CSR2,	160000,	O.CSR2,	OCT
	.DRSET	VEC2,	500,	O.VEC2,	OCT
	.ENDC;NE DXT$O
	.DRSET	RETRY,	RETRY,	O.RTRY,	NUM
	.IF NE ERL$G
	.DRSET	SUCCES,	-1,	O.SUCC,	NO
	.ENDC
	.DRSET	WRITE,	1,	 O.WP,	NO
	BTCSR = <DXEND-DXSTRT>+<BOTCSR-DXBOOT>+1000
O.CSR:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,INSCSR
	.ADDR	#BAREA+4,R1
	.ADDR	#1000,R2
	MOV	R2,(R1)
	MOV	#BTCSR/1000,-(R1)
	TST	-(R1)
	MOV	R0,R3
	MOV	R1,R0
	EMT	.READ
	BCS	O.BAD
	MOV	R3,<BTCSR&777>(R2)
	MOV	R1,R0
					.ASSUME ..READ+1 EQ ..WRIT
	INCB	1(R0)
	EMT	.WRITE
	BCS	O.SYWL
	MOV	R1,R0
					.ASSUME ..WRIT-1 EQ ..READ
	DECB	1(R0)
	MOV	#1,2(R0)
	EMT	.READ
	BCS	O.BAD
	.IF EQ DXT$O
	MOV	R3,RXCSA
	.IFF
	MOV	R3,DXCSR
	.ENDC
O.GOOD:	TST	(PC)+
O.BAD:	SEC
	RETURN
O.SYWL:
	MOV	@SP,R0
	INC	R0
	CMPB	#BR/400,(R0)+
	BNE	O.BAD
	MOV	R0,@SP
	BR	O.BAD
O.VEC:	CMP	R0,R3
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	.IF EQ DXT$O
	MOV	R0,DXSTRT
	.IFF
	MOV	R0,DX$VTB
	.ENDC
	BR	O.GOOD
	.IF NE DXT$O
O.CSR2:	CMP	R0,R3
	BLO	O.BAD
	MOV	R0,DXCSR2
	BR	O.GOOD
O.VEC2:	CMP	R0,R3
	BHIS	O.BAD
	BIT	#3,R0
	BNE	O.BAD
	MOV	R0,DX$VTB+6
	BR	O.GOOD
	.ENDC
O.RTRY:	CMP	R0,R3
	BHI	O.BAD
	MOV	R0,DRETRY
	BNE	O.GOOD
	BR	O.BAD
	.IF NE ERL$G
O.SUCC:	MOV	#0,R3
N.SUCC:	MOV	R3,SCSFLG
					.ASSUME O.SUCC+4 EQ N.SUCC
	BR	O.GOOD
	.ENDC
O.WP:	NOP
	CLR	R3
N.WP:
					.ASSUME O.WP+4 EQ N.WP
	MOV	R3,O.WPF
	MOV	R1,R3
	CMP	R3,#DXT$O*2+1
	BHI	O.BAD
	JMP	X.WP
	.IIF GT,<.-1000> .ERROR
	.SBTTL	DRIVER REQUEST ENTRY POINT
	.ENABL	LSB
	.DRBEG	DX
	BR	DXENT
DXWPRO:
	.REPT	DXT$O+1
	.BYTE	0,0
	.ENDR
				.ASSUME . LE DXSTRT+1000
	.IF NE ERL$G
SCSFLG:	.WORD	0
				.ASSUME . LE DXSTRT+1000
	.ENDC
	.IF NE	DXT$O
	.DRVTB	DX,DX$VEC,DXINT
	.DRVTB	,DX$VC2,DXINT
	.ENDC
DXENT:
.IF NE	MMG$T
	MOV	@#SYSPTR,R4
	MOV	P1EXT(R4),(PC)+
$P1EXT:	 .WORD	P1EXT
.ENDC
	MOV	(PC)+,(PC)+
DRETRY:	 .WORD	RETRY
				.ASSUME . LE DXSTRT+1000
RXTRY:	 .WORD	0
	MOV	DXCQE,R3
	MOV	(R3)+,R5
	MOV	#CSRD!CSGO,R4
				.ASSUME Q$BLKN+2 EQ Q$FUNC
	MOVB	(R3)+,R1
				.ASSUME Q$FUNC+1 EQ Q$UNIT
	MOVB	(R3)+,R0
	ASRB	R0
	BCC	1$
	BIS	#CSUNIT,R4
1$:
	.IF EQ	DXT$O
	BITB	#6/2,R0
	BNE	RXERR
	.IFF
	MOV	(PC)+,-(SP)
DXCSR = .
	 .WORD	DX$CSR
				.ASSUME . LE DXSTRT+1000
	ASRB	R0
	BCC	2$
	MOV	(PC)+,(SP)
DXCSR2 = .
	 .WORD	DX$CS2
				.ASSUME . LE DXSTRT+1000
2$:	MOV	(SP)+,RXCSA
	ASRB	R0
	BCS	RXERR
	.ENDC
				.ASSUME Q$UNIT+1 EQ Q$BUFF
	MOV	(R3)+,R0
				.ASSUME Q$BUFF+2 EQ Q$WCNT
	MOV	(R3)+,R2
	BPL	3$
	ASL	(PC)+
DXW1:	.WORD	.-.
				.ASSUME . LE DXSTRT+1000
	BCS	33$
	CLR	-(SP)
				.ASSUME Q$WCNT+2 EQ Q$COMP
	MOVB	Q$UNIT-Q$COMP(R3),(SP)
	BIC	#<^C3>,(SP)
	.ADDR	#DXWPRO,(SP),ADD; TO UNIT OFFSET
	TSTB	@(SP)+
	BNE	RXERR
				.ASSUME CSRD-2 EQ CSWRT
33$:	CMPB	-(R4),-(R4)
.ASSUME	CSWRT	EQ	CSRD-2
	NEG	R2
3$:	ASL	R1
	ADD	PC,R1
	ADD	CHGTBL-.(R1),R4
	MOV	R4,RXFUN2
	BMI	7$
	MOVB	R2,FILLCT
	DECB	FILLCT
	ASL	R2
	ASL	R5
	ASL	R5
	MOV	(PC)+,R4
	 .BYTE	-7,-26.
4$:	CMP	#26.*200,R5
	BHI	5$
	ADD	#-26.*200,R5
5$:	ROL	R5
	INCB	R4
	BLE	4$
	MOVB	R5,R1
	ADD	R4,R5
	MOV	R1,R4
	ASL	R1
	ADD	R4,R1
	ASL	R1
6$:	SUB	#26.,R1
	BGT	6$
	MOV	R1,TRKOFF
	BR	8$
7$:	SWAB	R5
	BISB	R2,R5
	MOV	#128.,R2
	.IF EQ	MMG$T
	CLR	(R0)+
	.IFF
	MOV	DXCQE,R4
	CLR	-(SP)
	CALL	@$PTWRD
	TST	(R0)+
	.ENDC
8$:	MOV	R0,(PC)+
BUFRAD:	 .WORD	0
	MOV	R5,TRACK
	MOV	R2,(PC)+
BYTCNT:	 .WORD	0
	.IF NE	MMG$T
	TST	(R3)+
	MOV	@R3,PARVAL
	.ENDC
	.BR	RXINIT
	.DSABL	LSB
	.SBTTL	START TRANSFER OR RETRY
	.ENABL	LSB
RXINIT:	MOV	#100000,RXIRTN
	MOV	RXCSA,R4
	BR	RXIENB
1$:	BIT	#CSREAD,R0
	BNE	3$
2$:	JSR	R0,SILOFE
	 .WORD	CSFBUF!CSGO
	 MOVB	(R2)+,@R5
	 MOV	R1,@R5
3$:	MOVB	SECTOR,R2
	BGT	5$
	SUB	#-14.,R2
	BGT	4$
	ADD	#12.,R2
	SEC
4$:	ROL	R2
	ADD	(PC)+,R2
TRKOFF:	 .WORD	0
	BGT	5$
	ADD	#26.,R2
5$:	MOV	R0,@R4
6$:	TSTB	@R4
	BEQ	6$
	BPL	RXRTRY
	MOVB	R2,@R5
7$:	TSTB	@R4
	BEQ	7$
	BPL	RXRTRY
	MOVB	(PC)+,@R5
TRACK:	 .BYTE	0
SECTOR:	 .BYTE	0
RXIENB:	BIS	#CSINT,@R4
	RETURN
RXERR:	MOV	DXCQE,R4
	BIS	#HDERR$,@-(R4)
	BR	13$
	.DRAST	DX,5,RXABRT
	.FORK	DXFBLK
	MOV	(PC)+,R0
RXFUN2:	 .WORD	0
	MOV	#128.,R3
	MOV	(PC)+,R4
RXCSA:	 .WORD	DX$CSR
				.ASSUME . LE DXSTRT+1000
	MOV	R4,R5
	TST	(R5)+
	BMI	RXRTRY
	ASL	(PC)+
RXIRTN:	 .WORD	0
	BCS	1$
	BIT	#CSREAD,R0
	BEQ	10$
	TST	R0
	BPL	9$
	BIT	#ESDD,@R5
	BEQ	9$
	.IF EQ	MMG$T
	MOV	BUFRAD,R2
	INC	-(R2)
	.IFF
	MOV	R4,R1
	MOV	DXCQE,R4
	MOV	#1,-(SP)
	SUB	#2,Q$BUFF(R4)
	CMP	Q$BUFF(R4),#20000
	BHIS	85$
	ADD	#20000,Q$BUFF(R4)
	SUB	#200,Q$PAR(R4)
85$:	CALL	@$PTWRD
	MOV	R1,R4
	.ENDC
9$:	JSR	R0,SILOFE
	 .WORD	CSEBUF!CSGO
	 MOVB	@R5,(R2)+
	 MOV	@R5,R2
10$:	INCB	SECTOR
	BNE	11$
	ADD	#-26.*400+1,TRACK
	ADD	#6,TRKOFF
	BLE	11$
	SUB	#26.,TRKOFF
11$:
	.IF EQ	MMG$T
	ADD	R3,BUFRAD
	.IFF
	ADD	#2,PARVAL
	.ENDC
	SUB	R3,BYTCNT
	BHI	1$
	CLR	BYTCNT
	BIT	#CSREAD!SPFUNC,R0
	BNE	12$
	ADD	#040000,(PC)+
	 .BYTE	0
FILLCT:	 .BYTE	0
	BCC	2$
12$:
	.IF NE	ERL$G
	TST	SCSFLG
	BNE	13$
	MOV	#DX$COD*400+377,R4
	MOV	DXCQE,R5
	CALL	@$ELPTR
	.ENDC
13$:	CLR	@RXCSA
14$:	.DRFIN	DX
RXABRT:	MOV	#CSINIT,@RXCSA
	CLR	DXFBLK+2
	BR	14$
	.DSABL	LSB
RXRTRY:
	.IF NE	ERL$G
	.ADDR	#DXRBUF,R3
	MOV	R3,R2
	MOV	@R4,(R3)+
	MOV	@R5,(R3)+
	MOV	#CSMAIN!CSGO,@R4
1$:	BIT	#CSDONE,@R4
	BEQ	1$
	MOV	@R5,@R3
	MOV	DRETRY,R3
	SWAB	R3
	ADD	#DXNREG,R3
	MOV	#DX$COD*400,R4
	BISB	RXTRY,R4
	DECB	R4
	MOV	DXCQE,R5
	CALL	@$ELPTR
	MOV	RXCSA,R4
	.ENDC
	DEC	RXTRY
	BGT	2$
	JMP	RXERR
2$:	MOV	#CSINIT,@R4
	JMP	RXINIT
	.SBTTL	SILOFE - FILL OR EMPTY THE SILO
	.ENABL	LSB
SILOFE:	MOV	(R0)+,@R4
	MOV	(R0)+,3$
	MOV	(R0)+,5$
	MOV	BYTCNT,R1
	BEQ	4$
	CMP	R1,R3
	BLOS	1$
	MOV	R3,R1
1$:	MOV	BUFRAD,R2
.IF NE	MMG$T
	JSR	R0,@$P1EXT
	.WORD	PARVAL-.
.ENDC
2$:	TSTB	@R4
	BPL	2$
3$:	HALT
	TSTB	@R4
	DECB	R1
	BNE	2$
.IF NE	MMG$T
PARVAL:	.WORD	0
.ENDC
4$:	TSTB	@R4
	BGT	6$
	BEQ	4$
5$:	HALT
	BR	4$
6$:	RTS	R0
	.DSABL	LSB
	.SBTTL	TABLES, FORK BLOCK, END OF DRIVER
	.WORD	CSWRTD-CSRD+SPFUNC
	.WORD	CSWRT-CSRD+SPFUNC
	.WORD	CSRD-CSRD+SPFUNC
CHGTBL:	.WORD	0
DXFBLK:	.WORD	0,0,0,0
	.IF NE	ERL$G
DXRBUF:	.BLKW	DXNREG
	.ENDC
	.SBTTL	BOOTSTRAP DRIVER
	.DRBOT	DX,BOOT1,READ
	. = DXBOOT+14
	.WORD	READS-DXBOOT
	.WORD	340
	.WORD	WAIT-DXBOOT
	.WORD	340
	. = DXBOOT+34
BOOT1:	MOVB	UNITRD-DXBOOT(R0),RDCMD
REETRY:	MOV	@PC,SP
	MOV	#200,R2
	CLR	R0
	BR	B2$
	. = DXBOOT+56
UNITRD:	.BYTE	CSGO+CSRD
	.BYTE	CSGO+CSRD+CSUNIT;READ FROM UNIT 1
	. = DXBOOT+70
WAIT:	TST	@R4
	BEQ	WAIT
	BMI	REETRY
RTIRET:	RTI
	. = DXBOOT+120
READS:	MOV	(PC)+,R4
BOTCSR:	 .WORD	DX$CSR
	MOV	R4,R5
	MOV	(PC)+,(R5)+
RDCMD:	.WORD	0
	IOT
	MOV	R3,@R5
	IOT
	MOV	R0,@R5
	IOT
	MOV	#CSGO+CSEBUF,@R4;LOAD EMPTY BUFFER FUNCTION INTO RXCS
BROFFS	=	READF-.
RDX:	IOT
	TSTB	@R4
	BPL	RTIRET
	MOVB	@R5,(R2)+
	DEC	R1
	BGT	RDX
	CLR	R2
	BR	RDX
B2$:	MOV	SP,R1
	INC	R0
	MOV	@PC,R3
				.ASSUME BPT EQ 3
	BPT
BOOT2:	CMPB	(R3)+,(R3)+
	BPT
	CMPB	(R3)+,(R3)+
	BPT
	BIT	#CSUNIT,RDCMD
	BNE	BOOT
	CLR	R0
	BR	BOOT
READ:	MOV	(PC)+,@(PC)+
	 .WORD	167
	 .WORD	RDX-DXBOOT
	MOV	(PC)+,@(PC)+
	 .WORD	READF-RDX-4
	 .WORD	RDX-DXBOOT+2
	MOV	#READ1-DXBOOT,@#B$READ
	MOV	#TRWAIT-DXBOOT,@#20
	CLR	@#JSW
	TST	HRDBOT
	BEQ	READ1
	MOV	@#B$DEVU,R3
	MOVB	UNITRD-DXBOOT(R3),RDCMD
READ1:	ASL	R0
	ASL	R0
	ASL	R1
1$:	MOV	R0,-(SP)
	MOV	R0,R3
	MOV	R0,R4
	CLR	R0
	BR	3$
2$:	SUB	#23.,R3
3$:	INC	R0
	SUB	#26.,R4
	BPL	2$
	CMP	#-14.,R4
	ROL	R3
4$:	SUB	#26.,R3
	BPL	4$
	ADD	#27.,R3
	BPT
	MOV	(SP)+,R0
	INC	R0
	TST	R1
	BGT	1$
	RETURN
READF:	TST	@R4
	BEQ	READF
	BMI	BIOERR
	TSTB	@R4
	BPL	READFX
	MOVB	@R5,(R2)+
	DEC	R1
	BGT	READF
	MOV	#1,R2
	BR	READF
TRWAIT:	TST	@R4
	BMI	BIOERR
	BEQ	TRWAIT
READFX:	RTI
	. = DXBOOT+606
BOOT:	MOV	#10000,SP
	MOV	R0,-(SP)
	MOV	#2,R0
	MOV	#<4*400>,R1
	MOV	#1000,R2
	CLR	(PC)+
HRDBOT:	 .WORD	1
	CALL	READ
	MOV	#READ1-DXBOOT,@#B$READ
	MOV	#B$DNAM,@#B$DEVN
	MOV	(SP)+,@#B$DEVU
	JMP	@#B$BOOT
	.DREND	DX
	.END
                                                                                                                                                                                                                                                                               