.MCALL	.MODULE
.MODULE	LS,VERSION=15,COMMENT=<Serial Printer Handler>

;                   COPYRIGHT (c) 1984,1985,1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
	.SBTTL	Conditional assembly summary
	.SBTTL	ORDER and LABEL PSECTS
	.PSECT	LSDVR
	.PSECT	$$$PAD
	.PSECT	SETOVR
	.PSECT	PC$PDP
PCBASE:
	.PSECT	LSDVR
	.SBTTL	MACROS AND DEFINITIONS
	.DSABL	GBL
	.IIF NDF LS$PC	LS$PC	= 0
	.IIF NDF LS$PDP LS$PDP	= 1
	.IIF EQ  LS$PC!LS$PDP	.ERROR
LSBOTH	= LS$PC&LS$PDP
	.IIF NDF TIM$IT	TIM$IT= 0
	.IIF NE  TIM$IT TIM$IT= 1
	.IIF NDF LS$HANG LS$HANG = TIM$IT
	.IIF NE  LS$HANG LS$HANG = 1
	.IIF NE  MMG$T	EIS$I = 1
	.IIF NDF EIS$I	EIS$I = 0
	.IIF NDF LS$PRI	LS$PRI	= 4
	.IIF NDF LS.CSZ	LS.CSZ	= 132.
	.IIF NDF LS.PSZ	LS.PSZ	= 66.
	.IIF NDF LS$VCX LS$VCX  = 470
	PC.CSR	= 173400
	PC.VEC	= 220
.LSGEN	= LS$PDP!<LS$PC*2>!<LS$HANG*4>!<EIS$I*10>
	.AUDIT	.LS
	.AUDIT	.LSGEN
	.MCALL	.DRDEF,	.INTEN,	.MTPS
	.MCALL	.ADDR,	.ASSUM,	.BR
	.MCALL	.READC,	.WRITE,	.WRITC
	.IIF EQ	EIS$I	.MCALL	SOB
	F.BADR	= 2
	.IF NE LS$PDP
	.DRDEF	LS,41,<WONLY$!SPECL$>,0,176500,300
	.IFF
	.DRDEF	LS,41,<WONLY$!SPECL$>,0,173400,220
	.ENDC
	.IF NE LSBOTH
	.DRPTR	FETCH=FETCH,LOAD=FETCH
	.DREST	CLASS=DVC.LP,MOD2=DV2.V2
	.IFF
	.DRPTR
	.DREST	CLASS=DVC.LP
	.ENDC
	CLOS..	=:1
	LOOK..	=:3
	ENTE..	=:4
	.READ	=:10
	.WRITE	=:11
	SYSPTR	= 54
	SPUSR	=:272
	 ILLFUN	=:2
	LOWMAP	=:326
	CONFG2	=:370
		PRO$	= 020000
	SYSGEN	= 372
	H.DCSR	=	174
	V.TRP4	=: 004
	BLK	=: 1000
	BLOCK0	=	0
	PSW	= 177776
	 PR0	=:000000
	 PR7	=:000240
	 CARRY	=:000001
	SYSCHN	=	17
	RC.IE	= 000100
	XC.IE	= 000100
	IC0DR	= 173200
	IC0CR	= IC0DR+2
	C.CSM	= 050
	C.SSM	= 070
	C.CSI	= 110
	C.SSI	= 130
	RC.ID	= 005
	XC.ID	= 006
	LS$BUF	= PC.CSR
	LS$STA	= PC.CSR+2
	LS$MOD	= PC.CSR+4
	LS$CMD	= PC.CSR+6
	ST.DSR	= 200
	ST.FE	= 040
	ST.OE	= 020
	ST.PE	= 010
	ST.RD	= 002
	ST.TR	= 001
	M1.SBM	= 300
		SB.1	= 100
		SB.15	= 200
		SB.2	= 300
	M1.PT	= 040
	M1.PEN	= 020
	M1.CLM	= 014
		CL.5	= 000
		CL.6	= 004
		CL.7	= 010
		CL.8	= 014
	M1.REQ	= 002
	M2.REQ	= ^B10110000
	B.50	= 00
	B.75	= 01
	B.110	= 02
	B.134	= 03
	B.150	= 04
	B.300	= 05
	B.600	= 06
	B.1200	= 07
	B.1800	= 10
	B.2000	= 11
	B.2400	= 12
	B.3600	= 13
	B.4800	= 14
	B.7200	= 15
	B.9600	= 16
	B.192K	= 17
	CM.OM1	= 200
	CM.OM0	= 100
	CM.RTS	= 040
	CM.RE	= 020
	CM.FB	= 010
	CM.RXE	= 004
	CM.DTR	= 002
	CM.TXE	= 001
	HT	= 11
	LF	= 12
	FF	= 14
	CR	= 15
	CTRLQ	= 'Q-100
	CTRLS	= 'S-100
	SPACE	= 40
	.SBTTL	Block 0 of handler file
	.ASECT
	. = 0
REF0::
	. = 120
ROMCHK:
	CLRB	@H.DCSR
	BCS	1$
	BITB	#177,@H.DCSR
	BEQ	1$
	SEC
1$:
	RETURN
.ASSUME . LE <DISCSR-2>,MESSAGE=<;Code below installation code too large>
	.SBTTL	INSTALLATION CODE
	.ENABL	LSB
	.IF NE LSBOTH
	.DRINS	-LS,PC.CSR
	.IFF
	.DRINS	LS
	.ENDC
	BR	1$
	BR	SETER2
1$:
	MOV	@#SYSPTR,R0
	BIT	#PRO$,CONFG2(R0)
	.IF EQ LS$PC
	BNE	SETER2
	.ENDC
	.IF EQ LS$PDP
	BEQ	SETER2
	.IFF
	BEQ	ROMCHK
	.ENDC
	.IF NE LS$PC
	TST	@#LS$CMD
 	MOVB	#<SB.1!CL.8!M1.REQ>,@#LS$MOD
	MOVB	#<M2.REQ!B.4800>,@#LS$MOD
 ISPEED=:.-4
	MOVB	#<CM.RTS!CM.RE!CM.RXE!CM.DTR!CM.TXE>,LS$CMD
	BR	20$
I.SPEE:
	 .IF NE LSBOTH
	MOV	@#SYSPTR,R1
	BIT	#PRO$,CONFG2(R1)
	BEQ	SETER2
	 .ENDC
	.ADDR	#SPEEDT,R1
10$:	TST	(R1)
	BEQ	SETER2
	CMP	R0,(R1)+
	BNE	10$
	SUB	PC,R1
	SUB	#<SPEEDT+2-.>,R1
	ASR	R1
	BIS	#M2.REQ,R1
	TST	@#LS$CMD
	TST	@#LS$MOD
	MOVB	R1,@#LS$MOD
	MOV	R1,ISPEED
	.ENDC
20$:	TST	(PC)+
SETER2:	SEC
	RETURN
	.DSABL	LSB
	.IF NE LS$PDP
I.VEC:
	.IF NE LSBOTH
	MOV	R0,LX$VTB
	.IFF
	MOV	R0,LS$VTB
	.IFTF
	ADD	#4,R0
	.IFT
	MOV	R0,LX$VTB+6
	.IFF
	MOV	R0,LS$VTB+6
	.ENDC
	CMP	R3,R0
	RETURN
	.ENDC
.ASSUME	. LT 400 MESSAGE=<;Installation code too large>
	.SBTTL	SET OPTION PARAMETER TABLE
.DRSET	BIT8 	O.BIT8/2		GETOVR	NO
.DRSET	CR 	O.CR/2			GETOVR	NO
	.IF NE LS$PDP
.DRSET	CSR 	O.CSR/2			GETOVR	OCT
	.ENDC
.DRSET	CTRL 	O.CTRL/2		GETOVR	NO
.DRSET	ENDPAG 	O.ENDP/2		GETOVR	NUM
.DRSET	FORM 	O.FF/2			GETOVR	NO
.DRSET	FORM0 	O.FORM0/2		GETOVR	NO
.DRSET	GRAPH	O.GRAP/2		GETOVR	NO
	.IF NE LS$HANG
.DRSET	HANG 	O.HANG/2		GETOVR	NO
	.ENDC
.DRSET	LC 	O.LC/2			GETOVR	NO
.DRSET	LENGTH 	O.LENG/2		GETOVR	NUM
.DRSET	SKIP 	O.SKIP/2		GETOVR	NUM
	.IF NE LS$PC
.DRSET	SPEED 	-1 			O.SPEE 	NUM
	.ENDC
.DRSET	TAB	O.TAB/2			GETOVR	NO
	.IF NE LS$PDP
.DRSET	VECTOR 	477 			O.VEC 	OCT
	.ENDC
.DRSET	WIDTH 	O.WIDTH/2		GETOVR	NUM
	.SBTTL	SET OPTION PROCESSING ROUTINES
	.ENABL	LSB
	.IF NE LS$PDP
O.VEC:	BR	I.VEC
	.ENDC
	.IF NE LS$PC
O.SPEE:	BR	I.SPEE
SPEEDT:	.WORD	50.,	75.,	110.,	134.,	150.,	300.
	.WORD	600.,	1200.,	1800.,	2000.,	2400.,	3600.
	.WORD	4800.,	7200.,	9600.,	19200.
	.WORD	0
	.ENDC
	.SBTTL	GETOVR - Get Overlay SET code routine from disk
	.ENABL	LSB
.Assume . LE 656,MESSAGE=<;Overlay read routine overlaps set code>
	.=656
	VALWCT =: ./2
	OVRSIZ =: .
	.SBTTL	GETBK0	- Read block zero - resident routine
GETBK0:	MOV	#SET.EX/2,R3
	.BR	GETOVR
GETOVR::
	CMPB	-(R3),-(R3)
	NOP
					.Assume . EQ GETOVR+4
	CMPB	(R3)+,(R3)+
	MOV	R0,-(SP)
	SWAB	R3
	MOVB	R3,REABLK
	BIC	#377,R3
					.Assume	BLOCK0 EQ 0
	JSR	R0,10$
REAFUN:	 .BYTE	17,10
REABLK:	 .BLKW	1
REABUF:	 .BLKW	1
	 .WORD	VALWCT
	 .WORD	0
10$:	.ADDR	#BLOCK0,R5,PUSH
	MOV	R5,REABUF
	MOV	(SP)+,R5
	EMT	375
	MOV	(SP)+,R0
	BCS	SET.NOR
	SWAB	R3
	ASL	R3
	ADD	REABUF,R3
	MOV	(SP)+,R0
	JMP	@R3
	.DSABL	LSB
SET.EX: TST	R2
	BEQ	SET.NOR
	DEC	R2
	BEQ	SET.ERR
	ADD	#2,(SP)
SET.ERR:SEC
SET.NOR:RETURN
	.DSABL	LSB
.Assume	. LE 1000,MESSAGE=<;Set code overflow>
	.SBTTL	DRIVER ENTRY
	.ENABL	LSB
	.DRBEG	LS
LSBASE	=:LSSTRT+6
	MOV	LSCQE,R4
	MOVB	Q$FUNC(R4),R5
	BNE	FILREQ
	ASL	Q$WCNT(R4)
	BEQ	LSDON1
	BCC	LSERR
	MOV	SP,DIDIO
	.IF NE LSBOTH
PDPA1:
	.ENDC
	.IF NE LS$PDP
	BIS	#RC.IE,@RCSR
	.ENDC
	.IF NE LSBOTH
PDPZ1	=:.-PDPA1
	.SAVE
	.PSECT	PC$PDP
PCA1:
	.ENDC
	.IF NE	LS$PC
	MOVB	#<C.CSM!RC.ID>,@#IC0CR
	.ENDC
	.IF NE LSBOTH
PCZ1	=:.-PCA1
	.RESTORE
					.Assume PDPZ1 EQ PCZ1
	.ENDC
DOINT:
	.IF NE LSBOTH
PDPA2:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
PDPZ2	=:.-PDPA2
	.SAVE
	.PSECT	PC$PDP
PCA2:
	.ENDC
	.IF NE LS$PC
	MOVB	#<C.SSM!XC.ID>,@#IC0CR
	MOVB	#<C.SSI!XC.ID>,@#IC0CR
	.ENDC
	.IF NE LSBOTH
PCZ2	=:.-PCA2
	.RESTORE
					.Assume PDPZ2 EQ PCZ2
	.ENDC
	TST	STALLF
	.IF EQ LS$HANG
	BEQ	20$
	.IFF
	BEQ	O$HANG
ENAOU1:	CALLR	ENAOUI
	.IFT
ENAOU1:	CALL	ENAOUI
20$:	RETURN
	.ENDC
FILREQ:
	BMI	LSDONE
	CLR	Q$WCNT(R4)
	CMPB	#ENTE..,R5
	BEQ	24$
	CMPB	#CLOS..,R5
	BEQ	DOINT
	CMPB	#LOOK..,R5
	BNE	25$
24$:
	CLR	DIDIO
25$:
LSDON1:	BR	LSDONE
	.DSABL	LSB
	.SBTTL	REGISTERS AND VECTOR TABLES
	.IF NE LS$PDP
RCSR:	.WORD	LS$CSR
RBUF:	.WORD	LS$CSR+2
XCSR:	.WORD	LS$CSR+4
XBUF:	.WORD	LS$CSR+6
	.ENDC
	.IF NE LSBOTH
	.DRVTB	LS,LS$VCX,LIINT
	.DRVTB	,LS$VCX+4,LSINT
	.DRVTB	LX,LS$VEC,LIINT
	.IFF
	.DRVTB	LS,LS$VEC,LIINT
	.ENDC
	.DRVTB	,LS$VEC+4,LSINT
	.SBTTL	INPUT INTERRUPT SERVICE
	.ENABL	LSB
	.DRAST	LI,LS$PRI,LSABT
	TST	LSCQE
	BEQ	30$
	.IF NE LSBOTH
PDPA3:
	.ENDC
	.IF NE LS$PDP
	MOVB	@RBUF,R4
	.ENDC
	.IF NE LSBOTH
PDPZ3	=:.-PDPA3
	.SAVE
	.PSECT	PC$PDP
PCA3:
	.ENDC
	.IF NE LS$PC
	MOVB	@#LS$BUF,R4
	.ENDC
	.IF NE LSBOTH
PCZ3	=:.-PCA3
	.RESTORE
					.Assume PDPZ3 EQ PCZ3
	.ENDC
	BIC	#^C<177>,R4
	CMPB	R4,#CTRLQ
	BNE	20$
	.IF NE LS$HANG
	CALL	CTIMER
	.ENDC
	MOV	SP,STALLF
	BR	ENAOU1
20$:	CMPB	R4,#CTRLS
	BNE	30$
	CALL	DISOUI
	CLR	STALLF
	.IF NE LS$HANG
O$HANG:	BR	EXIT
.Assume .-LSSTRT LE 1000,MESSAGE=<;Code to set not in block 1>
	TST	TCOMPL
	BNE	30$
	MOV	LSCQE,R4
	MOVB	Q$JNUM(R4),R4
	ASR	R4
	ASR	R4
	ASR	R4
	BIC	#^C<16>,R4
	MOV	R4,TJOBNM
	.ADDR	#OFFLIN,R4
	MOV	R4,TCOMPL
	.FORK	LIFBLK
	.TIMIO	TBLOCK,0,60.*5
	.ENDC
EXIT:
30$:	RETURN
	.DSABL	LSB
	.SBTTL	OPERATION COMPLETE
	.ENABL	LSB
LSABT:
	.IF NE LS$HANG
	CALL	LSCLR
	CALL	CTIMER
	.ENDC
	MOV	SP,STALLF
	BR	LSDONE
LSERR:	BIS	#HDERR$,@-(R4)
LSDONE:	CALL	LSCLR
	.DRFIN	LS
LSCLR:	CLR	LIFBLK+F.BADR
	CALL	DISOUI
	.IF NE LSBOTH
PDPA4:
	.ENDC
	.IF NE LS$PDP
	BIC	#RC.IE,@RCSR
	.ENDC
	.IF NE LSBOTH
PDPZ4	=:.-PDPA4
	.SAVE
	.PSECT	PC$PDP
PCA4:
	.ENDC
	.IF NE LS$PC
10$:	MOVB	#<C.SSM!RC.ID>,@#IC0CR
	.ENDC
	.IF NE LSBOTH
PCZ4	=:.-PCA4
	.RESTORE
					.Assume PDPZ4 EQ PCZ4
	.ENDC
	RETURN
	.DSABL	LSB
	.SBTTL	OUTPUT INTERRUPT SERVICE
	.ENABL	LSB
	.DRAST	LS,LS$PRI,LSABT
	CALL	DISOUI
	MOV	LSCQE,R4
	BEQ	20$
	CMPB	#CLOS..,Q$FUNC(R4)
	BNE	17$
 DIDIO	=:.+2
	TST	#.-.
	BEQ	LSDONE
O$ENDP=:.+2
	MOV	#0,Q$WCNT(R4)
.Assume .-LSSTRT LE 1000,MESSAGE=<;Code to set not in block 1>
	BEQ	LSDONE
	MOVB	#<100!CLOS..>,Q$FUNC(R4)
17$:
	CMPB	#<100!CLOS..>,Q$FUNC(R4)
	BEQ	19$
	TST	@R4
O$FORM:	BEQ	BLK0
.Assume .-LSSTRT LE 1000,MESSAGE=<;Code to set not in block 1>
	TST	STALLF
	BEQ	20$
	ASLB	(PC)+
TABFLG:	 .WORD	0
	BNE	TAB
19$:
	MOV	(PC)+,R5
FFFLAG:	 .WORD	0
	BNE	DOFORM
	CMPB	#<100!CLOS..>,Q$FUNC(R4)
	BNE	18$
	DEC	Q$WCNT(R4)
	BGE	BLKZ
	BR	LSDONE
18$:
IGNORE:	TST	Q$WCNT(R4)
	BEQ	LSDONE
	.IF EQ MMG$T
	MOVB	@Q$BUFF(R4),R5
	INC	Q$BUFF(R4)
	.IFF
	CALL	@$GTBYT
	MOV	(SP)+,R5
	.ENDC
	INC	Q$WCNT(R4)
O$BIT8=:.+2
	BIC	#^C<177>,R5
.Assume .-LSSTRT LE 1000,MESSAGE=<;Code to set not in block 1>
	BEQ	IGNORE
	ASRB	(PC)+
SKPFLG:	 .WORD	0
	BCC	10$
	CMPB	R5,#FF
	BEQ	IGNORE
10$:	CMPB	R5,#SPACE
	BLO	CHRTST
	CMPB	R5,#'A!40
	BLO	PCHAR
	CMPB	R5,#'Z!40
	BHI	PCHAR
	BIC	(PC)+,R5
O$LC:	 .WORD	0
.Assume .-LSSTRT LE 1000,MESSAGE=<;Code to set not in block 1>
PCHAR:	DEC	COLCNT
O$GRAP:	BLT	IGNORE
.Assume .-LSSTRT LE 1000,MESSAGE=<;Code to set not in block 1>
	ASLB	(PC)+
TABCNT:	 .WORD	1
	BEQ	RSTTAB
PRINTC:
	.IF NE LSBOTH
PDPA5:
	.ENDC
	.IF NE LS$PDP
	MOVB	R5,@XBUF
	.ENDC
	.IF NE LSBOTH
PDPZ5	=:.-PDPA5
	.SAVE
	.PSECT	PC$PDP
PCA5:
	.ENDC
	.IF NE LS$PC
	MOVB	R5,@#LS$BUF
	.ENDC
	.IF NE LSBOTH
PCZ5	=:.-PCA5
	.RESTORE
					.Assume PDPZ5 EQ PCZ5
	.ENDC
	CALL	ENAOUI
20$:	RETURN
CHRTST:	CMPB	R5,#HT
O$TAB:	BEQ	TABSET
	CMPB	R5,#FF
	BEQ	SENDFF
	CMPB	R5,#CR
O$CR:	BEQ	RSTC
	CMPB	R5,#LF
O$CTRL:	BNE	PRINTC
	CMP	LINCTR,(PC)+
O$SKIP:	 .WORD	0
	BLE	SKIPFF
DOFORM:	DEC	LINCTR
	BGT	RSTC
	.IF EQ <.-LSSTRT>&777-774
	NOP
	.ENDC
NEWPAG:	MOV	(PC)+,(PC)+
O$LENG:	 .WORD	LS.PSZ
LINCTR:	 .WORD	LS.PSZ
	CLR	FFFLAG
	.IF EQ <.-LSSTRT>&777-774
	NOP
	.ENDC
RSTC:	MOV	(PC)+,(PC)+
O$WIDT:	 .WORD	LS.CSZ
COLCNT:	 .WORD	LS.CSZ
	CLR	TABFLG
RSTTAB:	MOV	#1,TABCNT
	BR	PRINTC
BLKZ:
BLK0:	INC	@R4
SENDFF:	MOV	#CR,R5
	O$FF = .+2
	MOV	#FF,FFFLAG
	BMI	RSTC
	CLR	LINCTR
	BR	RSTC
TABSET:	MOV	TABCNT,TABFLG
TAB:	MOV	#SPACE,R5
	BR	PCHAR
HDWTAB:	ASLB	TABCNT
	BEQ	RSTTAB
	DEC	COLCNT
	BR	HDWTAB
SKIPFF:	INC	SKPFLG
	BR	SENDFF
	.DSABL	LSB
	.IF NE LS$HANG
	.SBTTL	TIMER SUPPORT ROUTINES
CTIMER:	TST	TCOMPL
	BEQ	10$
	.FORK	LIFBLK
	.CTIMIO	TBLOCK
	CLR	TCOMPL
10$:	RETURN
OFFLIN: MOV	@SP,-(SP)
	 .IF EQ MMG$T
	CLR	2(SP)
	 .IFF
	MOV	@#PSW,2(SP)
	 .ENDC
	.MTPS	#340
	.INTEN	0,PIC
	CLR	TCOMPL
	MOV	LSCQE,R4
	JMP	LSERR
	.ENDC
	.SBTTL	INTERRUPT ENABLE ROUTINES
ENAOUI:
	.IF NE LSBOTH
PDPA6:
	.ENDC
	.IF NE LS$PDP
	BIS	#XC.IE,@XCSR
	.ENDC
	.IF NE LSBOTH
PDPZ6	=:.-PDPA6
	.SAVE
	.PSECT	PC$PDP
PCA6:
	.ENDC
	.IF NE LS$PC
10$:	MOVB	#<C.CSM!XC.ID>,@#IC0CR
	.ENDC
	.IF NE LSBOTH
PCZ6	=:.-PCA6
	.RESTORE
					.Assume PDPZ6 EQ PCZ6
	.ENDC
	RETURN
DISOUI:
	.IF NE LSBOTH
PDPA7:
	.ENDC
	.IF NE LS$PDP
	BIC	#XC.IE,@XCSR
	.ENDC
	.IF NE LSBOTH
PDPZ7	=:.-PDPA7
	.SAVE
	.PSECT	PC$PDP
PCA7:
	.ENDC
	.IF NE LS$PC
10$:	MOVB	#<C.SSM!XC.ID>,@#IC0CR
	.ENDC
	.IF NE LSBOTH
PCZ7	=:.-PCA7
	.RESTORE
					.Assume PDPZ7 EQ PCZ7
	.ENDC
	RETURN
	.SBTTL	IMPURE DATA AREAS
STALLF:	.WORD	1
	.IF NE LS$HANG
TBLOCK:	.WORD	0,0,0
TJOBNM:	.WORD	0
	.WORD	177000+LS$CODE
	.WORD	-1
TCOMPL:	.WORD	0
	.ENDC
LIFBLK:	.WORD	0,0,0,0
	.DREND	LS
	.SBTTL	OVRBK0	-- overlay block number zero
	.PSECT	SETOVR
OVRBK0:
BIAS	==	<OVRBK0-REF0>
O.TAB:	BR	20$
	NOP
	MOV	(PC)+,R3
	 BEQ	TABSET-O$TAB+.
	BR	30$
20$:	MOV	(PC)+,R3
	 BEQ	HDWTAB-O$TAB+.
30$:
	MOV	R3,-(SP)
	MOV	#<O$TAB/1000>,R3
	CALL	CORWRT
	MOV	(SP)+,R3
	BCS	S.IGN1
	MOV	R3,<O$TAB&777>(R2)
	BR	CORXI1
O.CR:	BR	20$
	NOP
	MOV	(PC)+,R3
	 NOP
	BR	30$
20$:	MOV	(PC)+,R3
	 BEQ	RSTC-O$CR+.
30$:
	MOV	R3,-(SP)
	MOV	#<O$CR/1000>,R3
	CALL	CORWRT
	MOV	(SP)+,R3
S.IGN1:	BCS	S.IGN
	MOV	R3,<O$CR&777>(R2)
CORXI1:	BR	CORXIT
O.SKIP:	CMP	#255.,R0
	BLO	S.ERR
	TST	R0
	BEQ	10$
	INC	R0
10$:	MOV	#<O$SKIP/1000>,R3
	MOV	R0,-(SP)
	CALL	CORWRT
	MOV	(SP)+,R0
	BCS	S.IGN
	MOV	R0,<O$SKIP&777>(R2)
	BR	CORXIT
O.LENG:	TST	R0
	BLE	S.ERR
	MOV	#<O$LENG/1000>,R3
	MOV	R0,-(SP)
	CALL	CORWRT
	MOV	(SP)+,R0
	BCS	S.IGN
	MOV	R0,<O$LENG&777>(R2)
	MOV	R0,<LINCTR&777>(R2)
	BR	CORXIT
O.WIDT:	CMP	R0,#30.
	BLT	S.ERR
	MOV	#<O$WIDT/1000>,R3
	MOV	R0,-(SP)
	CALL	CORWRT
	MOV	(SP)+,R0
	BCS	S.IGN
	MOV	R0,<O$WIDT&777>(R2)
	MOV	R0,<COLCNT&777>(R2)
	BR	CORXIT
O.CTRL:	BR	20$
	NOP
	MOV	(PC)+,R3
	 BNE	IGNORE-O$CTRL+.
	BR	30$
20$:	MOV	(PC)+,R3
	 BNE	PRINTC-O$CTRL+.
30$:
	MOV	R3,-(SP)
	MOV	#<O$CTRL/1000>,R3
	CALL	CORWRT
	MOV	(SP)+,R3
	BCS	S.IGN
	MOV	R3,<O$CTRL&777>(R2)
	BR	CORXIT
	.IF NE LS$PDP
O.CSR:	CMP	R0,#160000
	BLO	S.ERR
	CLR	R3
	MOV	R0,-(SP)
	CALL	CORWRT
	MOV	(SP)+,R0
	BCS	S.IGN
	MOV	R0,<H.DCSR&777>(R2)
	MOV	R0,-(SP)
	CALL	CORREA
	MOV	(SP)+,R0
	BCS	S.IGN
	.ADDR	#RCSR+BIAS,R1
	MOV	#4,R2
 10$:
					.Assume RCSR+2 EQ RBUF
					.Assume RBUF+2 EQ XCSR
					.Assume XCSR+2 EQ XBUF
	 MOV	R0,(R1)+
	 ADD	#2,R0
	 SOB	R2,10$
	BR	S.NOR
	.ENDC
O.FF:	BR	20$
	NOP
	MOV	#<100000!LF>,R3
	BR	30$
20$:	MOV	#FF,R3
30$:
	MOV	R3,-(SP)
	MOV	#<O$FF/1000>,R3
	CALL	CORWRT
	MOV	(SP)+,R3
	BCS	S.IGN
	MOV	R3,<O$FF&777>(R2)
CORXIT:	CALL	CORREA
	BCS	S.IGN
	.BR	S.NOR
	.SBTTL	ADIOS - Common exit point for overlayed code
S.NOR:	CLR	R2
S.IGN:	CMP	(PC)+,(PC)+
S.ERR:	MOV	#1,R2
	JMP	GETBK0+BIAS
	.SBTTL	CORE - Sub/Coroutine for core reads/writes
BAREA:	.BYTE	17,11
	.BLKW
	.BLKW
	.WORD	256.
	.WORD	0
CORWRT:	.ADDR	#BAREA+4,R1
	.ADDR	#1000+BIAS,R2
	MOV	R2,(R1)
	MOV	#1,-(R1)
	TST	-(R1)
	MOV	R1,R0
	EMT	375
	BCS	C2.ERR
	MOV	R1,R0
	DECB	1(R0)
	MOV	R3,2(R0)
	EMT	375
	BCS	C.ERR
	BR	C.NOR
CORREA:	MOV	R1,R0
	INCB	1(R0)
	EMT	375
	BCS	C2.ERR
	MOV	R1,R0
	DECB	1(R0)
	MOV	#1,2(R0)
	EMT	375
	BCS	C.ERR
	INCB	1(R1)
	BR	C.NOR
C2.ERR:	MOV	#2,R2
	BR	C.NOR
C.ERR:	MOV	#1,R2
C.NOR:
	RETURN
.ASSUME <.-OVRBK0> LE OVRSIZ,MESSAGE=<;Overlay overflow>
OVRSZ0==.-OVRBK0
OVRSP0==OVRSIZ-OVRSZ0
	.SBTTL	OVRBK1	-- overlay block number one
	. = OVRBK0+1000
OVRBK1:
	BIAS	== <OVRBK1-REF0>
O.ENDP:	.ADDR	#O$ENDP+BIAS,R1
	MOV	R0,@R1
	BR	S.1NOR
O.BIT8:	BR	20$
	NOP
	MOV	#^c177,R3
	BR	30$
20$:	MOV	#^c377,R3
30$:	.ADDR	#O$BIT8+BIAS,R1
	BR	MOV3A1
O.FORM0:BR	20$
	NOP
	MOV	(PC)+,R3
	 NOP
	BR	30$
20$:	MOV	(PC)+,R3
	 BEQ	BLK0-O$FORM+.
30$:	.ADDR	#O$FORM+BIAS,R1
	BR	MOV3A1
O.LC:	CLR	R3
	BR	20$
	MOV	#40,R3
20$:	.ADDR	#O$LC+BIAS,R1
	BR	MOV3A1
O.GRAP:	BR	20$
	NOP
	MOV	(PC)+,R3
	 BLT	IGNORE-O$GRAP+.
	BR	30$
20$:	MOV	(PC)+,R3
	 NOP
30$:	.ADDR	#O$GRAP+BIAS,R1
	.IF NE LS$HANG
	BR	MOV3A1
O.HANG:	BR	20$
	NOP
	MOV	(PC)+,R3
	 NOP
	BR	30$
20$:	MOV	(PC)+,R3
	 BR	EXIT-O$HANG+.
30$:	.ADDR	#O$HANG+BIAS,R1
	.ENDC
MOV3A1:
	MOV	R3,@R1
	BR	S.1NOR
	.SBTTL	ADIOS - Common exit point for overlayed code
S.1NOR:	CLR	R2
S.1IGN:	CMP	(PC)+,(PC)+
S.1ERR:	MOV	#1,R2
	JMP	GETBK0+BIAS
.ASSUME <.-OVRBK1> LE OVRSIZ,MESSAGE=<;Overlay overflow>
OVRSZ1==.-OVRBK1
OVRSP1==OVRSIZ-OVRSZ1
	.IF NE LSBOTH
	.SBTTL	FETCH/LOAD CODE
	.ENABL	LSB
FETCH::
	MOV	@R5,R5
	MOV	@#SYSPTR,R0
	BIT	#PRO$,CONFG2(R0)
	BEQ	30$
	PCMSK	=: 360/<<15.*<PC.VEC-<20*<PC.VEC/20>>>/8.>+1>
	PCLOC	=: 326+<PC.VEC/20>
	BISB	#PCMSK,PCLOC(R0)
	MOV	LS$VTB-LSBASE(R5),R1
	MOV	#PC.VEC,R2
	CALL	VECMOV
	.ADDR	#PCBASE,R1
	.ADDR	#REPL,R4
 10$:
	 MOV	(R4)+,R0
	 BEQ	40$
	 MOV	R5,R2
	 ADD	(R4)+,R2
	 CALL	DATMOV
	 BR	10$
30$:
	MOV	LX$VTB-LSBASE(R5),R2
	MOV	R0,-(SP)
	MOV	R2,-(SP)
	ADD	#LOWMAP,R0
	MOV	#2,R4
	CALL	PROTECT
	MOV	(SP)+,R2
	MOV	(SP)+,R0
	MOV	#LS$VCX,R1
	CALL	VECMOV
	LXMSK	=: 360/<<15.*<LS$VCX-<20*<LS$VCX/20>>>/8.>+1>
	LXLOC	=: 326+<LS$VCX/20>
	BICB	#LXMSK,LXLOC(R0)
	MOV	LX$VTB-LSBASE(R5),LS$VTB-LSBASE(R5)
	MOV	LX$VTB+6-LSBASE(R5),LS$VTB+6-LSBASE(R5)
40$:
	CLC
	RETURN
VECMOV:
	MOV	#4,R0
DATMOV:
 50$:	 MOV	(R1)+,(R2)+
	 SOB	R0,50$
	RETURN
PROTECT:
	ASR	R2
	MOV	R2,R1
	BIC	#177407,R2
	BIC	#177770,R1
	ASR	R2
	ASR	R2
	ASR	R2
	ADD	R0,R2
 60$:	 CLR	R0
	 SEC
  70$:	  RORB	R0
	  DEC	R1
	  BPL	70$
  80$:	  BISB	R0,@R2
	  DEC	R4
	  BMI	90$
	  RORB	R0
	  BCC	80$
	 INC	R2
	 BR	60$
90$:
	RETURN
REPL:
	.IRPC	x,<1234567>
	.WORD	PDPZ'x/2,PDPA'x-LSBASE
	.ENDR
	.WORD	1,LS$VTB-LSBASE
	.WORD	1,LS$VTB+6-LSBASE
	.WORD	0
.ASSUME <.-OVRBK1> LE 2000,MESSAGE=<;FETCH/LOAD code overflow>
	.PSECT	PC$PDP
	.WORD	PC.VEC
	.WORD	PC.VEC+4
	.ENDC
	.END
                                                                                                                                                                                                                                 