.MCALL	.MODULE
.MODULE	LD,VERSION=19,COMMENT=<Logical disk handler>

;                     	COPYRIGHT (c) 1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
	.SbTtl	Conditional assembly summary
.NList	BEX,CND
.IIf	NDF	RTE$M	RTE$M=0
.IIf	NDF	MMg$t	MMg$t=0
.IIf	NDF	SJOnly	SJOnly=0
.IIf	NE	SJOnly	SJOnly=1
.IIf	NDF	LD$Own	LD$Own=1
.IIf	NE	LD$Own	LD$Own=1
.IIf	NE	SJOnly	LD$Own=0
.IIf	NDF	EIS$I	EIS$I=RTE$M!MMg$t
.IIf	NE	SJOnly*MMg$t	.Error
.IIf	NE	SJOnly*RTE$M	.Error
.IIf	NE	MMg$t*RTE$M	.Error
.IIf	NE	SJOnly		.Error
.IIf	NDF	Def$LD	Def$LD=:^rDSK
.LDGen	=:	<2*MMg$t>!<10*RTE$M>!<400*EIS$I>!<1000*SJOnly>!<2000*LD$Own>
.Audit .LD .LDGen Def$LD
.SbTtl
.If	NE	MMg$t
.SbTtl	*** Supports XM
.SbTtl	LDX is handler name
.IfF
 .If	EQ	SJOnly
  .If	EQ	RTE$M
.SbTtl	*** Supports FB
.SbTtl	*** Supports SJ
.SbTtl	LD is handler name
  .IfF
.SbTtl	*** Supports RTEM
.SbTtl	LDM is handler name
  .EndC;EQ	RTE$M
 .IfF
.SbTtl	*** Supports SJ
.SbTtl	LD is handler name
 .EndC
.EndC
.If	EQ	LD$Own
.SbTtl	Device ownership is NOT checked
.IfF
.SbTtl	Device ownership IS checked
.EndC
.SbTtl
.SbTtl	Macros and Definitions
.MCall	.DrDef
.MCall	.CsiSpc	.Print	.Exit	.Purge
.MCall	.LookUp	.DStat	.FProt	.Fetch
.MCall	.Enter	.SpFun	.WritW	.CStat
.MCall	.Release .SErr	.Chain	.SetTop
.MCall	.SReset	.Assume	.Br	...CmZ
.MCall	.Addr
.IIf EQ EIS$I	.MCall	SOB
.SbTtl	Global References to ULBLIB
.Globl	$CBOMg
.Globl	$FnAsc
.Globl	$R50Asc
LD.Cnt	=	0
RM.Cnt	=	0
.Macro	$Rel	Loc	Value	Base
...V2	=	.
.	=	Loc
.If	IDN	<LD>	<Base>
Ld.Cnt	=	Ld.Cnt+1
.Irp	...V3	<\Ld.Cnt>
LD.'...V3:	.Word	Value-LdBase
.EndR
.	=	...V2
.MExit
.EndC
.If	IDN	<RMON>	<Base>
RM.Cnt	=	RM.Cnt+1
.Irp	...V3	<\RM.Cnt>
RM.'...V3:	.Word	Value
.EndR
.	=	...V2
.MExit
.EndC
	.Error
.EndM	$Rel
.Macro	Boff	Dst
	Beq	Dst
.EndM	Boff
.Macro	Bon	Dst
	Bne	Dst
.EndM	Bon
.Macro	......
.EndM	......
.SbTtl	Equates
PR7	=:	7*40
JSP	=:	42
JSW	=:	44
	SpXit$	=:	40
	Chain$	=:	400
	Ovly$	=:	1000
	ChnIF$	=:	4000
	RStrt$	=:	20000
JUsErB	=:	53
	Succs$	=:	1
	Warn$	=:	2
	Error$	=:	4
	Fatal$	=:	10
	Uncon$	=:	20
JRMon	=:	54
InsCsr	=:	176
InsCk	=:	200
CmdLen	=:	510
CmdStr	=:	512
ChnTo	=:	500
PPN	=:	510
ChnFrm	=:	512
ChnArg	=:	522
	ChnNon	=:	377
	ChnRtn	=:	177
ChnErr	=:	523
ChnUEB	=:	524
ChnMsg	=:	525
	Indx$M	=:	76
SyUnit	=:	275
SysVer	=:	276
ConFg1	=:	300
	FBMon$	=:	000001
$MTPS	=:	360
$MFPS	=:	362
SyIndx	=:	364
ConFg2	=:	370
	LDRel$	=:	000020
SysGen	=:	372
	XMMon$	=:	000002
	RTEM$	=:	000010
$PName	=:	404
	EntEnd	=:	177777
Suffix	=:	412
	OwnMsk	=:	17
Upd$Fn	=:	372
Siz$Fn	=:	373
.SbTtl	Define handler characteristics
.DrDef	LD, 46, FilSt$!SpFun$!VarSz$, 0, 0, 0
.DrPtr	FETCH=INIT,LOAD=INIT
.DrESt	CLASS=DVC.DK,DATA=LDData,TYPE=LD
.DRSpF	<Upd$Fn>
.DRSpF	<Siz$Fn>
	.Asect
	.=:JSW
	.Word	Ovly$
.SbTtl	Installation check code
	.DrIns	LD
	Br	10$
	...........
					.Assume	. EQ InsSys
	Br	InErr
	.............
10$:
	Mov	@#JRmon, R0
	CmpB	SysVer(R0),#5
	Blo	InErr
.If	NE	SJOnly
	Bit	#FBMon$,ConFg1(R0)
	Bon	InErr
.EndC
	Bit	#RTEM$,SysGen(R0)
.If	NE	RTE$M
	Boff	InErr
.IfF
	Bon	InErr
.EndC
	Bit	#XMMon$,SysGen(R0)
.If	NE	MMG$T
	Boff	InErr
.IfF
	Bon	InErr
.EndC
	Tst	(PC)+
InErr:
	Sec
	Return
	......
.Enable	LSB
DoChain:
	Mov	@#JRMON,R0
	Add	SUFFIX(R0),RNAME
	Jsr	R1,35$
	.Rad50	"SY "
RName:
	.RMODULE
	.Rad50	"   SYS"
	.Word	0
	.Word	0,0,0,0
	.Word	-1
35$:
	Mov	#ChnTo,R0
 37$:
	 Mov	@R1,(R0)+
	 Cmp	#-1,(R1)+
	 Bne	37$
	Tst	-(R0)
 40$:
	 Mov	@R3,(R0)+
	 Cmp	#-1,(R3)+
	 Bne	40$
	.Chain
	......
.Dsabl	LSB
.Assume . LE 400
.SbTtl	Set Code
.Enable	LSB
.DrSet	CLEAN	'C	SetCle
.DrSet	EMPTY	-1	SetMty
.DrSet	WRITE	'R	SetWri	NO
.DrSet	BPT	NOP	SetBPT	<NO,NUM>
SetBPT:
	Mov	#BPT,R3
	.Br	SetNoB
SetNoB:
					.Assume SetBPT+4 EQ SetNoB
	Cmp	#BPTLen/2,R0
	Blos	SetErr
	Asl	R0
	Jsr	R1,10$
BPTTab:
	.Word	DBGSet-TabBas
	.Word	DBGQue-TabBas
	.Word	DBGRun-TabBas
BPTLen	=:	.-BPTTab
10$:
	Add	R1,R0
	Mov	@R0,R0
	Add	PC,R0
TabBas=:.
	Mov	R3,@R0
	Mov	(SP)+,R1
	Br	SetOk
	.............
SetWri:
	Mov	#'W,R3
	.Br	SetNoW
SetNoW:
	Call	DBGSet
					.Assume	SetWri+4 EQ SetNoW
	.Br	SetCle
SetCle:
	Call	DBGSet
	TstB	-1(R5)
	Bne	Not1Op
	MovB	R3,Letter
	Bis	#'0,R1
	MovB	R1,Number
	Jsr	R3,DoChain
	..............
					.Assume . EQ 20$
20$:
	.Ascii	"/"
Letter:	.BlkB	1
	.Ascii	":"
Number:	.BlkB	1
	.Asciz	""
	.Even
	.Word	-1
SetMty:
	Call	DBGSet
	TstB	-1(R5)
	Bne	Not1Op
	Jsr	R3,DoChain
	.IrpC	x,<01234567>
	.Ascii	"/L:x"
	.EndR
	.Asciz	""
	.Even
	.Word	-1
.Enable LSB
Not1Op:
	Jsr	R0,SetMsg
	.................
	.Ascii	"?"
	.NLCsi	TYPE=I,PART=NAME
	.Asciz	"-F-Only 1 option per SET allowed"
	.Even
SetMsg:
 10$:
	 TstB	-(R5)
	 TstB	-1(R5)
	 Bne	10$
	.Print
	Cmp	(SP)+,(SP)+
	.Br	SetOk
SetOk:
	Tst	(PC)+
SetErr:
	Sec
	Return
	......
DBGSet:
	BPT
.=:DBGSet;******************************;5
	NOP
	Return
	......
.Assume . LE 1000
LDHand	=:	1000
.SbTtl	Queue Manager code
.Enable	LSB
.DrBeg	LD
LdBase	=:LDSTRT+6
	Br	Cont
.SbTtl	Data Area
LdData::
Units	=:	8.
UntMsk	=:	Units-1
					.Assume	Units EQ 8.
BufLow:
	.RAD50	"LD"
Handlr:
	.BlkW	Units
	Hd.Act	=:	100000
	Hd.RdO	=:	020000
	Hd.Unt	=:	003400
	Hd.UOf	=:	000200
	Hd.UNx	=:	000100
	Hd.Ndx	=:	000076
Offset:	.BlkW	Units
Size:	.BlkW	Units
Name:	.BlkW	Units*4
BufHi:
Cont:
...1st:	Mov	LdCQE,R4
DBGQue:	BPT
.=:DBGQue;******************************;3
	NOP
	Mov	#Handlr,R5
$Rel	.-2	Handlr	LD
	MovB	Q$Unit(R4),R2
	Bic	#^cUntMsk,R2
	Asl	R2
	MovB	Q$Func(R4),R1
	Bpl	RelCk
	CmpB	#Upd$Fn,R1
	Bne	60$
.If	EQ	MMG$T
	Mov	Q$Buff(R4),R2
	Tst	Q$WCnt(R4)
	Bpl	10$
	Tst	-(R5)
	Mov	R5,R1
	Mov	R2,R5
	Mov	R1,R2
10$:
	Mov	#BufHi-BufLow/2,R1
 20$:
	 Mov	(R2)+,(R5)+
	 Sob	R1,20$
	Br	LdDon1
	..............
.IfF
	Tst	-(R5)
	Mov	#BufHi-BufLow,R1
	Tst	Q$WCnt(R4)
	Bpl	40$
 30$:
	 MovB	(R5)+,-(SP)
	 Call	@$PtByt
	 Sob	R1,30$
	Br	LdDon1
	..............
40$:
 50$:
	 Call	@$GtByt
	 MovB	(SP)+,(R5)+
	 Sob	R1,50$
	Br	LdDon1
	..............
.EndC
DBGRun:
	BPT
.=:DBGRun;******************************;5
	NOP
.Assume . LE LDStrt+776
	Return
	......
60$:
	CmpB	#Siz$Fn,R1
	Bne	LdDon1
					.Assume	Hd.Act EQ 100000
	Tst	Handlr(R2)
$Rel	.-2	Handlr	LD
	Bpl	LdEr1
.If EQ	Mmg$t
	Mov	Size(R2),@Q$Buff(R4)
$Rel	.-4	Size	LD
.IfF
	Mov	Size(R2),-(SP)
$Rel	.-2	Size	LD
	Call	@$PtWrd
.EndC
LdDon1:
	Jmp	LdDone
	..............
.SbTtl	Check the .Release/$UNLOAD bit
.Enable	LSB
RelCk:
	Bit	#LDRel$,@#ConFg2
$Rel	.-2	ConFg2	RMON
.CnFg2=:.-2
	Boff	20$
	Bic	#LDRel$,@.CnFg2
	Mov	#Units,R1
	Add	R1,R5
	Add	R1,R5
 10$:
	 Bis	#Hd.Unx,-(R5)
	 Sob	R1,10$
	.Br	20$
.SbTtl	Check for valid info about LDn: unit n
20$:
	Add	R2,R5
					.Assume	Hd.Act EQ 100000
	Tst	@R5
LdEr1:
	Bpl	LdErr
	BitB	#Hd.UNx!Hd.UOf,@R5
	Boff	LimCk
					.Assume	Hd.UNx NE 200
					.Assume	Hd.UOf EQ 200
	Bmi	LdErr
	Mov	R2,R1
	Asl	R1
	Asl	R1
	Mov	R2,-(SP)
	Mov	Name(R1),-(SP)
$Rel	.-2	Name	LD
	Beq	50$
	Mov	#$PName,R1
$Rel	.-2	$PName	RMON
RM.PNm=:.-2
	Mov	RM.Ent,R2
 30$:
	 Cmp	@SP,(R1)+
	 Beq	40$
	 Cmp	R1,R2
	 Bne	30$
40$:
	Sub	RM.PNm,R1
	Tst	-(R1)
	Br	60$
	...........
50$:
	Sec
60$:
	Bit	(SP)+,R2
	Mov	(SP)+,R2
	Bcs	LdNoDv
	MovB	R1,@R5
	.Br	LimCk
.SbTtl	Validate request (R/O) and block limits ok
.Enable	LSB
LimCk:
	Mov	Q$WCnt(R4),R1
	Bpl	ReadCk
	Bit	#Hd.RdO,@R5
	Bon	LdErr
	Neg	R1
ReadCk:
					.Assume	Q$BlkN EQ 0
	Cmp	@R4,Size(R2)
$Rel	.-2	Size	LD
	Bhi	LdErr
	Add	#256.-1,R1
	SwaB	R1
	Bic	#^c377,R1
					.Assume	Q$BlkN EQ 0
	Add	@R4,R1
	Cmp	R1,Size(R2)
$Rel	.-2	Size	LD
	Blos	FixOft
	Bis	#HdErr$,@Q$CSW(R4)
	Mov	Size(R2),R1
$Rel	.-2	Size	LD
					.Assume	Q$BlkN EQ 0
	Sub	@R4,R1
	SwaB	R1
	Bic	#^c377,R1
	Mov	R1,@Q$WCnt(R4)
FixOft:
					.Assume	Q$BlkN EQ 0
	Add	Offset(R2),@R4
$Rel	.-2	Offset	LD
	MovB	Handlr+1(R2),R1
$Rel	.-2	Handlr+1 LD
	Bic	#^cUntMsk,R1
	BicB	#UntMsk,Q$Unit(R4)
	BisB	R1,Q$Unit(R4)
.If	EQ	LD$Own
	.Br	ReQue
.IfF
	.Br	OwnCk
.SbTtl	Process ownership validation
.Enable	LSB
OwnCk:
	Asr	R1
....SJ:	Br	..NoCk
.=:....SJ;******************************;3
	MovB	@R5,R5
	Add	R5,R1
	Add	R5,R1
	MovB	.-.(R1),R5
RM.Own=:.-2
	Bit	#1,Handlr(R2)
$Rel	.-2	Handlr	LD
	Boff	10$
	.Rept	4
	Asr	R5
	.EndR
10$:
	Bic	#^cOwnMsk,R5
	Boff	ReQue
	Dec	R5
	MovB	Q$JNum(R4),R1
	Asr	R1
	Asr	R1
	Asr	R1
	Bic	#^cUntMsk,R1
	Cmp	R1,R5
	Bne	LdErr
	.Br	ReQue
..NoCk:
.EndC
.SbTtl	Requeuing process
ReQue:
	MovB	Handlr(R2),R2
$Rel	.-2	Handlr	LD
	Mov	.-.(R2),R2
RM.Ent=:.-2
	Beq	LdNoDv
	Call	@#$MFPS
$Rel	.-2	$MFPS	RMON
	Mov	#PR7,-(SP)
	Call	@#$MTPS
$Rel	.-2	$MTPS	RMON
RM.MTP=:.-2
	Clr	LdCQE
	Clr	LdLQE
	Call	@RM.MTP
	Add	#2,@SP
	Return
LDInt::
	......
LdNoDv:
LdErr:
	Bis	#HdErr$,@-(R4)
LdDone:
	.DrFin	LD
	..........
.DrEnd	LD
.SbTtl	Initialization, one-time code
.PSect	SETOVR
SetOvr:
.Enable	LSB
Init::
	Nop
	Mov	@#JRMon,R4
	Mov	@R5,R1
RM.Did	=	1
.Rept	RM.Cnt
 .Irp	x,<\RM.Did>
	Add	R4,RM.'x-LdBase(R1)
 .EndR
RM.Did	=	RM.Did+1
.EndR
	.Addr	#LD.Lst,R0
 20$:
	 Mov	(R0)+,R5
	 Bmi	30$
	 Add	R1,R5
	 Add	R1,@R5
	 Br	20$
	 ..........
30$:
	Mov	@RM.PNm-LdBase(R1),R5
	Add	R4,R5
	Mov	R5,RM.PNm-LdBase(R1)
	Mov	R5,R3
 40$:
	 Cmp	(R5)+,#EntEnd
	 Bne	40$
	Tst	-(R5)
	Sub	R3,R5
.If	NE	LD$Own
	Mov	R5,RM.Own-LdBase(R1)
.EndC
	Asr	R5
	Mov	R5,R0
	Add	R3,R5
	Mov	R5,RM.Ent-LdBase(R1)
.If	NE	LD$Own
	Cmp	(R0)+,(R0)+
	Sub	R0,R3
	Sub	R0,R3
	Sub	RM.Own-LdBase(R1),R3
	Mov	R3,RM.Own-LdBase(R1)
 .If	EQ	MMG$T
	Bit	#FBMon$,ConFg1(R4)
	Bon	50$
	Mov	#.-.,....SJ-LdBase(R1)
.....1=.
.=.-4
		Br	..NoCk-....SJ+.
.	=.....1
50$:
 .EndC;	EQ	MMG$T
.EndC
	Clc
	Return
	......
LD.Did	=	1
LD.Lst:
.Rept	LD.Cnt
 .Irp	x,<\LD.Did>
	.Word	LD.'x-LdBase
 .EndR
LD.Did	=	LD.Did+1
.EndR
	.Word	-1
.=.
.Assume	. LE SetOvr+<2*1000>
.Assume	LD.Cnt EQ LD.Did-1
.Assume	RM.Cnt EQ RM.Did-1
.SbTtl	LDRun - control LD handler
.PSect	LDRUN
.Enable	LSB
LDRun::
	Call	DBGRun
	...CmZ	Fudge=.LD
	.SErr
	Mov	#ClrLow,R0
	Mov	#ClrHi-ClrLow/2,R1
10$:
	 Clr	(R0)+
	 Sob	R1,10$
	Bit	#Chain$,@#JSW
	Boff	20$
	Mov	#ChnArg,R1
	CmpB	#ChnNon,@R1
	Bne	20$
	Clr	R1
20$:
	Mov	#CmdBuf,R3
	Mov	R3,CmdPtr
	Clr	CmdCnt
	.CSISpc	#Out1,#DefExt,R1,R3
	Bcc	30$
	Jsr	R0,ErrMsg
	.Word	MsgCsi
	Br	40$
	...........
30$:
	TstB	CmdBuf
	Bne	50$
	.Print	#MsgId
40$:
	Br	Done2
	............
50$:
	Mov	#In1,R0
	Mov	R0,R1
	.Rept	3
	Tst	-(R0)
	 .Rept	4
	Mov	-(R0),-(R1)
	 .EndR
	.EndR
	.Br	CkSys
.SbTtl	Insure that system channel open on LD handler on SY:
.Enable	LSB
CkSys:
	Mov	@#JRmon,R5
	Mov	#<^rLD >,R2
	Add	Suffix(R5),R2
	Mov	R2,DBlock+O.Name
	.CStat	#CStatS,Code=NoSet
	Bic	#^cHd.Ndx,CStat
	Cmp	SyIndx(R5),CStat
	Bne	10$
	CmpB	SyUnit(R5),CStat+C.Unit
	Beq	DoSwt
10$:
	.Purge	#SysChn
	Mov	#<^rSY >,DBlock+O.Dev
	Clr	DBlock+O.Name+2
	Mov	#<^rSYS>,DBlock+O.Type
	.LookUp	#LukUpS,Code=NoSet
	Bcc	20$
	Jmp	NoLErr
20$:
	Bit	#Chain$,@#JSW
	Bon	40$
	Clr	@#ChnFrm
	Mov	#CmdBuf,R0
	Mov	#ChnArg,R1
 30$:
	 MovB	(R0)+,(R1)+
	 Bne	30$
40$:
	.Chain
	......
ErrUkS:
	 Jsr	R0,ErrMsg
	 .Word	MsgUkS
	 Br	Done1
	 ...........
ErrNoV:
	 Jsr	R0,ErrMsg
	 .Word	MsgNoV
	 Br	Done1
	 ...........
.SbTtl	Process switches
.Enable	LSB
DoSwt:
	Mov	#-1,R5
	Call	SpFun
	Mov	(SP)+,R1
	Bne	NxtSwt
Done2:	Br	Done1
	.............
 NxtSwt:
	 Mov	#SwList-2,R2
	 Mov	(SP)+,R0
	 CmpB	R0,#'a
	 Blo	10$
	 CmpB	R0,#'z
	 Bhi	10$
	 Bic	#040,R0
 10$:
  20$:
	  Tst	(R2)+
	  TstB	(R2)+
	  Bmi	ErrUkS
	  CmpB	(R2)+,R0
	  Bne	20$
	 Jmp	@(R2)
	 ............
SwtA:
	 Tst	R0
	 Bpl	ErrNoV
	 Mov	(SP)+,ValueA
	 Br	SwtNoC
	 .............
SwtC:
	 Mov	R0,FlagC
	 Bpl	SwtXit
	 Mov	(SP)+,ValueC
	 Br	SwtXit
	 .............
SwtL:
	 Call	CheckV
	 Bis	#Sw.L,Table(R3)
	 SwaB	R0
	 Bic	#^c177,R0
	 MovB	R0,Table(R3)
	 MovB	R3,UnitA
	 AsrB	UnitA
	 BisB	#'0,UnitA
	 Inc	CountL
	 Br	SwtNoC
	 ..............
SwtR:
	 Call	CheckV
	 Bis	#Sw.R,Table(R3)
	 Br	SwtNoC
	 ..............
SwtW:
	 Call	CheckV
	 Bis	#Sw.W,Table(R3)
	 .Br	SwtNoC
SwtNoC:
	 Inc	FlgNoC
	 .Br	SwtXit
SwtXit:
	 Sob	R1,NxtSwt
	Br	CkSwt
Swt$:
	 Mov	R0,Flag$
	 Bpl	SwtXit
	 Tst	(SP)+
	 Br	SwtXit
	 .............
.SbTtl	CkSwt	- verify correct switch selections
.Enable	LSB
CkSwt:
	Tst	FlagC
	Boff	10$
	Tst	FlgNoC
	Boff	20$
	Jsr	R0,ErrMsg
	.Word	MsgSwC
	Br	Done1
	............
10$:
	Tst	ValueA
	Boff	DoFile
	Dec	CountL
	Beq	DoFile
	Jsr	R0,ErrMsg
	.Word	MsgALS
Done1:	Jmp	Done
	............
20$:
	Mov	#Handlr,R5
	Mov	#Name,R4
	Mov	#In1-<3*<In2-In1>>,R3
	Clr	R1
	Mov	#8.,R2
 30$:
	 MovB	R1,(R5)+
	 Inc	R1
	 MovB	(R5)+,R0
	 Bic	#^cUntMsk,R0
	 Add	(R4)+,R0
	 Add	#^r  0,R0
	 Mov	R0,(R3)+
	 Mov	(R4)+,(R3)+
	 Mov	(R4)+,(R3)+
	 Mov	(R4)+,(R3)+
	 Sob	R2,30$
	Mov	#Handlr,R2
	Br	DoSwtC
	..............
ErrNoF:
	Jsr	R0,ErrMsg
	.Word	MsgNoF
	Br	FilXi1
	..............
ErrDev:
	Jsr	R0,ErrMsg
	.Word	MsgDev
	Br	FilXi1
	..............
ErrRan:
	Jsr	R0,ErrMsg
	.Word	MsgRan
FilXi1:	Jmp	FilXit
	..............
ErrHTB:
	Jsr	R0,ErrMsg
	.Word	MsgHTB
	Br	SetTo1
	..............
ErrFet:
	Jsr	R0,ErrMsg
	.Word	MsgFet
	Mov	Sp,Feterr
	Tst	FlagC
	Boff	Done1
SetTo1:	Jmp	SetTop
	..............
ErrFNF:
	Jsr	R0,ErrMsg
	.Word	MsgFNF
	Br	Done1
	............
.SbTtl	Process input and update handler tables
.Enable	LSB
DoFile:
	Mov	#Table,R2
DoSwtC:
	Mov	#In1-<3*<In2-In1>>,R1
	Mov	#Handlr,R4
	Clr	R5
NxtFil:
					.Assume 100000 EQ Sw.L
	 Tst	@R2
	 Bpl	10$
	 Bic	#Hd.Act!Hd.UOf,@R4
	 MovB	@R2,R3
	 Asl	R3
	 Asl	R3
	 Asl	R3
	 Add	R1,R3
					.Assume O.Dev EQ 0
	 Tst	@R3
	 Bon	20$
 10$:	 Jmp	90$
 20$:
	 Tst	O.Name(R3)
	 Boff	ErrNoF
	 Bis	#Hd.Act!Hd.UNx,@R4
	 .DStatus #DStat,R3
	 Bcs	ErrDev
					.Assume 100000 EQ FilSt$
	 Tst	DStat
	 Bpl	ErrRan
	 Tst	DStat+D.EntP
	 Bon	30$
	 Add	LimHi,DStat+D.HSiz
	 .SetTop DStat+D.HSiz
	 Cmp	R0,DStat+D.HSiz
	 Blo	ErrHTB
	 .Fetch	LimHi,R3
	 Bcs	ErrFet
	 .Br	30$
 30$:
	 Clr	-(SP)
					.Assume	Chan EQ 0
	 .Purge	#0
	 .LookUp #LukupF,,R3,Code=NoSet
	 Bcc	40$
	 Inc	@SP
	 Tst	FlagC
	 Boff	ErrFNF
	 Bis	#Hd.UOf,@R4
	 Mov	O.Name(R3),@SP
	 Clr	O.Name(R3)
	 .LookUp #LukupF,Code=NoSet
	 Mov	@SP,O.Name(R3)
 40$:
	 .CStat	#CStatF, Code=NoSet
	 Mov	CStat+C.Leng,Size-Handlr(R4)
	 Mov	CStat+C.SBlk,Offset-Handlr(R4)
	 MovB	CStat+C.Unit,R0
	 BicB	#UntMsk,1(R4)
	 Bic	#^cUntMsk,R0
	 BisB	R0,1(R4)
					.Assume Chan EQ 0
	 .Purge	#0
	 Tst	(SP)+
	 Bon	70$
	 Tst	Flag$
	 Boff	60$
	 Tst	DStat+D.EntP
	 Bon	60$
	 Mov	R0,-(SP)
	 Mov	R1,-(SP)
	 Mov	CmdPtr,R1
	 Mov	#LCmnd,R0
  50$:
	  Inc	CmdCnt
	  MovB	(R0)+,(R1)+
	  Bne	50$
	 TstB	-(R1)
	 Mov	CStat+C.DevN,R0
	 Call	$R50Asc
	 ClrB	(R1)+
	 Mov	R1,CmdPtr
	 Add	#3,CmdCnt
	 Mov	(SP)+,R1
	 Mov	(SP)+,R0
 60$:
	 .FProt	#FProt,,R3,Code=NoSet
	 Bcs	ErrPro
	 .Br	70$
 70$:
 Releas:
	 .Release R3
 SetTop:
 80$:
	 .SetTop LimHi
	 Bis	#Hd.UNx,@R4
	 Mov	R5,R0
	 Add	#Name,R0
	 Tst	Feterr
	 Bne	81$
	 Mov	CStat+C.DevN,(R0)+
	 Tst	(R3)+
	 Mov	(R3)+,(R0)+
	 Mov	(R3)+,(R0)+
	 Mov	(R3)+,(R0)+
81$:	 Clr 	Feterr
	 Tst	FlagC
	 Bon	90$
	 Bic	#Hd.RdO,@R4
 90$:
	 Mov	#Hd.RdO,R0
	 Bit	#Sw.W,@R2
	 Boff	110$
					.Assume Sw.R EQ Hd.RdO
	 Bit	R0,@R2
	 Boff	100$
	 Mov	SP,WarnRW
 100$:
	 Bic	R0,@R4
 110$:
					.Assume Sw.R EQ Hd.RdO
	 Bit	R0,@R2
	 Boff	FilXit
	 Bis	R0,@R4
 FilXit:
	 Cmp	(R2)+,(R4)+
	 Add	#O.Size,R5
	 Cmp	#Units*O.Size,R5
	 Beq	WrapUp
	Jmp	NxtFil
	..............
ErrPro:
	Jsr	R0,ErrMsg
	.Word	MsgPro
	Br	Releas
	...........
	.SbTtl	WrapUp
	.Enable	LSB
WrapUp:
	Clr	FlagC
	.WritW	#WritW,,,,,,Code=NoSet
	Bcc	20$
	Tst	LDMem
	Bon	10$
	Cmp	#-1,ValueC
	Beq	10$
	Jsr	R0,ErrMsg
	.Word	MsgWri
	Br	Done
	............
10$:
	Jsr	R0,ErrMsg
	.Word	MsgWWr
20$:
	Mov	#+1,R5
	Call	SpFun
Done:
	Mov	@#JSP,SP
	Tst	WarnRW
	Bon	30$
	Tst	HadErr
	Bon	40$
	Jsr	R0,ErrMsg
	.Word	MsgAOK
	Br	40$
	...........
30$:
	Clr	WarnRW
	Jsr	R0,ErrMsg
	.Word	MsgWRW
40$:
	Tst	CmdCnt
	Bon	Kmon
	Tst	ValueA
	Bon	Kmon
	Bit	#Chain$,@#JSW
	Bon	50$
	.SReset
	Jmp	LDRun
	.............
50$:
	Tst	@#ChnFrm
	Boff	Exit
Chain:
	Mov	#ChnTo,R2
	Mov	#ChnFrm,R1
	.Rept	4
	Mov	(R1)+,(R2)+
	.EndR
					.Assume	Chan EQ 0
	.Purge	#0
	.Chain
	......
Kmon:
	Mov	CmdPtr,R1
	Mov	CmdCnt,R3
	Mov	ValueA,R0
	Boff	70$
	Mov	#ACmnd,R2
 60$:
	 Inc	R3
	 MovB	(R2)+,(R1)+
	 Bne	60$
	TstB	-(R1)
	Call	$R50Asc
	ClrB	(R1)+
	Add	#3,R3
70$:
	Mov	#CmdBuf,R0
	Mov	#CmdLen,R1
	Mov	R3,(R1)+
					.Assume CmdLen+2 EQ CmdStr
 80$:
	 MovB	(R0)+,(R1)+
	 Sob	R3,80$
	Bis	#SpXit$!ChnIF$,@#JSW
	Clr	R0
Exit:
	.Exit
	......
.Enable	LSB
ErrMsg:
	Mov	SP,HadErr
	Mov	R0,-(SP)
	Add	#2,@SP
	Mov	@R0,R0
	Call	@(R0)+
	Tst	ValueC
	Bge	1$
	CmpB	#Warn$,1(R0)
	Bge	1$
	MovB	#Warn$,1(R0)
	MovB	#'W,2(R0)
1$:	Mov	R1,-(SP)
	Bit	#Chain$,@#JSW
	Boff	20$
	Tst	@#ChnFrm
	Boff	20$
	Mov	#ChnArg,R1
	MovB	#ChnRtn,(R1)+
					.Assume ChnErr EQ ChnArg+1
 10$:
	 MovB	(R0)+,(R1)+
	 Bne	10$
	Br	30$
	...........
20$:
	Mov	(R0)+,R1
	Swab	R1
	BisB	R1,@#JUsErB
	TstB	@R0
	Boff	30$
	Mov	R0,-(SP)
	.Print	#Prefix
	Mov	(SP)+,R0
	.Print
30$:
	Mov	(SP)+,R1
	Mov	(SP)+,R0
	Rts	R0
	..........
	.SbTtl	SpFun Subroutine
.Enable	LSB
SpFun:
	.DStatus #DStat+1,#R50LD
	Bcc	10$
NoLErr:
	Mov	#R50LD,R3
	Jsr	R0,ErrMsg
	.Word	MsgDev
Done3:	Jmp	Done
	............
10$:
	Mov	DStat+D.EntP,LDMem
	Boff	30$
	Cmp	DStat+D.Stat,#LDSts
	Bne	NoLErr
	Call	30$
	.LookUp	#LukUpL,Code=NoSet
	Bcc	20$
	Jsr	R0,ErrMsg
	.Word	MsgLuk
	Br	Done3
	.............
20$:
	.SpFun	#SpFunL,WCnt=R5,Code=NoSet
	Bcc	30$
	Jsr	R0,ErrMsg
	.Word	MsgSpF
	Br	Done3
	.............
30$:
					.Assume	Chan EQ 0
	.Purge	#0
	Return
	......
	.SbTtl	Check for valid switch values subroutine
.Enable	LSB
CheckV:
	Tst	R0
	Bmi	10$
	Jsr	R0,ErrMsg
	.Word	MsgNoV
	Br	Done3
	.............
10$:
	Mov	(SP)+,R3
	Mov	(SP)+,R2
	Cmp	#Units-1,R2
	Bhis	20$
	Jsr	R0,ErrMsg
	.Word	MsgBdV
	Br	Done3
	.............
20$:
	Mov	R3,-(SP)
	Mov	R2,R3
	Asl	R3
	Return
	......
.SbTtl	Error message formatting routines
Device:
	Mov	R1,-(SP)
	Mov	(R0)+,R1
	Mov	R0,-(SP)
	Mov	#ErrBuf+2,R0
	Clr	-(R0)
	Mov	@R3,@R0
	Br	CalFnA
	..............
File:
	Mov	R1,-(SP)
	Mov	(R0)+,R1
	Mov	R0,-(SP)
	Mov	R3,R0
CalFnA:
	Call	$FnAsc
	ClrB	(R1)+
	Br	R01Ret
	.............
Switch:
	MovB	4(SP),@(R0)+
	Return
	......
SwiVal:
	Mov	R1,-(SP)
	MovB	4(SP),@(R0)+
Value:
	Mov	(R0)+,R1
	Mov	R0,-(SP)
	Mov	R1,R0
	Mov	R2,R1
	Mov	R2,-(SP)
	Clr	R2
	Call	$CBOMg
	ClrB	(R0)+
	Mov	(SP)+,R2
R01Ret:
	Mov	(SP)+,R0
	Mov	(SP)+,R1
Nothin:
RtsPC:	Return
	......
.SbTtl	Messages
MsgId:
.IIf	EQ MMg$T!RTE$M	.NLCSI
.If	NE MMg$T
	.NLCSI	TYPE=I,PART=NAME
	.Ascii	"X "
	.NLCSI	TYPE=Z,PART=RLSVER
.EndC
.If	NE RTE$M
	.NLCSI	TYPE=I,PART=NAME
	.Ascii	"M "
	.NLCSI	TYPE=Z,PART=RLSVER
.EndC
Prefix:	.Ascii	"?"
	.NLCSI	TYPE=I,PART=NAME
	.Ascii	"-"<200>
	.Even
MsgAOK:	.Word	Nothin
	.Asciz	<-1><Succs$>""
	.Even
MsgCsi:	.Word	Nothin
	.Asciz	<1><Fatal$>"F-Invalid Command"
	.Even
MsgWRW:	.Word	Nothin
	.Ascii	<2><Warn$>"W-/W and /R specified for same unit, /W ignored "
	.Even
MsgDev:	.Word	Device,ChrDev
	.Ascii	<3><Fatal$>"F-Device not installed "
ChrDev:	.BlkB	4.
	.Asciz	""
	.Even
MsgRan:	.Word	Device,ChrRan
	.Ascii	<4><Fatal$>"F-Invalid device "
ChrRan:	.BlkB	4.
	.Asciz	""
	.Even
MsgNoV:	.Word	Switch,ChrNoV
	.Ascii	<5><Fatal$>"F-Switch without required value /"
ChrNoV:	.BlkB	1.
	.Asciz	""
	.Even
MsgPro:	.Word	File,ChrPro
	.Ascii	<6><Warn$>"W-Unable to protect file "
ChrPro:	.BlkB	14.
	.Asciz	""
	.Even
MsgBdV:	.Word	SwiVal,ChrBdV,ValBdV
	.Ascii	<7><Fatal$>"F-Switch value out of range (0--7) /"
ChrBdV:	.BlkB	1.
	.Ascii	":"
ValBdV:	.BlkB	6.
	.Asciz	""
	.Even
MsgNoF:	.Word	Device,ChrNoF
	.Ascii	<8.><Fatal$>"F-No file specified "
ChrNoF:	.BlkB	4.
	.Asciz	""
	.Even
MsgFNF:	.Word	File,ChrFNF
	.Ascii	<9.><Fatal$>"F-File not found "
ChrFNF:	.BlkB	14.
	.Asciz	""
	.Even
MsgUkS:	.Word	Switch,ChrUkS
	.Ascii	<10.><Fatal$>"F-Unknown switch (/C, /L, /R, or /W only) /"
ChrUkS:	.BlkB	1
	.Asciz	""
	.Even
MsgALS:	.Word	Nothin
	.Asciz	<11.><Fatal$>"F-/A requires exactly 1 /L"
	.Even
MsgLuk:	.Word	Nothin
	.Asciz	<12.><Fatal$>"F-.LookUp for LD failed"
	.Even
MsgSpF:	.Word	Nothin
	.Asciz	<13.><Fatal$>"F-.SpFun to LD failed"
	.Even
MsgWri:	.Word	Nothin
	.Asciz	<14.><Fatal$>"F-Unable to update LD handler"
	.Even
MsgWWr:	.Word	Nothin
	.Asciz	<15.><Warn$>"W-Unable to update disk copy of LD handler"
	.Even
MsgHTB:	.Word	Nothin
	.Asciz	<16.><Fatal$>"F-Insufficient memory"
	.Even
MsgFet:	.Word	Device,ChrFet
	.Ascii	<17.><Fatal$>"F-.Fetch error "
ChrFet:	.BlkB	4.
	.Asciz	""
	.Even
MsgSwC:	.Word	Nothin
	.Asciz	<18.><Fatal$>"F-/C not specified alone"
	.Even
.SbTtl	Data
Chan	=:	0
SysChn	=:	17
..LDEX::
DefExt:	.Word	Def$LD,Def$LD,Def$LD,Def$LD
R50LD:
	.Rad50	"LD   "
LimLow:	.Limit
LimHi	=:	LimLow+2
ACmnd:
	.Ascii	"$ASSIGN LD"
UnitA:	.BlkB	1.
	.Asciz	" "
LCmnd:	.Asciz	"$LOAD "
	.Even
SwList:
	.Byte	0,'$
	.Word	Swt$
	.Byte	0,'A
	.Word	SwtA
	.Byte	0,'C
	.Word	SwtC
	.Byte	0,'L
	.Word	SwtL
	.Byte	0,'R
	.Word	SwtR
	.Byte	0,'W
	.Word	SwtW
	.Byte	-1
	.SbTtl	EMT argument blocks
.LookUp	=:	1
.Write	=:	11
.CStat	=:	27
.SpFun	=:	32
.FProt	=:	43
	Protect	=:	1
	Physical=:	RtsPC+1
	.Even
CStatF:
	.Byte	Chan, .CStat
	.Word	CStat
CStatS:
	.Byte	SysChn, .CStat
	.Word	CStat
FProt:
	.Byte	Chan, .FProt
	.BlkW	1.
	.Word	Protect
LukUpF:
	.Byte	Chan, .LookUp
	.BlkW	1.
	.Word	0
LukUpL:
	.Byte	Chan, .LookUp
	.Word	R50LD+1
	.Word	0
	.BlkW	1
	.Word	Physical
LukUpS:
	.Byte	SysChn, .LookUp
	.Word	DBlock+1
	.Word	0
	.BlkW	1
	.Word	Physical
SpFunL:
	.Byte	Chan, .SpFun
	.Word	0
	.Word	BufLow
	.BlkW	1.
	.Byte	377, Upd$Fn
	.Word	0
WritW:
	.Byte	SysChn, .Write
	.Word	LDStrt/256./2
	.Word	LDStrt
	.Word	256.*2
	.Word	0
	.SbTtl	Area to clear on startup
ClrLow:
ErrBuf:	.BlkW	2.
Flag$:	.BlkW	1.
FlagC:	.BlkW	1.
FlgNoC:	.BlkW	1.
ValueA:	.BlkW	1
ValueC:	.BlkW	1
CountL:	.BlkW	1
WarnRW:	.BlkW	1.
LDMem:	.BlkW	1.
HadErr:	.BlkW	1.
Feterr:	.BLKW	1
CmdPtr:	.BlkW	1.
CmdCnt:	.BlkW	1.
DBlock	=:	ChnTo
.IrpC	.....1	<123>
Out'.....1:	.BlkW	5.
.EndR
.IrpC	.....1	<123456>
In'.....1:	.BlkW	4.
.EndR
O.Dev	=:	0
O.Name	=:	2
O.Type	=:	6
O.Size	=:	10
DStat:	.BlkW	4.
D.Stat	=:	0
D.HSiz	=:	2
D.EntP	=:	4
D.DSiz	=:	6
CStat:	.BlkW	6.
C.CSW	=:	0
C.SBlk	=:	2
C.Leng	=:	4
C.Used	=:	6
C.Unit	=:	10
C.DevN	=:	12
Table:	.BlkW	Units
	Sw.L	=:	100000
	Sw.W	=:	040000
	Sw.R	=:	020000
.Assume	Sw.L EQ Hd.Act
.Assume	Sw.R EQ Hd.RdO
CmdBuf:	.BlkB	100.
	.Even
ClrHi:
	.End	LDRun
                                                                                                                                                                                                                                                                                                                                                                          