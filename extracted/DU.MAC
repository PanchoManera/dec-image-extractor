.MCALL .MODULE     
.MODULE DU,VERSION=51,COMMENT=<MSCP Disk Class Handler>,AUDIT=NO

;                     COPYRIGHT (c) 1984,1985, 1986 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                         ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
.SBTTL	CONDITIONAL ASSEMBLY SUMMARY
.SBTTL	Functional description
	.SBTTL	Design Overview
.SBTTL	CONDITIONALS
	.MCALL	.ASSUME,.ADDR,.BR
.NLIST	CND
	.IIF NDF DU$BOO, DU$BOO == 0
	.IIF NDF DU$BBR, DU$BBR == 0
	.IIF NDF ERL$G,  ERL$G == 0
	.IIF NDF DU$ERL, DU$ERL == 0
	.IIF NDF MMG$T,  MMG$T == 0
.IIF NDF DU$PORTS,   DU$PORTS = 1
.IIF LE  DU$PORTS-1, DU$PORTS = 1
.IIF EQ  DU$PORTS-1, DU$BOO = 0
	DU$BBR = DU$BBR & MMG$T
	.DUGEN	=:  DU$PORTS!<DU$BOO*400>!<DU$BBR*1000>
	.AUDIT	.DU,.DUGEN
.SBTTL	MSCP PROTOCOL DEFINITIONS
P.CRF	=:   0
P.UNIT	=:   4
P.OPCD	=:  10
P.MOD	=:  12
P.BCNT	=:  14
P.BUFF	=:  20
P.LBN	=:  34
P.PART	=:  36
P.CSIZ	=:  60
P.OTRF	=:  14
P.UNFL	=:  16
P.DVPM	=:  34
P.RBN	=:  14
P.VRSN	=:  14
P.CNTF	=:  16
P.HTMO	=:  20
	TO.MIN	= 0
P.TIME	=:  24
P.CRF	=:   0
P.UNIT	=:   4
P.OPCD	=:  10
P.FLGS	=:  11
P.STS	=:  12
P.BCNT	=:  14
P.FBBK	=:  34
P.OTRF	=:  14
P.CMST	=:  20
P.MLUN	=:  14
P.UNFL	=:  16
P.UNTI	=:  24
P.TRCK	=:  44
P.GRP	=:  46
P.CYL	=:  50
P.RCTS	=:  54
P.RBNS	=:  56
P.RCTC	=:  57
P.MLUN	=:  14
P.UNFL	=:  16
P.UNTI	=:  24
P.MEDI	=:  34
P.UNSZ	=:  44
P.VSER	=:  50
P.VRSN	=:  14
P.CNTF	=:  16
P.CTMO	=:  20
P.CNTI	=:  24
P.MSIZ	=:  60
OP.NIL	=:  0
OP.ABO	=:  1
OP.GCS	=:  2
OP.GUS	=:  3
OP.SCC	=:  4
OP.AVL	=: 10
OP.ONL	=: 11
OP.SUC	=: 12
OP.DAP	=: 13
OP.ACC	=: 20
OP.ERS	=: 22
OP.RPL	=: 24
OP.CMP	=: 40
OP.RD	=: 41
OP.WR	=: 42
OP.SEX	=:   7
OP.END	=: 200
OP.AVA	=: 100
OP.DUP	=: 101
OP.ACP	=: 102
MD.CMP	=:   40000
MD.EXP	=:  100000
MD.ERR	=:   10000
MD.SEC	=:    1000
MD.SER	=:     400
MD.ALL	=:       2
MD.SPD	=:       1
MD.NXU	=:    2000
MD.RIP	=:       1
MD.IMP	=:       2
MD.SWP	=:	 4
MD.PRI	=:	 1
EF.BBR	=:     200
EF.BBU	=:     100
EF.LOG	=:      40
UF.CMR	=:       1
UF.CMW	=:       2
UF.576	=:       4
UF.RMV	=:     200
UF.WPH	=:   20000
UF.WPS	=:   10000
UF.BBR  =:  100000
CF.ATN	=:     200
CF.MSC	=:     100
CF.OTH	=:      40
CF.THS	=:      20
CF.576	=:       1
ST.MSK	=:      37
ST.SUC	=:       0
ST.INV	=:	 1
ST.OFF	=: 	 3
ST.AVL	=:       4
ST.PRO	=:	 6
ST.DAT	=:	10
ST.DRV	=:	13
L.CRF	=:   0
L.UNIT	=:   4
L.SEQ	=:   6
L.FMT	=:  10
L.FLGS	=:  11
L.EVNT	=:  12
L.CNTI	=:  14
L.CSVR	=:  24
L.CHVR	=:  25
L.MLUN	=:  26
L.UNTI	=:  30
L.USVR	=:  40
L.UHVR	=:  41
L.VSER	=:  44
FM.CNT	=:      0
FM.BAD	=:      1
FM.DSK	=:      2
FM.SDI	=:	3
LF.SUC	=:    200
LF.CON	=:    100
LF.SNR	=:      1
L.BADR	=:   4
L.LVL	=:  42
L.RTRY	=:  43
L.VSER	=:  44
L.HDCD	=:  50
L.HDCD	=:  50
L.SDI	=:  54
.SBTTL	UDA PORT DEFINITIONS
OWN	=: 100000
FLAG	=:  40000
ISTEP1	=:   4000
ISTEP2	=:  10000
ISTEP3	=:  20000
ISTEP4	=:  40000
IERROR	=: 100000
IE	=:    200
STEP	=:    200
GO	=:      1
PC.AIP	=:	0
PC.ASA	=:	2
PC.STEP	=:	4
PC.VEC	=:	6
PC.ESZ	=:     10
BB.STS	=:	0
BB.MAX	=:	2
BB.RCT	=:	6
BB.TRK	=:     10
BB.RBN	=:     12
BB.COP	=:     13
BB.SIZ	=:     14
.SBTTL	DRIVER DEFINITIONS
NRETRY	=:	8.
VT.ESZ	=:	6
ILG.V	=:  4
INS.V	=: 10
KISAR1	=: 172342
BLK	=: 1000
BLK0	=: 0
SYSPTR	=: 54
MEMPTR	=: 430
	CORPTX 	=: 4
	   FSIZE   =: 0
	   FADDR   =: 2
P1EXT	=: 432
	CVAPHY	=: -16
	FINDGR	=: -12
	XALLOC  =: -6
	BLKMOV	=: -2
CONFG2 	=: 370
	QBUS$ =: 000100
GR.SIZ	=: 	0
GR.ADR  =: 	2
GR.STA	=: 	4
	GR.PVT =: 100000
	GR.NRF =: 000040
GR.NAM 	=: 	6
GR.ESZ	=:	10.
BEGREL	=:	20000
ENDREL 	=:	37776
PGSIZ	=:	20000
SP.RIO	=: 377
SP.WIO	=: 376
SP.VSZ	=: 373
SP.DAT	=: 372
SP.BYP	=: 371
SP.MUC	=: 360
SPFUNB	=:	100000
SPERR	=:	077400
SPFERR	=:	040000
SPBBR	=:	000200
SPECC	=:	000001
UT.UNIT	=:	0
UT.PART =:	2
UT.PORT	=:	3
UT.ESZ	=:	4
	.SBTTL	DRDEF - definition
	.MCALL	.DRDEF,	.MFPS,	.MTPS
	.DRDEF	DU,50,FILST$!SPFUN$!VARSZ$,0,172150,154
	.IF EQ MMG$T
	.DRPTR	FETCH=ONCE,LOAD=ONCE
	.DREST	CLASS=DVC.DK
	.IFF
	.DRPTR	FETCH=ONCE,LOAD=ONCE
	.DREST	CLASS=DVC.DK
	.ENDC
	.DRSPF	SP.RIO
	.DRSPF	SP.WIO
	.DRSPF	SP.VSZ
	.DRSPF	SP.DAT
	.DRSPF	<SP.BYP,SP.MUC>
.IIF NDF DU$ALT	DU$ALT	= 176150
.IIF NDF DU$CS1, DU$CS1=DU$CSR-04
.IIF NDF DU$CS2, DU$CS2=DU$CSR-10
.IIF NDF DU$CS3, DU$CS3=DU$CSR-14
.IIF NDF DU$VC1, DU$VC1=DU$VEC-04
.IIF NDF DU$VC2, DU$VC2=DU$VEC-10
.IIF NDF DU$VC3, DU$VC3=DU$VEC-14
.IF NE MMG$T
	.SAVE
	.PSECT	DUDVR
	.PSECT	SETOVR
	.PSECT	DUBOOT
	.PSECT	DUX
DUXBAS::
	.RESTORE
.IFF
	.PSECT 	DUDVR
	.PSECT	SETOVR
	.PSECT	DUBOOT
.ENDC
.SBTTL	MACRO DEFINITIONS
.MACRO	MSCP OPCODE
	JSR R5,GETCBF
	.WORD OPCODE
.ENDM
.MACRO	DO	THIS,THEN,THAT
	JSR	R5,COORD
	.WORD	THAT-.,THIS-.
.ENDM
.MACRO	PUSH	LIST
.IRP	XX,<LIST>
MOV	XX,-(SP)
.ENDM
.ENDM	PUSH
.MACRO	POP	LIST
.IRP	XX,<LIST>
MOV	(SP)+,XX
.ENDM
.ENDM	POP
DUR.Cnt	=	0
DUX.Cnt	=	0
.Macro	$Rel	Loc	Value	Base
.....1	=	.
.	=	Loc
.If	IDN	<DUX>	<Base>
DUX.Cnt	=	DUX.Cnt+1
.Irp	x	<\DUX.Cnt>
DUX'x:	.Word	Value-DUXBase+BEGREL
.EndR
.	=	.....1
.MExit
.EndC;	IDN	<DUX>	<Base>
.If	IDN	<DUR>	<Base>
DUR.Cnt	=	DUR.Cnt+1
.Irp	x	<\DUR.Cnt>
DUR'x:	.Word	Value-DUBase
.EndR
.	=	.....1
.MExit
.EndC;	IDN	<DUR>	<Base>
.Error
.EndM	$Rel
.MACRO	DUXPSECT
.IF NE MMG$T
	.SAVE
	.PSECT	DUX
.ENDC
.ENDM 	DUXPSECT
.MACRO	DUPSECT
.IIF NE MMG$T	.RESTORE
.ENDM	DUPSECT
.MACRO	.P1EXT	NEWPAR,?LOC
	MOV	NEWPAR,LOC
	JSR	R0,@$P1EXT
	.WORD	LOC-.
	.MACRO	.P1END
LOC:	.WORD	0
	.ENDM
.ENDM	.P1EXT
.MACRO	.HP1EX	NEWPAR,?LOC
	MOV	NEWPAR,LOC
	JSR	R0,@H$P1EX
	.WORD	LOC-.
	.MACRO	.HP1EN
LOC:	.WORD	0
	.ENDM
.ENDM	.HP1EX
.SBTTL	INSTALLATION CODE
	.ASECT
	. = 0
REF0::
	. = 120
	.IF EQ DU$PORTS-1
		.DRINS	DU
	.IFF
	 .IF EQ DU$PORTS-2
		.DRINS	DU,<DU$CS1>
	 .IFF
	  .IF EQ DU$PORTS-3
		.DRINS	DU,<DU$CS1,DU$CS2>
	  .IFF
		.DRINS	DU,<DU$CS1,DU$CS2,DU$CS3>
	  .ENDC
	 .ENDC
	.ENDC
	BR	DATAIN
	BR	SYSTIN
DATAIN:
.IF NE MMG$T
	MOV	@#SYSPTR,R4
	MOV	MEMPTR(R4),R0
	ADD	R4,R0
	MOV	CORPTX(R0),R5
	ADD	R4,R5
20$:	CMP	#-1,(R5)+
	BNE	20$
30$:	CMP	#-1,@R5
	BEQ	I.BAD
	TST	@R5
	BEQ	40$
	ADD	#GR.ESZ,R5
	BR	30$
40$:	MOV	P1EXT(R4),R0
	MOV	#MEMDUX,R2
	CALL	XALLOC(R0)
	BCS	I.BAD
	MOV	R2,(R5)+
	MOV	R1,(R5)+
	MOV	#GR.PVT,(R5)+
	MOV	#<^RDU >,(R5)+
	MOV	#<^R$>,@R5
	.DSABL	LSB
.ENDC
SYSTIN:
.IF EQ DU$BOO
	CLR	R0
	MFPT
	CMP	R0,#4
	BNE	I.GOO
	TST	@#DU$ALT
   .IIF EQ MMG$T	NOP
	BCS	I.BAD
.ENDC
I.GOO:	TST	(PC)+
I.BAD:	SEC
	RTS	PC
	.SBTTL	SET code dispatch tables.
	.ENABL	LSB
OV.UT:
	MOV	#SET.UT/2,R2
	BR	10$
OV.CSR:	MOV	#SET.CSR/2,R2
	BR	10$
OV.VEC:	MOV	#SET.VEC/2,R2
	BR	10$
OV.RET:	MOV	#SET.RET/2,R2
10$:	BR	GETOVR
	.DSABL	LSB
	.ASSUME	. LE 400
.SBTTL	SET CODE TABLES
	.DRSET	UNIT,UT.UNIT+1,XOV.UT,NUM
	.DRSET	PART,UT.PART+1,XOV.UT,NUM
.IF NE DU$PORTS-1
	.DRSET	PORT,UT.PORT+1,XOV.UT,NUM
.ENDC
	.DRSET	CSR,<0*2+1>,XOV.CS,OCT
	.DRSET	VECTOR,<0*2+1>,XOV.VE,OCT
	.DRSET	CSR0,<0*2+1>,XOV.CS,OCT
	.DRSET	VEC0,<0*2+1>,XOV.VE,OCT
.IF NE DU$PORTS-1
	.DRSET	CSR1,<1*2+1>,XOV.CS,OCT
	.DRSET	VEC1,<1*2+1>,XOV.VE,OCT
 .IF NE DU$PORTS-2
	.DRSET	CSR2,<2*2+1>,XOV.CS,OCT
	.DRSET	VEC2,<2*2+1>,XOV.VE,OCT
  .IF NE DU$PORTS-3
	.DRSET	CSR3,<3*2+1>,XOV.CS,OCT
	.DRSET	VEC3,<3*2+1>,XOV.VE,OCT
  .ENDC
 .ENDC
.ENDC
	.DRSET	RETRY,8.,XOV.RE,NUM
.IF NE ERL$G
	.DRSET	SUCCES,-1,OV.SUC,NO
.ENDC
XOV.UT:	BR	OV.UT
XOV.CS: BR 	OV.CSR
XOV.VE:	BR	OV.VEC
XOV.RE: BR	OV.RET
.IF NE ERL$G
OV.SUC:	CLR	R2
	BR	ACNO
OV.NO:	MOV	#4/2,R2
ACNO:	ADD	#SET.SUC/2,R2
	BR	GETOVR
.ENDC
	.ASSUME . LE <1000-144>
	.SBTTL	GETOVR - Get Overlay SET code routine from disk
	.ENABL	LSB
	. = 1000 - 144
GETOVR:
	SWAB	R2
	MOVB	R2,REABLK
	BIC	#377,R2
	.ASSUME	BLK0 EQ 0
	JSR	R0,10$
REAFUN:	.BYTE	17,10
REABLK:	.BLKW	1
REABUF:	.BLKW	1
	.WORD	VALWCT
	.WORD	0
10$:	.ADDR	#BLK0,R5,PUSH
	MOV	R5,REABUF
	MOV	(SP)+,R5
	VALWCT =: ./2
	OVRSIZ =: .
	EMT	375
	MOV	(SP)+,R0
	BCS	SET.NOR
	SWAB	R2
	ASL	R2
	.ADDR	#BLK0,R2,ADD
	JMP	@R2
	.DSABL	LSB
	.SBTTL	GETBK0	- Read block zero - resident routine
	.ENABL	LSB
GETBK0:	JSR	R0,10$
RDZERO:	.BYTE	17,10
	.WORD	BLK0
RDBUF:	.BLKW	1
RDWC:	.WORD	VALWCT
	.WORD	0
10$:	.ADDR	#BLK0,R3
	MOV	R3,RDBUF
	EMT	375
	MOV	(SP)+,R0
	BCS	SET.NOR
SET.EX: TST	R2
	BEQ	SET.NOR
	DEC	R2
	BEQ	SET.ERR
	ADD	#2,(SP)
SET.ERR:SEC
SET.NOR:RTS	PC
	.DSABL	LSB
SET.END:
	OSIZ ==: SET.END - GETOVR
	.ASSUME	. LE 1000
.SBTTL	DATA ALLOCATION
	.NLIST	BEX
	.ENABLE LC,LSB
	.DRBEG	DU
	DUBASE	=: DUSTRT + 6
	BR	ACROSS
STATU$::.WORD	0
ACROSS:	MOV	DUCQE,R5
.IF NE MMG$T
	MOV	@#KISAR1,R1
	.P1EXT	P1HIGH
	JMP	@#BEGIN
	$REL	.-2 BEGIN DUX
	.P1END
.IFF
	JMP	BEGIN
.ENDC
	.DSABL	LSB
.IF NE DU$PORTS-1
	.DRVTB	DU,DU$VEC,DUINT
	.DRVTB	,DU$VC1,DUINT
 .IF NE DU$PORTS-2
	.DRVTB	,DU$VC2,DUINT
  .IF NE DU$PORTS-3
	.DRVTB	,DU$VC3,DUINT
  .ENDC
 .ENDC
.ENDC
UDAIP::	.WORD	DU$CSR
UDASA::	.WORD	DU$CSR+2
ISTEP:	.WORD	0
INISEQ:	.WORD	0
INILST:	.BYTE	DU$VEC/4!IE
	.BYTE	0*10+0+STEP
MRPTR:	.WORD	0
	.WORD	0
	.WORD	GO
INTRID:	.BLKW	2
MRING:	.WORD	0,0
CRING:	.WORD	0,0
.IF NE ERL$G
$SUCS:	.WORD	0
.ENDC
$RETRY:	.WORD	NRETRY
.IF NE MMG$T
PHYSH:	.WORD	0
PHYSL:	.WORD	0
.ENDC
.UTTAB:	.WORD 0
UTTAB:	.ASSUME UT.UNIT EQ 0
	.ASSUME UT.PART EQ 2
	.ASSUME UT.PORT EQ 3
	.WORD	0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0
.IF NE DU$PORTS-1
.PCTAB:	.WORD 0
PCTAB:	.ASSUME PC.AIP EQ 0
	.ASSUME PC.ASA EQ 2
	.ASSUME PC.STEP EQ 4
	.ASSUME PC.VEC EQ 6
	.WORD DU$CSR,DU$CSR+2
	.WORD 0,DU$VEC/4!IE
	.WORD DU$CS1,DU$CS1+2
	.WORD 0,DU$VC1/4!IE
 .IF NE DU$PORTS-2
	.WORD DU$CS2,DU$CS2+2
	.WORD 0,DU$VC2/4!IE
  .IF NE DU$PORTS-3
	.WORD DU$CS3,DU$CS3+2
	.WORD 0,DU$VC3/4!IE
					  .ASSUME DU$PORTS LE 4
  .ENDC
 .ENDC
.ENDC
	LOWDATA ==: . - UDAIP
	.ASSUME . LE DUSTRT+1000
			DUXPSECT
.IF NE MMG$T
XUDAIP::.WORD	DU$CSR
XUDASA::.WORD	DU$CSR+2
XISTEP:	.WORD	0
XINISE:	.WORD	0
XINILS:	.BYTE	DU$VEC/4!IE
	.BYTE	0*10+0+STEP
XMRPTR:	.WORD	0
	.WORD	0
	.WORD	GO
XINTRI: .BLKW	2
XMRING:	.WORD	0,0
XCRING:	.WORD	0,0
.IF NE ERL$G
X$SUCS:	.WORD	0
.ENDC
X$RETR:	.WORD	NRETRY
XPHYSH:	.WORD	0
XPHYSL:	.WORD	0
X.UTTA:	.WORD 0
XUTTAB:
	.WORD	0,0,1,0,2,0,3,0,4,0,5,0,6,0,7,0
.IF NE DU$PORTS-1
X.PCTA:	.WORD 0
XPCTAB:
	.WORD DU$CSR,DU$CSR+2
	.WORD 0,DU$VEC/4!IE
	.WORD DU$CS1,DU$CS1+2
	.WORD 0,DU$VC1/4!IE
 .IF NE DU$PORTS-2
	.WORD DU$CS2,DU$CS2+2
	.WORD 0,DU$VC2/4!IE
  .IF NE DU$PORTS-3
	.WORD DU$CS3,DU$CS3+2
	.WORD 0,DU$VC3/4!IE
  .ENDC
 .ENDC
.ENDC
.ENDC
LN.CMD:	.WORD	P.CSIZ
VC.CMD:	.WORD	0
CBUFF:	.BLKB	P.CSIZ
LN.RSP:	.WORD	0
VC.RSP:	.WORD	0
MBUFF:	.BLKB	P.MSIZ
	DUPSECT
.IF NE MMG$T
P1HIGH:	.WORD	0
$P1EXT:	.WORD	0
.ENDC
	DUXPSECT
RETRY:	.WORD	0
VOLSIZE:.WORD	0,0
NEXT:	.WORD	0
.IF NE MMG$T
P1LOW:	.WORD	0
.IF NE ERL$G
H$ELPT:	.WORD	0
.ENDC
H$PTWR:	.WORD	0
H$MPPT:	.WORD	0
H$GTBY:	.WORD	0
H$P1EX: .WORD	0
H$CQE:	.WORD	0
.ENDC
.IF NE DU$PORTS-1
ACTPORT:.WORD  -1
.ENDC
INTEOP:	.WORD	0
.IF NE DU$BBR
BBRON:	.WORD	0
.ENDC
	DUPSECT
DUFBLK:	.WORD	0,0,0,0
.IF NE ERL$G
ERLBUF:	.BLKB	P.MSIZ
.ENDC
	DUXPSECT
.IF NE DU$BBR
    .IF NE DU$PORTS
ACTBBR:	.WORD 0
BBRTAB:	.ASSUME BB.STS EQ 0
	.ASSUME BB.MAX EQ 2
	.ASSUME BB.RCT EQ 6
	.ASSUME BB.TRK EQ 10
	.ASSUME BB.RBN EQ 12
	.ASSUME BB.COP EQ 13
	.WORD	0
	.BLKW	5
      .IF NE DU$PORTS-1
	.WORD	0
	.BLKW	5
       .IF NE DU$PORTS-2
	.WORD 	0
	.BLKW	5
        .IF NE DU$PORTS-3
	.WORD	0
	.BLKW	5
					  .ASSUME DU$PORTS LE 4
        .ENDC
       .ENDC
     .ENDC
  .ENDC
	.SBTTL	BBR data structures and definitions
LBN:	.BLKW	400
SEC0: 	.BLKW	400
	VSN0 =:	0
	VSN1 =:	VSN0+2
	VSN2 =:	VSN1+2
	VSN3 =:	VSN2+2
	RCTFLG ==: VSN3+2
		RF.WB=:1
		RF.FE=:200
		RF.BR=:20000
		RF.P2=:40000
		RF.P1=:100000
	RLBNL=:	RCTFLG+4
	RLBNH=:	RLBNL+2
	URBNL=:	RLBNH+2
	URBNH=:	URBNL+2
	RRBNL=:	URBNH+2
	RRBNH=:	RRBNL+2
	CID0=:	RRBNH+2
	CID1=:	CID0+2
	CID2=:	CID1+2
	CID3=:	CID2+2
	CIN0=:	CID3+2
	CIN1=:	CIN0+2
RCTBF:	.BLKW	400
RCTB1:	.BLKW	400
XFRSZ:	.BLKW	1
LBNH:	.BLKW	1
LBNL:	.BLKW	1
RPLBL: 	.BLKW	1
RPLBH:	.BLKW	1
DSKBF:	.BLKW	1
IOMOD:	.BLKW	1
UNIT:	.BLKW	1
IOFUN:	.BLKW	1
DF.SEC	=:	010000
DF.ALL	=:	020000
DF.UNU	=:	040000
DF.NUL	=:	100000
OOPS:	.BLKW	1
USTAT:	.BLKW	1
	US.OLP	=:  1
IOST:	.BLKW	2
DPHYSL:	.BLKW	1
DPHYSH:	.BLKW	1
BBRECU:	.BLKW	1
BLBNL:	.BLKW	1
BLBNH:	.BLKW	1
PLBNL:	.BLKW	1
PLBNH:	.BLKW	1
PLBNO:	.BLKW	1
RCTSZ:	.BLKW	1
TRKSZ:	.BLKW	1
RBNPT:	.BLKB	1
RCTCP:	.BLKB	1
MXLBN:	.BLKW	2
NRBNL:	.BLKW	1
NRBNH:	.BLKW	1
NLBNL:	.BLKW	1
NLBNH:	.BLKW	1
NLBNO:	.BLKW	1
ORBNL:	.BLKW	1
ORBNH:	.BLKW	1
OLBNL:	.BLKW	1
OLBNH:	.BLKW	1
OLBNO:	.BLKW	1
OLDSTA:	.BLKW	1
WRKSIZ	==:      OLDSTA+2-XFRSZ
.ENDC
.SBTTL **********************************
.SBTTL EXECUTABLE CODE BEGINS		*
.SBTTL **********************************
BEGIN::
.IF EQ MMG$T
	MOV	$RETRY,RETRY
.IFF
	MOV	2(SP),SP
	ADD	#6,SP
	MOV	R5,H$CQE
	MOV	R1,P1LOW
	MOV	X$RETRY,RETRY
.ENDC
	CLR	INTEOP
.IF NE DU$BBR
	CLR	BBRON
.ENDC
	CMPB	Q$FUNC(R5),#SP.DAT
	BNE	10$
	JMP	DOTAB
10$:	MOVB	Q$UNIT(R5),R3
	BIC	#^C<7>,R3
	ASL	R3
	ASL	R3
					  .ASSUME UT.ESZ EQ 4
.IF EQ MMG$T
	.ADDR	#UTTAB,R3,ADD
	MOV	R3,.UTTAB
.IFF
	ADD	#XUTTAB,R3
	$REL .-2 XUTTAB DUX
	MOV	R3,X.UTTAB
.ENDC
.IF NE DU$PORTS-1
	MOVB	UT.PORT(R3),R2
	BPL	30$
	JMP	DUHERR
30$:	MOV	R2,R3
	ASL	R2
	ASL	R2
	ASL	R2
					  .ASSUME PC.ESZ EQ 10
.IF EQ MMG$T
	.ADDR	#PCTAB,R2,ADD
	MOV	R2,.PCTAB
.IFF
	ADD	#XPCTAB,R2
	$REL .-2 XPCTAB DUX
	MOV	R2,X.PCTAB
.ENDC
	CMP	R3,ACTPORT
	BEQ	NOSW
	MOV	R3,ACTPORT
.IF EQ MMG$T
	.ADDR	#UDAIP,R4
.IFF
	MOV	#XUDAIP,R4
	$REL .-2 XUDAIP DUX
.ENDC
	MOV	(R2)+,(R4)+
					  .ASSUME PC.AIP EQ 0
	MOV	(R2)+,(R4)+
					  .ASSUME PC.ASA EQ 2
	MOV	(R2)+,(R4)+
					  .ASSUME PC.STEP EQ 4
.IF EQ MMG$T
	MOVB	(R2),INILST
					  .ASSUME PC.VEC EQ 6
.IFF
	MOVB	(R2),XINILST
.ENDC
.ENDC
NOSW:
.IF NE DU$BBR
   .IF NE DU$PORTS-1
	MOV	ACTPORT,R1
   .IFF
	CLR	R1
   .ENDC
	ASL	R1
	ASL	R1
	MOV	R1,-(SP)
	ASL	R1
	ASL	R1
	SUB	(SP)+,R1
				.ASSUME BB.SIZ EQ 14
	ADD	#BBRTAB,R1
	$REL .-2 BBRTAB DUX
	MOV	R1,ACTBBR
.ENDC
	.BR	START
.SBTTL	PORT INITIALIZATION CODE
	.ENABL	LSB
START:	CLR	R5
.IF EQ MMG$T
	TST	ISTEP
.IFF
	TST	XISTEP
.ENDC
	BPL	INIT
.IF EQ MMG$T
	BIT	#<IERROR!ISTEP1>,@UDASA
.IFF
	MOV	#XUDASA,R5
	$REL .-2 XUDASA DUX
	BIT	#<IERROR!ISTEP1>,@(R5)
.ENDC
	BNE	INIT
	JMP	DISPAT
INIT:	MOV	#100000,INITFL
	DEC	RETRY
	BGE	10$
HARDEX:	JMP	DUHERR
10$:
.IF NE MMG$T
	MOV	#XUDAIP,R5
	$REL .-2 XUDAIP DUX
	MOV	R5,@(R5)
	MOV	#XISTEP,R4
	$REL .-2 XISTEP DUX
.IFF
	MOV	R5,@UDAIP
	.ADDR	#ISTEP,R4
.ENDC
	MOV	#ISTEP1,(R4)+
	MOV	R4,@R4
.IF EQ MMG$T
	CMP	(R4)+,(R4)+
	MOV	R4,@R4
	ADD	#MRING-MRPTR,@R4
.ENDC
INISTP:
.IF EQ MMG$T
	.ADDR	#UDASA,R4
.IFF
	MOV	#XUDASA,R4
	$REL .-2 XUDASA DUX
.ENDC
	MOV	@(R4)+,R5
	BMI	INIT
	BIT	R5,@R4
	BEQ	INISTP
	ASL	(R4)+
	ADD	#2,(R4)
.IF NE MMG$T
	MOV	#XUDASA,R5
	$REL .-2 XUDASA DUX
	MOV	@(R4),@(R5)
.IFF
	MOV	@(R4),@UDASA
.ENDC
	TST	-(R4)
					  .ASSUME ISTEP4*2 EQ 100000
.IF EQ DU$PORTS-1
	BMI	START
.IFF
	BPL	1$
  .IF NE MMG$T
	MOV	X.PCTAB,R5
  .IFF
	MOV	.PCTAB,R5
  .ENDC
	MOV	(R4),PC.STEP(R5)
	BR	START
.ENDC
1$:
.IF NE MMG$T
HRET:
	.HP1EX	P1LOW
	JMP	@#LRET1
	$REL .-2 LRET1 DUR
	.HP1EN
	DUPSECT
LRET1:
	MOV	2(SP),SP
	ADD	#6,SP
.ENDC
	RTS	PC
	.DSABL	LSB
.SBTTL	FUNCTION DISPATCH AREA
	.ENABL	LSB
	DUXPSECT
DISPAT:	ASL	(PC)+
INITFL:	 .WORD	0
	BCC	5$
	DO	SETTMO,THEN,BRINON
BRINON:
.IF EQ	DU$BBR
	DO	IONLIN,THEN,DISPAT
.IFF
	DO 	IONLIN,THEN,GETUS
.ENDC
5$:
.IF EQ	MMG$T
	MOV	DUCQE,R5
.IFF
	MOV	H$CQE,R5
.ENDC
	MOVB	Q$FUNC(R5),R4
	BNE	10$
.IF EQ ERL$G
.IF NE MMG$T
	CALL	BUSCHK
	BCS	HARDEX
.ENDC
	DO	IOXFER,THEN,DUEXIT
.IFF
.IF NE MMG$T
	CALL	BUSCHK
	BCS	HARDEX
.ENDC
	DO	IOXFER,THEN,LOGIT
.ENDC
10$:	CMPB	R4,#SP.BYP
	BNE	20$
15$:	DO	BYPASS,THEN,DUEXIT
20$:	CMPB	R4,#SP.MUC
	BEQ	15$
	CMPB	R4,#SP.VSZ
	BNE	45$
	DO	ONLINE,THEN,GETSIZ
45$:	CMPB	R4,#SP.WIO
	BLT	NOFUN
	BHI	50$
	NEG	Q$WCNT(R5)
50$:	MOV	#SPFUNB,(PC)+
SPCIO:	.WORD	0
.IF NE MMG$T
	MOV	Q$PAR(R5),(PC)+
SPPAR:	.WORD	0
.ENDC
	MOV	Q$BUFF(R5),(PC)+
SPBUFA:	.WORD	0
	ADD	#2,Q$BUFF(R5)
.IF NE MMG$T
	CMP	Q$BUFF(R5),#40000
	BLO	55$
	SUB	#20000,Q$BUFF(R5)
	ADD	#200,Q$PAR(R5)
	CALL	BUSCHK
	BCS	HARDEX
.ENDC
55$:	DO 	IOXFER,THEN,DUEXIT
NOFUN:	JMP	DUEXIT
	.DSABL	LSB
.SBTTL	COORD - Coordination routine for handler
COORD:	MOV	R5,R4
	ADD	(R5)+,R4
	MOV	R4,NEXT
	MOV	R5,R4
	ADD	(R5)+,R4
	MOV	(SP)+,R5
	JSR	PC,@R4
	.BR	POLL
.SBTTL	POLL - This routine starts the controller!
POLL:
.IF EQ MMG$T
	BIS	#OWN,CRING+2
	MOV	@UDAIP,R5
	BIS	#<OWN!FLAG>,MRING+2
.IFF
	BIS	#OWN,XCRING+2
	MOV	#XUDAIP,R5
	$REL .-2 XUDAIP DUX
	MOV	@(R5),R5
	BIS	#<OWN!FLAG>,XMRING+2
.ENDC
.IF EQ MMG$T
	RTS	PC
.IFF
	JMP	HRET
.ENDC
HINIST:	BR	INISTP
.SBTTL	INTERRUPT ENTRY POINT
	.ENABL	LSB
	DUPSECT
	.DRAST	DU,5
.IF NE MMG$T
	.P1EXT	P1HIGH
	CALL	@#INTEX
	$REL .-2 INTEX DUX
	.P1END
	JMP	FORKIT
.ENDC
	DUXPSECT
.IF NE MMG$T
INTEX:
	CLR	XINTRID
	CLR	XINTRID+2
	RETURN
	DUPSECT
FORKIT:
	.FORK	DUFBLK
	MOV	@#KISAR1,R1
	.P1EXT	P1HIGH
	JMP	@#INTEX2
	$REL .-2 INTEX2 DUX
	.P1END
	DUXPSECT
INTEX2:
	MOV	2(SP),SP
	ADD	#6,SP
	MOV	R1,P1LOW
	TST	XISTEP
.IFF
	CLR	INTRID
	CLR	INTRID+2
	.FORK	DUFBLK
	TST	ISTEP
.ENDC
	BGT	HINIST
.IF EQ MMG$T
	BIT	#<IERROR!ISTEP1>,@UDASA
.IFF
	MOV	#XUDASA,R5
	$REL .-2 XUDASA DUX
	BIT	#<IERROR!ISTEP1>,@(R5)
.ENDC
	BEQ	47$
	JMP	INIT
47$:
.IF NE DU$BBR
	TST	BBRON
	BPL	60$
	JMP	CONBBR
.ENDC
60$:	TST	INTEOP
	BPL	50$
	CLR	INTEOP
	BR	10$
50$:
.IF EQ	MMG$T
	MOV	DUCQE,R5
.IFF
	MOV	H$CQE,R5
.ENDC
	CMPB	#SP.BYP,Q$FUNC(R5)
	BNE	10$
	CMP	#1,(R5)
	BEQ	30$
	JMP	@NEXT
30$:
.IF NE MMG$T
	MOV	Q$PAR(R5),R1
	MOV	Q$BUFF(R5),R5
	ADD	#<4>,R5
	.HP1EX	R1
	MOV	P.STS(R5),R1
	MOV	R1,@#STATU$
	$REL .-2 STATU$ DUR
	MOVB	P.FLGS(R5),R2
	.HP1EN
	BR	40$
.ENDC
10$:
.IF NE MMG$T
	MOV	#MBUFF,R5
	$REL .-2 MBUFF DUX
.IFF
	MOV	MRING,R5
.IFTF
	MOV	P.STS(R5),R1
.IFF
	MOV	R1,STATU$
.IFT
	.HP1EX	P1LOW
	MOV	R1,@#STATU$
	$REL .-2 STATU$ DUR
	.HP1EN
.IFTF
	MOVB	P.FLGS(R5),R2
 	BIC	#^C<377>,R2
.ENDC
40$:
.IF NE DU$BBR
	BITB	R2,#EF.BBR
	BEQ	NOBBR
	JMP	BBFND
NOBBR:
.ENDC
	BIC	#^C<ST.MSK>,R1
					  .ASSUME ST.SUC EQ 0
	TST	R1
					  .ASSUME ST.SUC EQ 0
	BNE	20$
	JMP	@NEXT
20$:
	CMP	R1,#ST.AVL
.IF EQ ERL$G
	BNE	DUHERR
.IFF
	BEQ	48$
	JMP	BADIO
48$:
.ENDC
	DO	IONLIN,THEN,HSTART
HSTART:
.IIF NE	ERL$G, JSR PC,ERRLOG
	DEC	RETRY
	BLE	DUHERR
.IF EQ DU$BBR
	JMP	START
.IFF
	JMP	GETUS
.ENDC
	.DSABL	LSB
.SBTTL	NORMAL AND STANDARD EXITS
DUHERR:	TST	SPCIO
	BEQ	10$
	CALL	SPCERR
10$:
.IF EQ	MMG$T
	MOV	DUCQE,R5
.IFF
	MOV	H$CQE,R5
.ENDC
	BIS	#HDERR$,@-(R5)
	.BR	DUEXIT
	.ENABL	LSB
DUEXIT:	TST	SPCIO
	BEQ	10$
	CALL	SPCEXI
10$:
.IF NE MMG$T
	.HP1EX	P1LOW
	JMP	@#LRET2
	$REL .-2 LRET2 DUR
	.HP1EN
	DUPSECT
LRET2:
	MOV	2(SP),SP
	ADD	#6,SP
.ENDC
	.DRFIN	DU
	.DSABL	LSB
	.SBTTL	SPCEXI - SPECIAL ABSOLUTE READ/WRITE EXITS
	.ENABL	LSB
	DUXPSECT
SPCERR:	BITB	#EF.BBR,R2
	BEQ	20$
	BIS	#SPBBR,SPCIO
	BR	SPCEXI
20$:	CMPB	#ST.DAT,R1
	BNE	10$
	BIS	#SPFERR,SPCIO
	BR	SPCEXI
10$:	BIS	#SPERR,SPCIO
SPCEXI:	MOV	SPBUFA,R2
.IF NE MMG$T
	MOV	H$CQE,R4
	MOV	R2,Q$BUFF(R4)
	MOV	SPPAR,Q$PAR(R4)
	MOV	SPCIO,-(SP)
	CALL	@H$PTWR
.IFF
	MOV	SPCIO,(R2)
.ENDC
	CLR	SPCIO
	RTS	PC
	.DSABL	LSB
.SBTTL	SETTMO	- Sets 'host timeout' period
SETTMO:	MOV	#-1,INTEOP
	MSCP	OP.SCC
	MOV	#TO.MIN*60.,P.HTMO(R4)
	RTS	PC
.SBTTL	ONLINE - Do online request for retry or sizing
IONLIN:	MOV	#-1,INTEOP
ONLINE:	MSCP	OP.ONL
	RTS	PC
.SBTTL	IGETUS - Do a GET UNIT STATUS request
IGETUS:
	MOV	#-1,INTEOP
	MSCP	OP.GUS
	RTS	PC
.SBTTL	SUBROUTINE TO INITIALIZE FOR I/O TRANSFERS
IOXFER:
	MSCP	OP.RD
	MOV	(R5),R1
	MOV	R1,P.LBN(R4)
.IF EQ MMG$T
	MOV	Q$BUFF(R5),P.BUFF(R4)
.IFF
	ADD	#Q$BUFF,R5
	CALL	@H$MPPT
	MOV	(SP)+,P.BUFF(R4)
	MOV	(SP)+,R0
	ASH	#-4,R0
	MOVB	R0,P.BUFF+2(R4)
	MOV	H$CQE,R5
.ENDC
	TST	SPCIO
	BEQ	30$
	SUB	#2,Q$BUFF(R5)
30$:	MOV	Q$WCNT(R5),R0
	BPL	1$
	NEG	R0
	INCB	P.OPCD(R4)
					  .ASSUME OP.WR EQ OP.RD+1
1$:	MOV	R0,-(SP)
	ADD	#255.,R0
	BICB	#377,R0
	SWAB	R0
	ADD	R0,R1
	BCC	2$
	TST	R1
	BEQ	2$
	SUB	R1,R0
	SWAB	R0
	TST	(SP)+
	BIS	#HDERR$,@-(R5)
	BR	3$
2$:	MOV	(SP)+,R0
3$:	ASL	R0
	MOV	R0,P.BCNT(R4)
.IF EQ MMG$T
	MOV	.UTTAB,R5
.IFF
	MOV	X.UTTAB,R5
.ENDC
	MOVB	UT.PART(R5),P.PART(R4)
	RTS	PC
.IF NE MMG$T
	.SBTTL	BUSCHK - Check DMA limits for a given bus
	.ENABL	LSB
BUSCHK:
	MOV	R5,-(SP)
	MOV	@#SYSPTR,R3
	BIT	#QBUS$,CONFG2(R3)
	BNE	20$
	MOV	H$CQE,R5
	ADD	#Q$BUFF,R5
	CALL	@H$MPPT
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	ASH	#-4,R2
	MOV	(R5)+,-(SP)
	BPL	10$
	NEG	(SP)
10$:	ASL	(SP)
	ADD	(SP)+,R1
	ADC	R2
	BIC	#<^B11>,R2
	BNE	30$
20$:	TST	(PC)+
30$:	SEC
	MOV	(SP)+,R5
	RETURN
	.DSABL	LSB
.ENDC
.IF NE ERL$G
.SBTTL	ERROR LOGGING SUPPORT ROUTINES
LOGIT:
.IF EQ MMG$T
	TST	$SUCS
.IFF
	TST	X$SUCS
.ENDC
	BNE	44$
	CLR     RETRY
	JSR	PC,ERRLOG
44$:	JMP	DUEXIT
BADIO:	MOV	#1,RETRY
	JSR	PC,ERRLOG
	JMP	DUHERR
ERRLOG:
.IF EQ MMG$T
	.ADDR	#MBUFF,R2
.IFF
	MOV	@#KISAR1,R1
	MOV	#MBUFF,R2
	$REL .-2 MBUFF DUX
	MOV	#ERLBUF,R4
	$REL .-2 ERLBUF DUR
	MOV	R4,R3
	BIC	#^C<77>,R4
	ADD	#BEGREL,R4
	ASH	#-6,R3
	BIC	#^C<1777>,R3
	MOV	#P.MSIZ/2,R5
	MOV	H$P1EX,R0
	CALL	BLKMOV(R0)
	MOV	#ERLBUF,R2
	$REL .-2 ERLBUF DUR
.ENDC
	ADD	#P.UNIT,R2
.IF EQ	MMG$T
	MOV	DUCQE,R5
.IFF
	MOV	H$CQE,R5
.ENDC
	MOV	RETRY,R4
	ADD	#DU$COD*400-1,R4
	MOV	#NRETRY*400+20.,R3
.IF EQ MMG$T
	CALL	@$ELPTR
.IFF
	CALL	@H$ELPT
.ENDC
	RTS	PC
.ENDC
.SBTTL	ROUTINE TO RETURN THE VOLUME SIZE (SPFUN 373)
GETSIZ:
	MOV	P.UNSZ(R5),VOLSIZE
	MOV	P.UNSZ+2(R5),VOLSIZE+2
	.BR	SNDSIZ
SNDSIZ:
.IF EQ	MMG$T
	MOV	DUCQE,R4
	MOV	.UTTAB,R5
.IFF
	MOV	H$CQE,R4
	MOV	X.UTTAB,R5
.ENDC
	MOV	VOLSIZE,-(SP)
	BNE	5$
	DEC	(SP)
5$:	TST	VOLSIZE+2
	BEQ	10$
	CMPB	UT.PART(R5),VOLSIZ+2
	BGE	10$
	MOV	#177777,(SP)
10$:
.IF NE MMG$T
	JSR	PC,@H$PTWR
.IFF
	MOV	(SP)+,@Q$BUFF(R4)
.ENDC
	JMP	DUEXIT
.SBTTL	SUBROUTINE TO INITIALIZE MSCP COMMAND BUFFER
GETCBF:
	MOV	R0,-(SP)
	MOV	R1,-(SP)
.IF EQ MMG$T
	.ADDR	#MBUFF,R4
	MOV	R4,MRING
	CLR	MRING+2
.IFF
	MOV	XPHYSL,R0
	MOV	XPHYSH,R1
	ADD	#MBUFF-DUXBASE,R0
	ADC	R1
	MOV	R0,XMRING
	MOV	R1,XMRING+2
	MOV	#MBUFF,R4
	$REL .-2 MBUFF DUX
.IFTF
	MOV	#P.CSIZ/2,-(SP)
					  .ASSUME MBUFF EQ CBUFF+P.CSIZ+4
1$:	CLR	-(R4)
	DEC	(SP)
	BPL	1$
	SUB	(SP)+,-(R4)
	MOV	#60,-4(R4)
	MOV	#60,P.CSIZ(R4)
.IFT
	MOV	R4,CRING
	CLR	CRING+2
.IFF
	MOV	XPHYSL,R0
	MOV	XPHYSH,R1
	ADD	#CBUFF-DUXBASE,R0
	ADC	R1
	MOV	R0,XCRING
	MOV	R1,XCRING+2
.IFTF
	MOV	(R5)+,P.OPCD(R4)
.IFT
	MOV	@.UTTAB,P.UNIT(R4)
					  .ASSUME UT.UNIT EQ 0
.IFF
	MOV	#X.UTTAB,R1
	$REL .-2 X.UTTAB DUX
	MOV	@(R1),P.UNIT(R4)
.IFTF
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	R5
.ENDC
.SBTTL	SUBROUTINE TO BYPASS RT-11 AND ISSUE MSCP DIRECTLY
	.ENABL	LSB
BYPASS:	ADD	#Q$BUFF-Q$BLKN,R5
.IF EQ MMG$T
	MOV	(R5)+,R4
	CLR	R0
.IFF
	CALL	@H$MPPT
	MOV	(SP)+,R4
	MOV	(SP)+,R0
	ASH	#-4,R0
.ENDC
	ADD	#4,R4
	ADC	R0
.IF EQ MMG$T
	MOV	R4,MRING
	MOV	R0,MRING+2
.IFF
	MOV	R4,XMRING
	MOV	R0,XMRING+2
.ENDC
	.IF EQ MMG$T
	BNE	30$
	.ENDC
	ADD	#P.MSIZ+4,R4
	ADC	R0
.IF EQ MMG$T
	MOV	R4,CRING
	MOV	R0,CRING+2
.IFF
	MOV	R4,XCRING
	MOV	R0,XCRING+2
.ENDC
	.IF EQ MMG$T
	BNE	30$
	.ENDC
	MOV	(R5),R0
	BEQ	20$
	.IF EQ MMG$T
	CLR	R1
	MOV	R0,R2
	.IFF
	MOV	H$P1EX,R1
	CALL	CVAPHY(R1)
	.ENDC
	MOV	Q$BUFF-Q$WCNT(R5),R4
	ADD	#<4+P.MSIZ+4>+P.BUFF,R4
	.IF NE MMG$T
	MOV	Q$PAR-Q$WCNT(R5),10$
	JSR	R0,@H$P1EX
	 .WORD	10$-.
	.ENDC
	MOV	R2,(R4)+
	MOV	R1,(R4)+
	.IF NE MMG$T
10$:	 .BLKW
	.ENDC
20$:	RTS	PC
	.IF EQ MMG$T
30$:	TST	(SP)+
	JMP	DUHERR
	.ENDC
	.DSABL	LSB
.SBTTL	ROUTINE TO RETURN THE UNIT TRANSLATION TABLE
	.ENABL	LSB
DOTAB:	MOV	R0,-(SP)
	MOV	#UT.ESZ/2*8.,R0
	MOV	R5,R4
.IF EQ MMG$T
	.ADDR	#UTTAB,R5
.IFF
	MOV	#XUTTAB,R5
	$REL .-2 XUTTAB DUX
.ENDC
	TST	Q$WCNT(R4)
	BMI	20$
10$:
	.IF EQ MMG$T
	MOV	(R5)+,@Q$BUFF(R4)
	ADD	#2,Q$BUFF(R4)
	.IFF
	MOV	(R5)+,-(SP)
	CALL	@H$PTWRD
	.ENDC
	DEC	R0
	BGT	10$
	BR	40$
20$:	ASL	R0
	.IF EQ MMG$T
30$:	MOVB	@Q$BUFF(R4),(R5)+
	INC	Q$BUFF(R4)
	.IFF
30$:
	JSR	PC,@H$GTBY
	MOVB	(SP)+,(R5)+
	.ENDC
	DEC	R0
	BGT	30$
40$:	MOV	(SP)+,R0
	JMP	DUEXIT
	.DSABL	LSB
.IF NE DU$BBR
	.SBTTL	GETUS - Save information necessary for BBR support
GETUS:
	MOV	#MBUFF,R5
	$REL .-2 MBUFF DUX
	MOV	ACTBBR,R1
	MOV	P.UNFL(R5),(R1)+
	BPL	10$
	JMP	DISPAT
10$:	MOV	P.UNSZ(R5),(R1)+
					.ASSUME BB.MAX EQ 2
	MOV	P.UNSZ+2(R5),(R1)+
	DO	IGETUS,THEN,SAVUS
SAVUS:
	MOV	#MBUFF,R5
	$REL .-2 MBUFF DUX
	MOV	ACTBBR,R1
	ADD	#BB.RCT,R1
	MOV	P.RCTS(R5),(R1)+
					.ASSUME BB.RCT EQ 6
	MOV	P.TRCK(R5),(R1)+
					.ASSUME BB.TRK EQ 10
	MOV	P.RBNS(R5),@R1
					.ASSUME BB.RBN EQ 12
					.ASSUME BB.COP EQ 13
	BIT	#UF.WPH,P.UNFL(R5)
	BEQ	ONLBBR
	JMP	DISPAT
.ENDC
.IF NE DU$BBR
	.SBTTL	BBR - Host Bad Block Replacement Main Entry points
	.ENABL	LSB
BBFND:
	MOV	ACTBBR,R2
	TST	@R2
	BMI	20$
	CALL	CLRWRK
	MOV	MBUFF+P.FBBK,BLBNL
	MOV	MBUFF+P.FBBK+2,BLBNH
	.HP1EX	P1LOW
	MOV	@#STATU$,R1
	$REL .-2 STATU$ DUR
	.HP1EN
	MOV	R1,OLDSTA
	DO 	IGETUS,THEN,CKWRTP
CKWRTP:
	MOV	ACTBBR,R2
	MOV	MBUFF+P.UNFL,R5
	MOV	OLDSTA,R4
	BIT	#UF.WPH,R5
	BEQ	CONBBR
	MOV	R4,R1
20$:	JMP	NOBBR
ONLBBR:
	MOV	ACTBBR,R2
	CALL	CLRWRK
	BIS	#US.OLP,USTAT
	.BR	CONBBR
CONBBR:
	MOV	SP,(PC)+
SAVESP:	.WORD	0
	CALL	RCONTX
10$:	BR	DOBBR
	.DSABL	LSB
CLRWRK:	MOV	#XFRSZ,R3
	$REL .-2 XFRSZ DUX
	MOV	#WRKSIZ,R4
	ASR	R4
10$:	CLR	(R3)+
	DEC	R4
	BNE	10$
	RTS	PC
.ENDC
.IF NE DU$BBR
	.SBTTL	DOBBR - Main Host BBR algorithm
DOBBR:
	MOV	#SEC0,DSKBF
	$REL .-4 SEC0 DUX
	MOV	BB.MAX(R2),LBNL
	MOV	BB.MAX+2(R2),LBNH
	CALL	MULRD
	BCC	20$
	JMP	VERXIT
20$:
	BIT	#US.OLP,USTAT
	BEQ	READIT
	.ENABL	LSB
	MOV	#SEC0,R0
	$REL .-2 SEC0 DUX
	ADD	#RCTFLG,R0
	BIT	#<RF.P1!RF.P2>,(R0)
	BEQ	40$
	MOV	#LBN,DSKBF
	$REL .-4 LBN DUX
	MOV	BB.MAX(R2),LBNL
	MOV	BB.MAX+2(R2),LBNH
	ADD	#1,LBNL
	ADC	LBNH
	CALL	MULRD
	BCC	10$
	JMP	VERXIT
10$:
	BIT	#RF.P1,(R0)
	BEQ	30$
	CALL	P1REC
	BR	RTEST
30$:	BIT	#RF.P2,(R0)
	BEQ	40$
	CALL	P2REC
	JMP	RCTUPD
40$:	JMP	COMXIT
	.DSABL	LSB
READIT:
	.ENABL	LSB
	MOV	#4,R4
30$:	MOV	#LBN,R3
	$REL .-2 LBN DUX
	MOV	R3,DSKBF
	MOV	#256.,R0
10$:	CLR	(R3)+
	DEC	R0
	BNE	10$
	MOV	BLBNL,LBNL
	MOV	BLBNH,LBNH
	MOV	#OP.RD,IOFUN
	CLR	IOMOD
	CALL	DSKIO
	BCC	20$
	BITB	#ST.DAT,IOST
	BEQ	20$
	DEC	R4
	BNE	30$
	BIS	#RF.FE,SEC0+RCTFLG
20$:	MOV	BB.MAX(R2),LBNL
	MOV	BB.MAX+2(R2),LBNH
	ADD	#1,LBNL
	ADC	LBNH
	CALL	MULWT
	BIS	#RF.P1,SEC0+RCTFLG
	BCC	PHASE1
	JMP	VERXIT
	.DSABL	LSB
PHASE1:
	MOV	#SEC0,R0
	$REL .-2 SEC0 DUX
	ADD	#RCTFLG,R0
	CMP	(R0)+,(R0)+
	MOV	BLBNL,(R0)+
	MOV	BLBNH,(R0)+
	MOV	#SEC0,DSKBF
	$REL .-4 SEC0 DUX
	MOV	BB.MAX(R2),LBNL
	MOV	BB.MAX+2(R2),LBNH
	CALL	MULWT
	BCC	ALLOUT
	JMP	VERXIT
	.ENABL	LSB
ALLOUT:	MOV	#8.,R5
RTEST:	MOV	#4,R4
10$:	MOV	#RCTBF,DSKBF
	$REL .-4 RCTBF DUX
	MOV	#OP.RD,IOFUN
	MOV	#<MD.CMP!MD.SEC!MD.SER>,IOMOD
	MOV	BLBNL,LBNL
	MOV	BLBNH,LBNH
	CALL	DSKIO
	BCS	SCAN
	DEC	R4
	BNE	10$
RWTEST:	MOV	#OP.WR,IOFUN
	MOV	#LBN,DSKBF
	$REL .-4 LBN DUX
	MOV	#MD.CMP,IOMOD
	CALL	DSKIO
	BCS	SCAN
	MOV	#4,R4
20$:	MOV	#OP.RD,IOFUN
	MOV	#RCTBF,DSKBF
	$REL .-4 RCTBF DUX
	CALL	DSKIO
	BCS	SCAN
	DEC	R4
	BNE	20$
TSTPAT:
	MOV	#256.,R4
	MOV	#RCTBF,R0
	$REL .-2 RCTBF DUX
	MOV	#LBN,R3
	$REL .-2 LBN DUX
30$:	MOV	(R3)+,@R0
	COM	(R0)+
	DEC	R4
	BNE	30$
	MOV	#OP.WR,IOFUN
	MOV	#<MD.CMP!MD.ERR!MD.SEC!MD.SER>,IOMOD
	CALL	DSKIO
	BCS	SCAN
	MOV	#4,R4
40$:	MOV	#OP.RD,IOFUN
	CALL	DSKIO
	BCS	SCAN
	DEC	R4
	BNE	40$
	DEC	R5
	BNE	RTEST
	.DSABL	LSB
RESDAT:
	CALL	WTSAV
	BCS	SCAN
	JMP	NOREP
SCAN:
	CALL	WTSAV
	CALL	HASH
SCAN1:
	INC	BBRECU
	CMP	#2,BBRECU
	BEQ	10$
	CALL	SRCH
	BCC	PHASE2
10$:	JMP	SAVXIT
PHASE2:
	BIC	#RF.P1,SEC0+RCTFLG
	BIS	#RF.P2,SEC0+RCTFLG
	MOV	#SEC0,R0
	$REL .-2 SEC0 DUX
	ADD	#URBNL,R0
	MOV	NRBNL,(R0)+
	MOV	NRBNH,(R0)+
	MOV	ORBNL,(R0)+
	MOV	ORBNH,(R0)
	MOV	#SEC0,DSKBF
	$REL .-4 SEC0 DUX
	MOV	BB.MAX(R2),LBNL
	MOV	BB.MAX+2(R2),LBNH
	CALL	MULWT
	BCC	RCTUPD
	JMP	VERXIT
RCTUPD:
	CALL	NEWBF
	MOV	R0,DSKBF
	CALL	MULRD
	BCS	25$
	MOV	R0,R3
	ADD	NLBNO,R3
	MOV	BLBNL,(R3)+
	MOV	BLBNH,(R3)
	BIC	#170000,(R3)
	BIS	#DF.ALL,(R3)
	CMP	PLBNO,NLBNO
	BNE	10$
	CMP	PLBNL,NLBNL
	BNE	10$
	CMP	PLBNH,NLBNH
	BEQ	15$
10$:	BIS	#DF.SEC,(R3)
15$:	BIT	#RF.BR,SEC0+RCTFLG
	BEQ	40$
	CMP	OLBNL,NLBNL
	BNE	20$
	CMP	OLBNH,NLBNH
	BEQ	30$
20$:	CALL	OLDBF
	MOV	R0,DSKBF
	CALL	MULRD
25$:	BCS	HSAVXIT
30$:	MOV	R0,R3
	ADD	OLBNO,R3
	MOV	#DF.UNU,2(R3)
	CLR	(R3)
	MOV	R0,DSKBF
	CALL	MULWT
	BCS	UNAXIT
	CMP	OLBNL,NLBNL
	BNE	40$
	CMP	OLBNH,NLBNH
	BEQ	REPLBN
40$:	CALL	NEWBF
	MOV	R0,DSKBF
	CALL	MULWT
	BCS	UNAXIT
REPLBN:
	MOV	#OP.RPL,IOFUN
	MOV	NRBNH,RPLBH
	MOV	NRBNL,RPLBL
	MOV	BLBNH,LBNH
	MOV	BLBNL,LBNL
	CLR	IOMOD
	CMP	PLBNO,NLBNO
	BNE	10$
	CMP	PLBNL,NLBNL
	BNE	10$
	CMP	PLBNH,NLBNH
	BNE	10$
	MOV	#MD.PRI,IOMOD
10$:	CALL	GENIO
	BCS	RPLERR
	MOV	#OP.RD,IOFUN
	MOV	#RCTBF,DSKBF
	$REL .-4 RCTBF DUX
	MOV	#MD.CMP,IOMOD
	CALL	DSKIO
	BCC	RPLERR
	CMPB	#ST.DAT,IOST
	BNE	RPLERR
	CALL	WTSAV
	BCC	FINSZ
	JMP	SCAN1
HSAVXI:	BR	SAVXIT
RPLERR:	CALL	FFINSZ
	MOVB	#-2,IOST
	BR	VERXIT
NOREP:	MOV	#-1,OOPS
FINSZ:	CALL	FFINSZ
	BCS	VERXIT
	BR	COMXIT
UNAXIT:
	CALL	UNALL
SAVXIT:
	CALL	WTSAV
	CALL	FFINSZ
VERXIT:
	TSTB	IOST
	BNE	10$
	MOVB	#-1,IOST
10$:
	BIT	#US.OLP,USTAT
	BNE	COMXIT
	JMP	DUHERR
COMXIT:
.IIF NE DU$ERL	CALL	$ERPKT
COMXT1:	CLR	USTAT
	CLR	OOPS
	JMP	START
.ENDC
.IF NE DU$BBR
	.SBTTL 	BBRSUB - BBR subroutines
.SBTTL	DSKIO - INITIATE DISK I/O ROUTINE
DSKIO::
	MOV	#512.,XFRSZ
GENIO:	PUSH	<R5,R4,R3,R2,R1,R0>
	MOV	XPHYSL,R4
	MOV	XPHYSH,R5
	MOV	DSKBF,R0
	SUB	#BEGREL,R0
	ADD	R0,R4
	ADC	R5
	MOV	R4,DPHYSL
	MOV	R5,DPHYSH
	MSCP	OP.NIL
	MOV	#X.UTTAB,R1
	$REL .-2 X.UTTAB DUX
	MOV	@(R1),P.UNIT(R4)
	MOV	IOFUN,P.OPCD(R4)
	MOV	IOMOD,P.MOD(R4)
	CMP	#OP.RPL,P.OPCD(R4)
	BEQ	20$
	MOV	LBNH,P.LBN+2(R4)
	MOV	LBNL,P.LBN(R4)
	MOV	XFRSZ,P.BCNT(R4)
	MOV	DPHYSH,P.BUFF+2(R4)
	MOV	DPHYSL,P.BUFF(R4)
	BR	30$
20$:	MOV	RPLBH,P.RBN+2(R4)
	MOV	RPLBL,P.RBN(R4)
	MOV	LBNH,P.LBN+2(R4)
	MOV	LBNL,P.LBN(R4)
30$:	CALL	SCONTX
	MOV	#MBUFF,R4
	$REL .-2 MBUFF DUX
	MOV	P.STS(R4),-(SP)
	MOVB	P.FLGS(R4),-(SP)
	BIT	#MD.ERR,IOMOD
	BEQ	35$
	BIC	#ST.DAT,2(SP)
35$:	CLC
	MOVB	(SP)+,IOST+1
	MOV	(SP),IOST+2
	BIC	#^C<ST.MSK>,(SP)
	MOVB	(SP)+,IOST
	BEQ	50$
40$:	SEC
50$:	POP	<R0,R1,R2,R3,R4,R5>
	RETURN
.ENDC
.IF NE DU$BBR
.SBTTL	FFINSZ - UPDATE TABLE SECTOR 0 TO SHOW RCT IS FINISHED
FFINSZ::
	MOV	#SEC0,R3
	$REL .-2 SEC0 DUX
	ADD	#RCTFLG,R3
	MOV	#8.,R4
10$:	CLR	(R3)+
	DEC	R4
	BNE	10$
	MOV	#SEC0,DSKBF
	$REL .-4 SEC0 DUX
	MOV	BB.MAX+2(R2),LBNH
	MOV	BB.MAX(R2),LBNL
	CALL	MULWT
	RETURN
.SBTTL	HASH  - PRIMARY REPLACEMENT CONTROL TABLE HASH ALGORITHM
HASH::
	PUSH	<R0,R1,R2,R3>
	MOV	R1,R4
	MOV	R2,R5
	MOV	BB.TRK(R5),R0
	MOV	BLBNH,R1
	MOV	BLBNL,R2
	CALL	DDIV
	MOV	R2,R3
	MOV	R1,R2
	CLR	R0
	BISB	BB.RBN(R5),R0
	CALL	DMUL
	MOV	R1,R2
	MOV	R0,R1
	MOV	#128.,R0
	CALL	DDIV
	ADD	BB.MAX(R5),R2
	ADC	R1
	ADD	BB.MAX+2(R5),R1
	ADD	#2,R2
	ADC	R1
	MOV	R2,PLBNL
	MOV	R1,PLBNH
	ASL	R0
	ASL	R0
	MOV	R0,PLBNO
	POP	<R3,R2,R1,R0>
	RETURN
.SBTTL	MULRD - PERFORM MULTIPLE-COPY READ FROM DISK
MULRD::
	PUSH	<LBNL,LBNH>
	PUSH	<R4,R0>
	MOV	BB.RCT(R2),R4
	CLR	R0
	BISB	BB.COP(R2),R0
	MOV	#OP.RD,IOFUN
	MOV	#MD.CMP,IOMOD
10$:	CALL	DSKIO
	BCC	30$
	ADD	R4,LBNL
	ADC	LBNH
	DEC	R0
	BNE	10$
	SEC
30$:	POP	<R0,R4>
	POP	<LBNH,LBNL>
	RETURN
.SBTTL	MULWT - PERFORM MULTIPLE-COPY WRITE TO DISK
MULWT::
	PUSH	<LBNL,LBNH>
	PUSH	<R0,R3,R4>
	MOV	BB.RCT(R2),R3
	CLR	R0
	BISB	BB.COP(R2),R0
	MOV	R0,R4
	MOV	#OP.WR,IOFUN
10$:	MOV	#MD.CMP,IOMOD
	CALL	DSKIO
	BCC	20$
	CMPB	IOST,#ST.DAT
	BNE	25$
	MOV	#MD.ERR,IOMOD
	CALL	DSKIO
	DEC	R4
20$:	ADD	R3,LBNL
	ADC	LBNH
	DEC	R0
	BNE	10$
	TST	R4
	BNE	30$
25$:	SEC
30$:	POP	<R4,R3,R0>
	POP	<LBNH,LBNL>
	RETURN
.SBTTL	NEWBF - SET QIO PARAMETERS FOR NEW RBN
.SBTTL	OLDBF - SET QIO PARAMETERS FOR OLD RBN
	.ENABL	LSB
NEWBF::
	MOV	#RCTBF,R0
	$REL .-2 RCTBF DUX
	MOV	NLBNL,LBNL
	MOV	NLBNH,LBNH
	BR	10$
OLDBF::
	MOV	#RCTB1,R0
	$REL .-2 RCTB1 DUX
	MOV	OLBNL,LBNL
	MOV	OLBNH,LBNH
10$:	MOV	R0,DSKBF
	RETURN
	.DSABL	LSB
.SBTTL	P1REC - RESTORE DATA FOR PHASE 1 RECOVERY
.SBTTL	P2REC - RESTORE DATA FOR PHASE 2 RECOVERY
P1REC::
	CMP	(R0)+,(R0)+
	MOV	(R0)+,BLBNL
	MOV	(R0)+,BLBNH
	CLRB	BLBNH+1
	CALL	HASH
	RETURN
P2REC::
	PUSH	<R1,R2,R3>
	CALL	P1REC
	MOV	#NRBNL,R3
	$REL .-2 NRBNL DUX
	MOV	(R0),(R3)+
	MOV	(R0)+,R2
	MOV	(R0),(R3)+
	MOV	(R0)+,R1
	PUSH	<R0>
	CALL	RBNDIV
	POP	<R0>
	MOV	(R0),(R3)+
	MOV	(R0)+,R2
	MOV	(R0),(R3)+
	MOV	(R0)+,R1
	BNE	10$
	TST	R2
	BEQ	20$
10$:
	CALL	RBNDIV
20$:	POP	<R3,R2,R1>
	RETURN
RBNDIV:
	MOV	#128.,R0
	CALL	DDIV
	MOV	R2,(R3)+
	MOV	R1,(R3)+
	ASH	#2,R0
	MOV	R0,(R3)+
	MOV	ACTBBR,R5
	ADD	BB.MAX(R5),-6(R3)
	ADC	-4(R3)
	ADD	#2,-6(R3)
	ADC	-4(R3)
	RETURN
.SBTTL	SRCH  - REPLACEMENT CONTROL TABLE SEARCH ALGORITHM
SRCH::
	PUSH	<R0,R1,R2,R3,R4,R5>
	CLR	ORBNL
	CLR	ORBNH
	CLR	R0
	MOV	PLBNO,R4
	ASR	R4
	ASR	R4
	MOV	#RCTBF,DSKBF
	$REL .-4 RCTBF DUX
	MOV	PLBNL,LBNL
	MOV	PLBNH,LBNH
SNEXT:	CALL	MULRD
	BCS	SXIT
	CLR	R2
STEST:	MOV	R4,R1
	ADD	R2,R1
	BLT	SBMP
	CMP	R1,#127.
	BGT	SBMP
	ASL	R1
	ASL	R1
	TST	RCTBF+2(R1)
	$REL .-2 RCTBF+2 DUX
	BNE	SALL0
	MOV	#NRBNL,R3
	$REL .-2 NRBNL DUX
	CALL	SRBN
	CLC
	BR	SXIT
SALL0:	BIT	#DF.ALL,RCTBF+2(R1)
	$REL .-2 RCTBF+2 DUX
	BEQ	SNULL
	MOV	RCTBF+2(R1),R3
	$REL .-2 RCTBF+2 DUX
	BIC	#<DF.NUL!DF.UNU!DF.ALL!DF.SEC>,R3
	CMP	BLBNH,R3
	BNE	SNULL
	CMP	BLBNL,RCTBF(R1)
	$REL .-2 RCTBF DUX
	BNE	SNULL
	MOV	#ORBNL,R3
	$REL .-2 ORBNL DUX
	BIS	#RF.BR,SEC0+RCTFLG
	CALL	SRBN
	BR	SBMP
SNULL:	TST	RCTBF+2(R1)
	$REL .-2 RCTBF+2 DUX
	BPL	SBMP
	TST	R0
	SEC
	BNE	SXIT
	INC	R0
	MOV	ACTBBR,R4
	MOV	BB.MAX(R4),LBNL
	MOV	BB.MAX+2(R4),LBNH
	ADD	#2,LBNL
	ADC	LBNH
	CLR	R4
	BR	SNEXT
SBMP:
	NEG	R2
	BMI	STEST
	INC	R2
	CMP	R2,#128.
	BLT	STEST
	CLR	R4
	ADD	#1,LBNL
	ADC	LBNH
	BR	SNEXT
SRBN:
	PUSH	<R0,R1,R2,R3,R4,R5>; SAVE REGISTERS
	MOV	LBNL,R3
	MOV	LBNH,R2
	MOV	ACTBBR,R0
	SUB	BB.MAX(R0),R3
	SBC	R2
	SUB	BB.MAX+2(R0),R2
	SUB	#2,R3
	SBC	R2
	MOV	#128.,R0
	CALL	DMUL
	MOV	10(SP),R2
	ASR	R2
	ASR	R2
	ADD	R2,R1
	ADC	R0
	MOV	4(SP),R3
	MOV	R1,(R3)+
	MOV	R0,(R3)+
	MOV	LBNL,(R3)+
	MOV	LBNH,(R3)+
	ASL	R2
	ASL	R2
	MOV	R2,(R3)
SXIT:	POP	<R5,R4,R3,R2,R1,R0>; RESTORE REGISTERS
	RETURN
.SBTTL	UNALL - MARK RBN UNALLOCATED
UNALL::
	PUSH	<R0,R5>
	CALL	NEWBF
	MOV	R0,DSKBF
	CALL	MULRD
	MOV	R0,R5
	ADD	NLBNO,R5
	CLR	(R5)
	CLR	2(R5)
	CALL	MULWT
	BIT	#RF.BR,SEC0+RCTFLG
	BEQ	30$
	CALL	OLDBF
	MOV	R0,DSKBF
	CALL	MULRD
	MOV	R0,R5
	ADD	OLBNO,R5
	MOV	BLBNL,(R5)+
	MOV	BLBNH,(R5)
	BIS	#DF.ALL,(R5)
	CMP	PLBNO,OLBNO
	BNE	10$
	CMP	PLBNL,NLBNL
	BNE	10$
	CMP	PLBNH,NLBNH
	BEQ	20$
10$:	BIS	#DF.SEC,(R5)
20$:	CALL	MULWT
30$:	POP	<R5,R0>
	RETURN
.SBTTL	WTSAV - WRITE SAVED DATA BACK OUT TO DISK
WTSAV::
	MOV	BLBNL,LBNL
	MOV	BLBNH,LBNH
	MOV	#OP.WR,IOFUN
	MOV	#MD.CMP,IOMOD
	BIT	#RF.FE,SEC0+RCTFLG
	BEQ	10$
	MOV	#MD.ERR!MD.CMP,IOMOD
10$:	MOV	#LBN,DSKBF
	$REL .-4 LBN DUX
	CALL	DSKIO
	RETURN
.SBTTL	DDIV  - DOUBLE PRECISION DIVIDE ROUTINE
DDIV::	MOV	R3,-(SP)
	MOV	#32.,R3
	MOV	R0,-(SP)
	CLR	R0
10$:	ASL	R2
	ROL	R1
	ROL	R0
	CMP	R0,(SP)
	BLO	20$
	SUB	(SP),R0
	INC	R2
20$:	SOB	R3,10$
	TST	(SP)+
	MOV	(SP)+,R3
	RETURN
.SBTTL	DMUL  - DOUBLE PRECISION MULTIPLY
DMUL::	MOV	R0,-(SP)
	CLR	R0
	CLR	R1
10$:	TST	(SP)
	BEQ	30$
	ROR	(SP)
	BCC	20$
	ADD	R3,R1
	ADC	R0
	ADD	R2,R0
20$:	ASL	R3
	ROL	R2
	BR	10$
30$:	TST	(SP)+
	RETURN
.ENDC
.IF NE DU$BBR
	.SBTTL	RCONTX - Restore the context before the interrupt.
	.ENABL	LSB
RCONTX:
	MOV	(SP)+,(PC)+
RBACK:	.WORD	0
	CLR	BBRON
	MOV	#CONTEXT,R5
	$REL .-2 CONTEXT DUX
	MOV	(R5)+,R0
	BEQ	20$
	CLR	CONTEXT
	MOV	-(R0),R4
	MOV	-(R0),R3
	MOV	-(R0),R2
	MOV	-(R0),R1
10$:	MOV	-(R0),-(SP)
	CMP	R0,R5
	BNE	10$
	JMP	@(SP)+
20$:	JMP	@RBACK
	.DSABL	LSB
.ENDC
.IF NE DU$BBR
	.SBTTL	SCONTX - Save the context - GO START COMMAND!
	.ENABL	LSB
SCONTX:
	MOV	#CONTEXT,R0
	$REL .-2 CONTEXT DUX
	ADD	#2,R0
	MOV	(SP)+,(R0)+
10$:	MOV	(SP)+,(R0)+
	CMP	SP,SAVESP
	BNE	10$
	MOV	R1,(R0)+
	MOV	R2,(R0)+
	MOV	R3,(R0)+
	MOV	R4,(R0)+
	MOV	R0,CONTEXT
	MOV	#-1,BBRON
	JMP	POLL
CONTEXT:.WORD	0
	.REPT	60
	.WORD	125252
	.ENDR
	.DSABL	LSB
.ENDC
.IF NE MMG$T
DUXEND::
	DUXSIZ ==: DUXEND - DUXBAS
.IF EQ DU$BBR
	.ASSUME . LE DUXBAS+<10000>
.IFF
	.ASSUME	. LE DUXBAS+<20000>
.ENDC
.ENDC
DUPSECT
.SBTTL	BOOTSTRAP DRIVER
	.DRBOT	DU,BOOT1,READ,CONTROL=<UMSCP,QMSCP>
	. = DUBOOT+40
BOOT1:	JMP	@#BOOT-DUBOOT
.IF NE DU$BOO
	.SBTTL	LOACSR - load IP register from tables
	.ENABL LSB
	. = DUBOOT + 14
LOACSR:
	MOV	BUNIT,R3
	ASL	R3
	ASL	R3
	BR	100$
	. = DUBOOT + 44
100$:   ADD	#PD.POR-DUBOOT,R3
	MOV	(R3)+,MUNIT
	MOV	@R3,R3
	ASL	R3
	BR	200$
	. = DUBOOT + 70
200$:	ADD	#PD.CSR-DUBOOT,R3
	BR	300$
	. = DUBOOT + 104
300$:	MOV	@R3,BDUAIP
	RTS	PC
	.DSABL	LSB
.ENDC
	. = DUBOOT+120
READ:	TST	HRDBOT
	BEQ	READA
	MOV	@#B$DEVU,(PC)+
BUNIT:	 .WORD	0
READA:
.IF	NE	DU$BOO
	ASR	#1
	BCC	10$
	JSR	PC,LOACSR
.ENDC
10$:	MOV	#NRETRY,BRETRY
	ASL	R1
	ASR	#1
	BCC	READ1
.IF	EQ	DU$BOO
	JSR	PC,ALTCHK
.ENDC
BINIT:	DEC	(PC)+
BRETRY:	 .WORD	0
	BLT	BIOELK
	MOV	BDUAIP,R5
	MOV	R4,(R5)+
	MOV	#ISTEP1,R3
	MOV	#BINLST-DUBOOT,R4
1$:	TST	@R5
	BMI	BINIT
	BIT	@R5,R3
	BEQ	1$
	MOV	(R4)+,@R5
	ASL	R3
	BPL	1$
	CMP	(R4)+,(R4)+
	MOV	R4,BCRING
	MOV	R4,BMRING
	JSR	R0,BGTBUF
	 .WORD	OP.ONL
	JSR	PC,BDOIO
	.BR	READ1
READ1:	JSR	R0,BGTBUF
	 .WORD	OP.RD
	MOV	R0,P.LBN(R4)
	MOV	R1,P.BCNT(R4)
	MOV	R2,P.BUFF(R4)
	.BR	BDOIO
.ENABL	LSB
BDOIO:	MOV	BDUAIP,R3
1$:	MOV	#BCRING+2-DUBOOT,R4
	MOV	#OWN,@R4
	MOV	(R3)+,R5
2$:	TST	@R3
	BMI	4$
	TST	@R4
	BMI	2$
	TST	-(R4)
	MOV	#OWN,-(R4)
3$:	TST	@R3
	BMI	4$
	TST	@R4
	BMI	3$
	TSTB	BBUFF+P.STS
BIOELK:	BNE	BIOERR
	RTS	PC
4$:	TST	(SP)+
	BR	BINIT
.DSABL	LSB
BGTBUF:	MOV	#BBUFF-DUBOOT+P.MSIZ,R4
1$:	CLR	-(R4)
	CMP	R4,#BBUFF-DUBOOT
	BHI	1$
	MOV	#P.MSIZ,-4(R4)
	MOV	(R0)+,P.OPCD(R4)
.IF EQ DU$BOO
	MOV	BUNIT,P.UNIT(R4)
.IFF
	MOV	MUNIT,P.UNIT(R4)
.ENDC
	RTS	R0
.SBTTL	BOOTSTRAP IMPURE AREA
BINLST:	.BYTE	0
	.BYTE	0*10+0+STEP
	.WORD	BMRING-DUBOOT
	.WORD	0
	.WORD	GO
BLN:	.WORD	0
BVC:	.WORD	0
BBUFF:	.BLKB	P.MSIZ
	.WORD	0,0
BMRING:	.WORD	0,0
BCRING:	.WORD	0,0
	.SBTTL	ALTCHK	- ALTERNATE CSR CHECK FOR FALCONS
BDUAIP:	.WORD	DU$CSR
.IF NE DU$BOO
MUNIT:	.WORD	0
.ENDC
.IF EQ	DU$BOO
ALTCHK:	MOV	R0,-(SP)
	MOV	@#INS.V,-(SP)
	MOV	PC,R0
	ADD	#BT.INS-.,R0
	MOV	R0,@#INS.V
	CLR	R0
	MFPT
	CMP	R0,#4
	BNE	999$
	MOV	#DU$ALT,BDUAIP
999$:	MOV	(SP)+,@#INS.V
	MOV	(SP)+,R0
	RTS	PC
BT.INS:	BIS	#1,2(SP)
	RTI
.ENDC
.IF NE	DU$BOO
PD.POR:	.WORD	0,0
	.WORD	1,0
	.WORD	2,0
	.WORD	3,0
	.WORD	4,0
	.WORD	5,0
	.WORD	6,0
	.WORD	7,0
PD.CSR:	.WORD	DU$CSR
.IF NE DU$PORTS-1
	.WORD	DU$CS1
  .IF NE DU$PORTS-2
	.WORD	DU$CS2
     .IF NE DU$PORTS-3
	.WORD	DU$CS3
     .ENDC
  .ENDC
.ENDC
.ENDC
	.SBTTL	BOOTSTRAP PRIMARY ROUTINE
BOOT:	MOV	#10000,SP
	MOV	R0,-(SP)
	BIC	#^C<7>,@SP
	MOV	(SP),BUNIT
	MOV	#2,R0
	MOV	#<4*400>,R1
	MOV	#1000,R2
	CLR	(PC)+
HRDBOT:	 .WORD	1
	JSR	PC,READ
	MOV	#READ-DUBOOT,@#B$READ
	MOV	#B$DNAM,@#B$DEVN
	MOV	(SP)+,@#B$DEVU
	JMP	@#B$BOOT
	.DREND	DU
	.SBTTL	OVR1 - Set code overlay number 1
	.PSECT	SETOVR
OVRBK0:
BIAS	==:	<OVRBK0 - REF0>
VALUE:	.WORD	0
OFFSET:	.WORD	0
.IF NE DU$BOO
	OFF2TA	= 8.*2*2
.ENDC
.SBTTL SET UNIT, PORT, PARTITION, SUCCESS AND RETRY
SET.UT:
	DEC	R3
	CMP	R0,#255.
	BHI	HLP1
.IF NE DU$PORTS-1
	CMP	R3,#UT.PORT
	BNE	10$
	CMP	R0,#DU$PORTS-1
	BHI	HLP1
.ENDC
10$:	BIC	#100000,R1
	ASL	R1
	ASL	R1
.IF	NE	DU$BOO
	MOV	R1,OFFSET
.ENDC
					  .ASSUME UT.ESZ EQ 4
	.ADDR	#UTTAB+BIAS,R1,ADD
	ADD	R3,R1
	MOVB	R0,(R1)
.IF	NE	DU$BOO
	MOV	R0,VALUE
	CMP	R3,#UT.PORT
	BNE	20$
	ADD	#2,OFFSET
	BR	30$
20$:	CMP	R3,#UT.UNIT
	BNE	S.NOR
30$:
	MOV	#PD.POR/1000,R3
	CALL	CORWRT
	BCS	S.IGN
	ADD	OFFSET,R2
	MOV	VALUE,<PD.POR&777>(R2)
	CALL	CORREA
	BCS	S.IGN
	BR	S.NOR
.IFF
	BR	S.NOR
.ENDC
.IF NE ERL$G
SET.SUC:
	CLR	R3
	NOP
	MOV	R3,$SUCS+BIAS
	BR	S.NOR
.ENDC
SET.RET:
	CMP	R0,R3
HLP1:	BHI	S.ERR
	MOV	R0,$RETRY+BIAS
	BR	S.NOR
.SBTTL	SET CSR
SET.CSR:
	CMP	R0,#160000
	BLO	S.ERR
	MOV	R0,VALUE
	MOV	R3,OFFSET
	MOV	#BLK0,R3
	CALL	CORWRT
	BCS	S.IGN
	DEC	OFFSET
	BNE	10$
	MOV	VALUE,INSCSR+BIAS+1000
10$:	MOV	OFFSET,R0
	NEG	R0
	.ADDR	#DISCSR+BIAS+1000,R0,ADD
	MOV	VALUE,(R0)
	MOV	#BLK0,R3
	CALL	CORREA
	BCS	S.IGN
	MOV	OFFSET,R3
.IF 	NE	DU$BOO
	ADD	#OFF2TA,OFFSET
.ENDC
.IF NE DU$PORTS-1
	ASL	R3
	ASL	R3
					    .ASSUME PC.ESZ EQ 10
	.ADDR	#PCTAB+BIAS,R1
	ADD	R3,R1
.IFF
	.ADDR	#UDAIP+BIAS,R1
.ENDC
	MOV	VALUE,(R1)+
					   .ASSUME PC.AIP EQ 0
	MOV	VALUE,@R1
					   .ASSUME PC.ASA EQ 2
	ADD	#2,@R1
.IF NE	DU$PORTS-1
.IF EQ	DU$BOO
	TST	R3
					  .ASSUME PC.AIP EQ 0.
	BNE	S.NOR
.ENDC
.ENDC
  .IF EQ DU$BOO
	MOV	#BDUAIP/1000,R3
  .IFF
	MOV	#PD.POR/1000,R3
  .ENDC
	CALL	CORWRT
	BCS	S.IGN
  .IF EQ DU$BOO
	MOV	VALUE,<BDUAIP&777>(R2)
  .IFF
	ADD	OFFSET,R2
	MOV	VALUE,<PD.POR&777>(R2)
  .ENDC
	CALL	CORREA
	BCS	S.IGN
	BR	S.NOR
.SBTTL SET VECTOR(S)
SET.VEC:
	CMP	R0,#500
	BHIS	S.ERR
.IF NE DU$PORTS-1
	.ADDR	#DU$VTB+BIAS,R1
	DEC	R3
	MOV	R3,-(SP)
	ASL	R3
	ADD	(SP),R3
					    .ASSUME VT.ESZ EQ 6
	ADD	R3,R1
.IFF
	.ADDR	#DUSTRT+BIAS,R1
.ENDC
	MOV	R0,@R1
.IF NE DU$PORTS-1
	ADD	(SP)+,R1
					   .ASSUME PC.ESZ EQ 10
	ADD	#PCTAB-DU$VTB+PC.VEC,R1
					   .ASSUME VT.ESZ+2 EQ PC.ESZ
.IFF
	.ADDR	#INILST+BIAS,R1
.ENDC
	ASR	R0
	ASR	R0
	BIS	#IE,R0
	MOVB	R0,@R1
	BR	S.NOR
	.SBTTL	ADIOS - Common exit point for overlayed code
S.NOR:	CLR	R2
S.IGN:	CMP	(PC)+,(PC)+
S.ERR:	MOV	#1,R2
	JMP	GETBK0+BIAS
	.SBTTL	CORE - Sub/Coroutine for core reads/writes
BAREA:	.BYTE	17,11
	.BLKW
	.BLKW
	.WORD	256.
	.WORD	0
CORWRT:
	.ADDR	#BAREA+4,R1
	.ADDR	#1000+BIAS,R2
	MOV	R2,(R1)
	MOV	#1,-(R1)
	TST	-(R1)
	MOV	R1,R0
	EMT	375
	BCS	C2.ERR
	MOV	R1,R0
	DECB	1(R0)
	MOV	R3,2(R0)
	EMT	375
	BCS	C.ERR
	BR	C.NOR
CORREA:	MOV	R1,R0
	INCB	1(R0)
	MOV	R3,2(R0)
	EMT	375
	BCS	C2.ERR
	MOV	R1,R0
	DECB	1(R0)
	MOV	#1,2(R0)
	EMT	375
	BCS	C.ERR
	INCB	1(R1)
	BR	C.NOR
C2.ERR:	MOV	#2,R2
	BR	C.NOR
C.ERR:	MOV	#1,R2
C.NOR:
	RTS	PC
	.ASSUME	<.-OVRBK0> LE OVRSIZ
	.SBTTL	SPCDRPTR - SPecial DRPTR codes.
	. = OVRBK0 + BLK
OVRBK1:
	.SBTTL	ONCE - Load/Fetch once only code.
ONCE::
	MOV	R2,SSLOT
	MOV	R4,SRDRTN
	MOV	R5,SENTRY
	MOV	@R5,R3
.IF EQ DU$BOO
	CALL	FALCON
.ENDC
.IF NE DU$PORTS-1
	CALL	CKPORT
.ENDC
.IF NE MMG$T
	.ENABL	LSB
	MOV	@#SYSPTR,R4
	MOV	P1EXT(R4),R4
	.ADDR	#DUNAME,R5
	CALL	FINDGR(R4)
	BCS	GETGBL
	MOV	GR.ADR(R1),P1HIGH-DUBASE(R3)
	MOV	P1HIGH-DUBASE(R3),R1
	BR	50$
.IIF  EQ DU$BBR			MEMDUX =: 100
.IIF  NE DU$BBR			MEMDUX =: 200
GETGBL:	MOV	@#SYSPTR,R4
	MOV	MEMPTR(R4),R0
	ADD	R4,R0
	MOV	CORPTX(R0),R5
	ADD	R4,R5
20$:	CMP	#-1,(R5)+
	BNE	20$
30$:	CMP	#-1,@R5
	BEQ	D.BAD
	TST	@R5
	BEQ	40$
	ADD	#GR.ESZ,R5
	BR	30$
40$:	MOV	P1EXT(R4),R0
	MOV	#MEMDUX,R2
	MOV	R3,-(SP)
	CALL	XALLOC(R0)
	MOV	(SP)+,R3
	BCS	D.BAD
	MOV	R2,(R5)+
	MOV	R1,(R5)+
	MOV	R1,P1HIGH-DUBASE(R3)
	MOV	#GR.PVT,(R5)+
	MOV	#<^RDU >,(R5)+
	MOV	#<^R$>,@R5
50$:	CLR	R0
	ASHC	#6,R0
	MOV	R0,PHYSH-DUBASE(R3)
	MOV	R1,PHYSL-DUBASE(R3)
	CALL	UPDUX
	BCS	D.BAD
	.DSABL	LSB
.ENDC
D.GOO:	TST	(PC)+
D.BAD:	SEC
	RETURN
DUNAME:	.RAD50	/DU /
	.RAD50	/$  /
SENTRY:	.WORD	0
SSLOT:	.WORD	0
SRDRTN:	.WORD	0
.IF NE MMG$T
	.SBTTL	UPDUX - Move psect DUX to high memory
	.ENABL	LSB
UPDUX::
	MOV	#XMRING,R2
	$REL .-2 XMRING DUX
	SUB	#BEGREL,R2
	ADD	R2,R1
	ADC	R0
	MOV	R1,MRPTR-DUBASE(R3)
	MOV	R0,MRPTR+2-DUBASE(R3)
	MOV	@#KISAR1,-(SP)
	MOV	P1HIGH-DUBASE(R3),@#KISAR1
	MOV	SENTRY,R2
	MOV	SSLOT,R0
	ASL	R0
	ADD	R2,R0
	ADD	#2,R0
	MOV	@R0,R0
	DEC	R0
	MOV	#20000,R5
	ADD	#DUXBAS/1000,R0
	MOV	#DUXSIZ,R4
30$:	CMP	R4,#BLK
	BGT	40$
	MOV	R4,R1
	BR	44$
40$:	MOV	#BLK,R1
44$:	ASR	R1
	.ADDR	#ONCBUF,R2
	MOV	R1,-(SP)
	CALL	@SRDRTN
	MOV	(SP)+,R1
	BCS	20$
	CALL	STORUP
	SUB	#BLK,R4
	BLE	45$
	INC	R0
	BR	30$
45$:
	MOV	#LN.CMD,R1
	$REL .-2 LN.CMD DUX
	MOV	#P.CSIZ+4,R2
60$:	CLR	(R1)+
	DEC	R2
	BNE	 60$
	.ADDR	#DUR.LST,R0
10$: 	MOV	(R0)+,R1
	BEQ	20$
	ADD	R3,@R1
	BR	10$
20$:	MOV	#20000,R5
	MOV	@#KISAR1,R1
	MOV	(SP),@#KISAR1
	MOV	$MPPTR-DUBASE(R3),-(SP)
	MOV	$PTWRD-DUBASE(R3),-(SP)
	MOV	$GTBYT-DUBASE(R3),-(SP)
.IF NE ERL$G
	MOV	$ELPTR-DUBASE(R3),-(SP)
.ENDC
	MOV	@#SYSPTR,R2
	MOV	P1EXT(R2),-(SP)
	MOV	(SP),$P1EXT-DUBASE(R3)
	MOV	R1,@#KISAR1
	MOV	(SP)+,H$P1EX-DUXBAS(R5)
.IF NE ERL$G
	MOV	(SP)+,H$ELPT-DUXBAS(R5)
.ENDC
	MOV	(SP)+,H$GTBY-DUXBAS(R5)
	MOV	(SP)+,H$PTWR-DUXBAS(R5)
	MOV	(SP)+,H$MPPT-DUXBAS(R5)
	.ADDR	#ONCBUF,R0
	MOV	(SP),@#KISAR1
	MOV	#UDAIP-DUBASE,R2
	ADD	R3,R2
	MOV	#LOWDATA,R4
	ADD	R4,R0
	ASR	R4
80$:	MOV	(R2)+,-(R0)
	SOB	R4,80$
	MOV	R1,@#KISAR1
	MOV	#LOWDATA,R4
	MOV	#XUDAIP,R2
	$REL .-2 XUDAIP DUX
	ADD	R4,R2
	ASR	R4
90$:	MOV	(R0)+,-(R2)
	SOB	R4,90$
	MOV	(SP)+,@#KISAR1
	RTS	PC
	.DSABL	LSB
.ENDC
.IF NE MMG$T
	DUR.DID	=	1
	DUR.LST:
	.REPT	DUR.CNT
	 .Irp	x	<\DUR.DID>
		.WORD	DUR'x
	$REL	.-2	DUR'x	DUX
	 .ENDR
	DUR.DID	=	DUR.DID+1
	.ENDR
		.WORD	000000
		.EVEN
.ENDC
STORUP:
	MOV	R2,-(SP)
10$:	MOV	(R2)+,(R5)+
	DEC	R1
	BNE	10$
	MOV	(SP)+,R2
	RTS	PC
FBLOC::
.ASSUME	. LE OVRBK1+<1*BLK>
	. = OVRBK1+<1*BLK>
ONCBUF::
.IF NE DU$PORTS-1
	.SBTTL	CKPORT - Check for installed ports
CKPORT:	.MFPS
	.MTPS	#340
	MOV	@#INS.V,-(SP)
	.ADDR	#DU.INS,R5
	MOV	R5,@#ILG.V
INPOR1:
	MOV	PCTAB+<PC.ESZ*1>-DUBASE(R3),R1
	CLC
	MOV	@R1,R0
	BCC	INPOR2
	MOV	#1,R4
	CALL	PORTUP
INPOR2:
   .IF NE DU$PORTS-2
	MOV	PCTAB+<PC.ESZ*2>-DUBASE(R3),R1
	CLC
	MOV	@R1,R0
	BCC	INPOR3
	MOV	#2,R4
	CALL	PORTUP
INPOR3:
     .IF NE DU$PORTS-3
	MOV	PCTAB+<PC.ESZ*3>-DUBASE(R3),R1
	CLC
	MOV	@R1,R0
	BCC	NOPOR
	MOV	#3,R4
	CALL	PORTUP
NOPOR:
     .ENDC
   .ENDC
	MOV	(SP)+,@#ILG.V
	.MTPS
	RTS	PC
PORTUP:
	MOV	#UTTAB-DUBASE,R1
	ADD	R3,R1
	MOV	#8.,R0
10$:	CMPB	R4,UT.PORT(R1)
	BNE	20$
 	BISB	#200,UT.PORT(R1)
20$:	DEC	R0
	BEQ	30$
	ADD	#UT.ESZ,R1
	BR	10$
30$:	RTS	PC
.ENDC
.IF EQ DU$BOO
	.SBTTL	FALCON - Check if we are on a falcon
.IFTF
DU.INS:	BIS	#1,2(SP)
	RTI
.IFT
FALCON:	.MFPS
	.MTPS	#340
	MOV	R0,-(SP)
	MOV	@#INS.V,-(SP)
	.ADDR	#DU.INS,R5
	MOV	R5,@#INS.V
	CLR	R0
	MFPT
	CMP	R0,#4
	BNE	10$
	.IF EQ DU$PORTS-1
	MOV	#DU$ALT,UDAIP-DUBASE(R3)
	MOV	#DU$ALT+2,UDASA-DUBASE(R3)
	.IFF
	MOV	#DU$ALT,PCTAB-DUBASE(R3)
	MOV	#DU$ALT+2,PCTAB+2-DUBASE(R3)
	.ENDC
10$:	MOV	(SP)+,@#INS.V
	MOV	(SP)+,R0
	.MTPS
	RTS	PC
.ENDC
ONCEND::
.ASSUME	. LE OVRBK1+<2*BLK>
	. = OVRBK1 + <2*BLK>
	.END
                                                                                                                                                                                                                                                                                                 