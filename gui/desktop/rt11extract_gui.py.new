#!/usr/bin/env python3

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import subprocess
import os
import sys
import tempfile
import shutil
from pathlib import Path
import threading
import time
import zipfile
import uuid
from datetime import datetime
import webbrowser
import sys
from pathlib import Path

# Import PyInstaller helper for path resolution
try:
    from pyinstaller_helper import setup_backend_path, get_rt11extract_cli_path, get_imd2raw_path, is_frozen, get_script_dir
except ImportError:
    # Fallback: create minimal helper functions if file not found
    def setup_backend_path():
        script_dir = Path(__file__).parent.parent.parent if not getattr(sys, 'frozen', False) else Path(sys.executable).parent
        backend_path = script_dir / "backend"
        if backend_path.exists() and str(backend_path) not in sys.path:
            sys.path.insert(0, str(backend_path))
        return backend_path
    
    def get_rt11extract_cli_path():
        def debug_log(msg):
            print(f"[DEBUG] RT11Extract CLI: {msg}")
            
        debug_log(f"Resolving CLI path in {'frozen' if getattr(sys, 'frozen', False) else 'script'} mode")
        
        if getattr(sys, 'frozen', False):
            if sys.platform.startswith('win'):
                # Windows: Try all possible CLI executables in same directory
                exe_dir = Path(sys.executable).parent
                debug_log(f"Windows mode - searching in: {exe_dir}")
                
                # Try all possible CLI executables in prioritized order
                cli_options = [
                    "RT11Extract.exe",            # Main CLI
                    "rt11extract_universal.exe",  # Universal extractor
                    "universal_extractor.exe",    # Alternative name
                    "rt11extract_cli.exe"        # Alternative name
                ]
                
                for cli in cli_options:
                    cli_path = exe_dir / cli
                    debug_log(f"Checking for {cli}: {cli_path.exists()}")
                    if cli_path.exists():
                        debug_log(f"Found CLI: {cli_path}")
                        return cli_path
                
                debug_log("No Windows CLI found!")
                return None
                
            elif sys.platform == 'darwin':
                # macOS: Try all possible CLI executables in bundle/cli/
                exe_path = Path(sys.executable)
                cli_dir = exe_path.parent.parent / "cli"
                debug_log(f"macOS mode - searching in bundle CLI dir: {cli_dir}")
                
                # Try all possible CLI names in prioritized order
                cli_options = [
                    "rt11extract_cli",         # Main CLI
                    "rt11extract_universal",    # Universal extractor
                    "universal_extractor",      # Alternative name
                    "RT11Extract"              # Alternative name
                ]
                
                for cli in cli_options:
                    cli_path = cli_dir / cli
                    debug_log(f"Checking for {cli}: {cli_path.exists()}")
                    if cli_path.exists():
                        debug_log(f"Found CLI: {cli_path}")
                        return cli_path
                
                debug_log("No macOS CLI found in bundle!")
                return None
            else:
                exe_dir = Path(sys.executable).parent
                return exe_dir / "RT11Extract"
        else:
            return Path(__file__).parent.parent.parent / "backend" / "extractors" / "rt11extract"
    
    def get_imd2raw_path():
        def debug_log(msg):
            print(f"[DEBUG] IMD2RAW: {msg}")
            
        debug_log(f"Resolving IMD2RAW path in {'frozen' if getattr(sys, 'frozen', False) else 'script'} mode")
        
        if getattr(sys, 'frozen', False):
            if sys.platform.startswith('win'):
                exe_dir = Path(sys.executable).parent
                debug_log(f"Windows mode - searching in: {exe_dir}")
                
                # Try multiple names
                imd_options = ["imd2raw.exe", "IMD2RAW.exe", "imd2dsk.exe"]
                for imd in imd_options:
                    imd_path = exe_dir / imd
                    debug_log(f"Checking for {imd}: {imd_path.exists()}")
                    if imd_path.exists():
                        debug_log(f"Found IMD2RAW: {imd_path}")
                        return imd_path
                
                debug_log("No Windows IMD2RAW found!")
                return None
                
            elif sys.platform == 'darwin':
                # CRITICAL: For macOS bundle, use the embedded imd2raw inside the app bundle
                exe_path = Path(sys.executable)
                # sys.executable is Contents/MacOS/RT11Extract, we need Contents/cli/imd2raw
                debug_log(f"macOS mode - searching in bundle")
                
                # Try multiple locations and names
                bundle_locations = [
                    exe_path.parent.parent / "cli" / "imd2raw",      # Standard bundle location
                    exe_path.parent.parent / "cli" / "IMD2RAW",      # Alternative name
                    exe_path.parent / "imd2raw",                     # Direct in MacOS dir
                    exe_path.parent.parent / "Resources" / "imd2raw" # Resources dir
                ]
                
                for loc in bundle_locations:
                    debug_log(f"Checking bundle location: {loc.exists()}")
                    if loc.exists():
                        debug_log(f"Found IMD2RAW in bundle: {loc}")
                        return loc
                
                debug_log("No macOS IMD2RAW found in bundle!")
                return None
        else:
            return Path(__file__).parent.parent.parent / "backend" / "image_converters" / "imd2raw.py"
    
    def is_frozen():
        return getattr(sys, 'frozen', False)
    
    def get_script_dir():
        if is_frozen():
            return Path(sys.executable).parent
        else:
            return Path(__file__).parent.parent.parent

# Setup backend path for imports
backend_path = setup_backend_path()

# Global variables - use PyInstaller helper for path resolution
rt11extract_path = get_rt11extract_cli_path()
imd2raw_path = get_imd2raw_path()
script_dir = get_script_dir()

class RT11ExtractGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("RT-11 Extract GUI")
        self.root.geometry("900x700")
        self.root.minsize(800, 600)
        
        # Variables
        self.current_file = None
        self.current_files = []
        self.temp_dir = None
        self.output_dir = None
        self.is_extracting = False
        self.converted_dsk_file = None  # For IMD->DSK conversion
        self.fuse_mount_point = None  # FUSE mount point
        self.fuse_process = None      # FUSE process
        self.fuse_mounted = False     # Track if FUSE is successfully mounted
        self.startup_warning_shown = False  # Track if startup warning was shown
        
        # Windows-specific variables
        if sys.platform == "win32":
            # Constants for Windows subprocess creation flags
            self.CREATE_NO_WINDOW = 0x08000000
            self.DETACHED_PROCESS = 0x00000008
        else:
            self.CREATE_NO_WINDOW = 0
            self.DETACHED_PROCESS = 0

        self.setup_ui()
        self.setup_menu()
        
        # Set custom RT-11/DEC icon (after UI setup so log function is available)
        self.set_application_icon()
        
        self.check_rt11extract()
        
        # Show startup warning about filesystem mounting (after UI is ready)
        self.root.after(500, self.show_startup_warning)
        
        # Debug CLI path resolution
        self.log(f"DEBUG: Resolved CLI path: {rt11extract_path}")
        self.log(f"DEBUG: CLI exists: {rt11extract_path.exists() if rt11extract_path else False}")
        self.log(f"DEBUG: Running as frozen: {getattr(sys, 'frozen', False)}")
        self.log(f"DEBUG: Script directory: {script_dir}")

    def _get_subprocess_kwargs(self):
        """Get subprocess kwargs that handle CLI paths correctly"""
        kwargs = {
            'capture_output': True,
            'text': True
        }
        
        # Set proper working directory based on mode and platform
        if getattr(sys, 'frozen', False):
            if sys.platform == 'darwin':
                # For macOS bundle, all CLIs should be in Contents/cli/
                exe_path = Path(sys.executable)
                cli_dir = exe_path.parent.parent / "cli"
                if cli_dir.exists():
                    kwargs['cwd'] = str(cli_dir)
                else:
                    # Fallback to executable directory
                    kwargs['cwd'] = str(exe_path.parent)
            else:
                # For Windows and others, use executable directory
                kwargs['cwd'] = str(Path(sys.executable).parent)
        else:
            # In script mode, use script directory
            kwargs['cwd'] = str(script_dir)
        
        self.log(f"DEBUG: Setting up subprocess kwargs...")
        self.log(f"DEBUG: Initial cwd = {kwargs['cwd']}")
        
        # On Windows, hide the console window
        if sys.platform == "win32":
            kwargs['creationflags'] = self.CREATE_NO_WINDOW
            self.log("DEBUG: Added Windows CREATE_NO_WINDOW flag")
        
        self.log(f"DEBUG: Final kwargs = {kwargs}")
        return kwargs

    def _run_cli_command(self, cmd, *args, **kwargs):
        """Run CLI command with proper handling of executables"""
        if getattr(sys, 'frozen', False):
            # Use bundled CLI tools
            cli_path = None
            if sys.platform == "win32":
                # Windows: Check executables in same directory
                exe_dir = Path(sys.executable).parent
                for cli in [f"{cmd}.exe", f"{cmd}_cli.exe"]:
                    test_path = exe_dir / cli
                    if test_path.exists():
                        cli_path = test_path
                        break
            elif sys.platform == "darwin":
                # macOS: Check in bundle/cli/
                exe_path = Path(sys.executable)
                cli_dir = exe_path.parent.parent / "cli"
                test_path = cli_dir / cmd
                if test_path.exists():
                    cli_path = test_path

            if cli_path:
                # Enable execution on macOS if needed
                if sys.platform == "darwin":
                    try:
                        cli_path.chmod(cli_path.stat().st_mode | 0o755)
                    except Exception as e:
                        self.log(f"Warning: Could not set executable permissions: {e}")
                
                return subprocess.run([str(cli_path)] + list(args), **kwargs)
        
        # Default: Use backend script directly
        script_path = script_dir / "backend" / "extractors" / cmd
        if script_path.exists():
            return subprocess.run([sys.executable, str(script_path)] + list(args), **kwargs)
        
        raise FileNotFoundError(f"CLI tool not found: {cmd}")

    def check_rt11extract(self):
        """Check if rt11extract is available and working"""
        if not rt11extract_path or not rt11extract_path.exists():
            self.log(f"ERROR: rt11extract not found at: {rt11extract_path}")
            self.log("Please ensure rt11extract is in the same directory as this script.")
            messagebox.showerror("RT-11 Extract Not Found", 
                               f"rt11extract not found at:\n{rt11extract_path}\n\n"
                               "Please ensure rt11extract is in the same directory as this script.")
        else:
            self.log("RT-11 Extract found and ready.")

    def log(self, message):
        """Add message to log"""
        self.log_text.config(state="normal")
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
        self.log_text.config(state="disabled")
        self.root.update_idletasks()

    def setup_ui(self):
        # ... (rest of UI setup code unchanged)
        pass

def main():
    # Add startup debug logging
    print("\nRT-11 Extract GUI Starting...")
    print(f"Running in {'frozen/compiled' if getattr(sys, 'frozen', False) else 'script'} mode")
    print(f"Platform: {sys.platform}")
    print(f"Executable: {sys.executable}")
    print(f"Working directory: {os.getcwd()}")
    
    # Create main window
    root = tk.Tk()
    
    # Create application
    app = RT11ExtractGUI(root)
    
    # Handle window closing
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    
    # Start application
    print("Starting main loop...\n")
    root.mainloop()

if __name__ == '__main__':
    main()
