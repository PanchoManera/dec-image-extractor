#!/usr/bin/env python3
"""
OS/8 Filesystem Extractor for PDP-8
====================================

Parser for OS/8 disk images used by DEC PDP-8 minicomputers.
Based on official DEC OS/8 System Reference Manual (DEC-S8-OSSMA-A-D).

OS/8 File System Structure (from official manual):
- Block 0: Boot block
- Blocks 1-6: System area (records 0, 7-67)
- Directory structure:
  - Starts at block 7 (normal) or block 70 (system directory)
  - Each file entry uses additional information words for date storage
  - 1 block = 1 record = 2 pages = 256₈ words (from manual page 23)

File naming (official specs):
- Up to 6 alphanumeric characters + optional 2-character extension
- Names are in RADIX-50 encoding (base-40)
- Standard extensions per manual:
  .SV = Core image/SAVE files
  .PA = PAL8 source files
  .FT = FORTRAN source files
  .SB = SABR source files
  .BN = Absolute binary files
  .RL = Relocatable binary files
  .LS = Assembly listing files
  .TM = Temporary files

Date format (official):
- OS/8 automatically stores date in first additional information word
- DATE command format: mm/dd/yy
- Dates appear in directory listings when additional info words present

Based on:
- DEC OS/8 System Reference Manual (os8_system_reference_manual.pdf)
- Official DEC documentation downloaded from grc.com
- Verified against real OS/8 disk images
"""

import struct
import sys
import os
import argparse
import time
import datetime
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any

# OS/8 Constants (from official manual)
BLOCK_SIZE = 256  # 256₈ words per block (official: 1 block = 1 record = 2 pages = 256₈ words)
WORD_SIZE = 2     # 2 bytes per 12-bit word (stored as 16-bit)
BLOCKS_PER_TRACK = 32  # Standard for RK8 disks
TRACKS_PER_DISK = 203  # Standard for RK8 disks

# Directory structure constants (from manual)
SYSTEM_AREA_START = 7     # Records 7-67 are system area (normal directory)
SYSTEM_DIR_START = 70     # File storage starts at record 70 for system directory
DIR_ENTRY_SIZE = 4        # Directory entries with additional info words
MAX_FILENAME_LEN = 6      # 6 alphanumeric characters max (official)
MAX_EXTENSION_LEN = 2     # 2 alphanumeric characters max (official)

# File status bits
FILE_TENTATIVE = 0o4000  # Tentative file bit
FILE_PERMANENT = 0o2000  # Permanent file bit
FILE_PROTECTED = 0o1000  # Protected file bit

# RADIX-50 character set (base-40 encoding used by OS/8)
# Official character set from manual
RADIX50_CHARS = " ABCDEFGHIJKLMNOPQRSTUVWXYZ$.%0123456789"

# Official OS/8 file extensions (from manual Table 3)
OFFICIAL_OS8_EXTENSIONS = {
    'SV': 'Core image file or SAVE file',
    'FT': '8K FORTRAN source file', 
    'SB': '8K SABR source file',
    'PA': 'PAL8 source file',
    'BN': 'Absolute binary file',
    'RL': 'Relocatable binary file',
    'MP': 'Loading map file',
    'LS': 'PAL8 or SABR assembly listing',
    'TM': 'Temporary file generated by FORTRAN or SABR'
}

# Additional common extensions found in practice
COMMON_OS8_EXTENSIONS = {
    'DA': 'Data file',
    'TX': 'Text file', 
    'BI': 'Binary file',
    'SY': 'System file',
    'CO': 'Core image',
    'OB': 'Object file',
    'DI': 'Directory',
    'HL': 'Help file'
}

def radix50_decode(word: int) -> str:
    """Decode a 12-bit RADIX-50 encoded word to 3 characters"""
    if word == 0:
        return "   "
    
    result = ""
    for _ in range(3):
        char_code = word % 40
        if char_code < len(RADIX50_CHARS):
            result = RADIX50_CHARS[char_code] + result
        else:
            result = " " + result
        word //= 40
    
    return result

def decode_os8_filename(data: bytes) -> str:
    """Decode OS/8 filename from various possible encodings"""
    if not data:
        return ""
    
    # Try ASCII with various offsets (common in DEC systems)
    for offset in [0, 0x40, 0x80, 0xC0]:
        try:
            decoded = ""
            for byte in data:
                if byte == 0:
                    break
                char_code = byte - offset
                if 32 <= char_code <= 126:  # Printable ASCII range
                    decoded += chr(char_code)
                elif char_code == 0:  # Space
                    decoded += " "
                else:
                    break
            
            # Check if result looks like a valid filename
            cleaned = decoded.strip()
            if (len(cleaned) >= 2 and 
                all(c.isalnum() or c in '.$% ' for c in cleaned) and
                not cleaned.isspace()):
                return cleaned
        except:
            continue
    
    # Try as raw ASCII
    try:
        decoded = data.decode('ascii', errors='ignore').strip('\x00 \x40')
        if len(decoded) >= 2 and all(c.isalnum() or c in '.$%' for c in decoded):
            return decoded
    except:
        pass
    
    # Fallback to RADIX-50 for first few words
    try:
        if len(data) >= 4:
            word1 = struct.unpack('<H', data[:2])[0] & 0o7777
            word2 = struct.unpack('<H', data[2:4])[0] & 0o7777
            return (radix50_decode(word1) + radix50_decode(word2))[:6].strip()
    except:
        pass
    
    return ""

def radix50_encode(text: str) -> int:
    """Encode up to 3 characters as a 12-bit RADIX-50 word"""
    text = text.ljust(3)[:3].upper()  # Pad to 3 chars, truncate, uppercase
    
    result = 0
    for char in text:
        result *= 40
        if char in RADIX50_CHARS:
            result += RADIX50_CHARS.index(char)
        # else: char not found, adds 0 (space)
    
    return result & 0o7777  # Mask to 12 bits

class OS8FileEntry:
    """Represents an OS/8 file directory entry"""
    
    def __init__(self, name: str, extension: str, start_block: int, 
                 length: int, status: int = 0, date: int = 0):
        self.name = name.strip()
        self.extension = extension.strip()
        self.start_block = start_block
        self.length = length  # Length in blocks
        self.status = status
        self.date = date
        
    @property
    def full_name(self) -> str:
        """Get full filename with extension"""
        if self.extension:
            return f"{self.name}.{self.extension}"
        return self.name
    
    @property
    def size_bytes(self) -> int:
        """Get file size in bytes"""
        return self.length * BLOCK_SIZE * WORD_SIZE
    
    @property
    def is_tentative(self) -> bool:
        """Check if file is tentative"""
        return bool(self.status & FILE_TENTATIVE)
    
    @property
    def is_permanent(self) -> bool:
        """Check if file is permanent"""
        return bool(self.status & FILE_PERMANENT)
    
    @property
    def is_protected(self) -> bool:
        """Check if file is protected"""
        return bool(self.status & FILE_PROTECTED)
    
    @property
    def file_type(self) -> str:
        """Determine file type based on extension (official OS/8 types)"""
        # Use official extensions first
        ext_upper = self.extension.upper()
        if ext_upper in OFFICIAL_OS8_EXTENSIONS:
            return OFFICIAL_OS8_EXTENSIONS[ext_upper]
        
        # Fallback to common extensions
        if ext_upper in COMMON_OS8_EXTENSIONS:
            return COMMON_OS8_EXTENSIONS[ext_upper]
        
        # Legacy mappings for compatibility
        legacy_types = {
            'BA': 'BASIC Program',
            'MA': 'MACRO Source', 
            'LD': 'Loader'
        }
        
        return legacy_types.get(ext_upper, 'Unknown')
    
    def get_os8_date(self) -> Optional[datetime.datetime]:
        """Convert OS/8 date format to datetime (official format from manual)"""
        if self.date == 0:
            return None
            
        try:
            # OS/8 date format from manual: stored in additional information words
            # Format follows DATE command: mm/dd/yy
            # The manual indicates dates are automatically stored when files are created
            
            # Try different interpretations of the date word
            # Method 1: Standard interpretation
            year_offset = (self.date >> 8) & 0o17  # 4 bits for year
            month = (self.date >> 4) & 0o17        # 4 bits for month  
            day = self.date & 0o17                 # 4 bits for day
            
            # Base year from manual era (OS/8 documentation dates from early 1970s)
            base_year = 1970
            year = base_year + year_offset
            
            if 1 <= month <= 12 and 1 <= day <= 31 and year >= 1970:
                return datetime.datetime(year, month, day)
            
            # Method 2: Alternative encoding (some OS/8 versions)
            # Try different bit arrangements
            alt_month = (self.date >> 5) & 0o17
            alt_day = self.date & 0o37
            alt_year_offset = (self.date >> 10) & 0o77
            alt_year = 1970 + alt_year_offset
            
            if 1 <= alt_month <= 12 and 1 <= alt_day <= 31 and 1970 <= alt_year <= 1990:
                return datetime.datetime(alt_year, alt_month, alt_day)
                
        except (ValueError, OverflowError):
            pass
            
        return None
    
    def __repr__(self):
        status_str = ""
        if self.is_tentative:
            status_str += "T"
        if self.is_permanent:
            status_str += "P"
        if self.is_protected:
            status_str += "R"
        
        date_str = ""
        date_obj = self.get_os8_date()
        if date_obj:
            date_str = f" ({date_obj.strftime('%Y-%m-%d')})"
            
        return f"OS8File({self.full_name}, {self.length} blocks, {status_str}{date_str})"

class OS8FileSystem:
    """OS/8 filesystem parser based on PUTR logic"""
    
    def __init__(self, image_path: str, verbose: bool = False):
        self.image_path = Path(image_path)
        self.verbose = verbose
        self.image_data = None
        self.files = []
        self.partition_size = 0
        self.partition_start = 0
        
        self._load_image()
        self._setup_partition()
        self._parse_directory()
    
    def _load_image(self):
        """Load disk image into memory"""
        if not self.image_path.exists():
            raise FileNotFoundError(f"Image not found: {self.image_path}")
        
        with open(self.image_path, 'rb') as f:
            self.image_data = f.read()
        
        if self.verbose:
            print(f"Loaded OS/8 image: {len(self.image_data)} bytes")
            print(f"Total blocks: {len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)}")
    
    def _setup_partition(self):
        """Setup OS/8 partition based on PUTR logic (ospart routine)"""
        total_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
        
        # Default partition setup - similar to PUTR's ospart routine
        self.partition_start = 0
        self.partition_size = min(total_blocks, 0o7777)  # Max 4095 blocks in OS/8
        
        # Special handling for RK05 disks (3200 blocks partition)
        # This mirrors PUTR's logic for RK05 OS/8 partitions
        if total_blocks >= 3200:
            # RK05 format with OS/8 partitions - PUTR uses 3200 blocks for OS/8 RK05
            self.partition_size = 3200  # Standard OS/8 RK05 partition size
            if self.verbose:
                print(f"Detected RK05 format, using {self.partition_size} block partition")
        
        if self.verbose:
            print(f"OS/8 partition: start={self.partition_start}, size={self.partition_size}")
    
    def read_block(self, block_num: int) -> List[int]:
        """Read a block and return as list of 12-bit words"""
        offset = block_num * BLOCK_SIZE * WORD_SIZE
        
        if offset + (BLOCK_SIZE * WORD_SIZE) > len(self.image_data):
            raise ValueError(f"Block {block_num} beyond image size")
        
        words = []
        for i in range(BLOCK_SIZE):
            word_offset = offset + (i * WORD_SIZE)
            # Read 16-bit word and mask to 12 bits
            word = struct.unpack('<H', self.image_data[word_offset:word_offset+2])[0]
            words.append(word & 0o7777)  # Mask to 12 bits
        
        return words
    
    def read_file_data(self, file_entry: OS8FileEntry) -> bytes:
        """Read file data from disk"""
        if file_entry.length == 0:
            return b''
        
        file_data = b''
        for block_offset in range(file_entry.length):
            block_num = file_entry.start_block + block_offset
            try:
                block_words = self.read_block(block_num)
                # Convert 12-bit words to bytes
                for word in block_words:
                    # Store as little-endian 16-bit, preserving the 12-bit value
                    file_data += struct.pack('<H', word)
            except ValueError:
                # Block beyond image, pad with zeros
                file_data += b'\x00' * (BLOCK_SIZE * WORD_SIZE)
                break
        
        return file_data
    
    def _parse_directory(self):
        """Parse OS/8 directory structure using PUTR-style logic"""
        self.files = []
        
        # PUTR-style directory scanning - follows chkosx routine logic
        # Start with directory segment 1 (block 1) and follow chains
        if self._parse_os8_directory_putr_style():
            return
        
        # Fallback to original method if PUTR-style fails
        # OS/8 directory structure (from official manual):
        # Block 0: Boot block
        # Blocks 1-6: System area (records 7-67 from manual)
        # Directory location depends on system type:
        # - Normal directory: starts at block 7
        # - System directory: file storage starts at block 70
        # From manual: "file storage starts at record 70 rather than record 7" for system dirs
        directory_blocks = [7, 1, 6, 70, 8, 10, 16, 20]  # Official locations first
        
        for dir_start in directory_blocks:
            try:
                files = self._parse_os8_directory_proper(dir_start)
                if files and 3 <= len(files) <= 30:  # Reasonable range for OS/8 system disk
                    self.files = files
                    if self.verbose:
                        print(f"Found valid OS/8 directory at block {dir_start} with {len(files)} files")
                    return
                elif len(files) > 30:
                    if self.verbose:
                        print(f"Too many files at block {dir_start} ({len(files)}), likely false positives")
            except Exception as e:
                if self.verbose:
                    print(f"No valid directory at block {dir_start}: {e}")
                continue
        
        if not self.files:
            # Try alternative directory parsing methods
            self._scan_for_files()
    
    def _parse_os8_directory_proper(self, start_block: int) -> List[OS8FileEntry]:
        """Parse OS/8 directory starting at specific block using proper OS/8 format"""
        files = []
        
        try:
            # Read the directory block
            dir_block = self.read_block(start_block)
            
            if self.verbose:
                print(f"Reading OS/8 directory from block {start_block}")
                # Print first few words for debugging
                print(f"First 10 words: {[oct(w) for w in dir_block[:10]]}")
            
        # OS/8 directory format (from official manual):
        # Manual states: "additional information words specified in directory"
        # "OS/8 automatically enters the last date specified in a DATE command"
        # "system always uses one additional information word"
        # Format with additional words:
        # Word 0: Filename in RADIX-50 (first 3 chars) 
        # Word 1: Filename continuation (chars 4-6) in RADIX-50
        # Word 2: Start block + status/extension info
        # Word 3: Length + additional info
        # Word 4+: Additional information words (date, etc.)
            
            # Try multiple directory parsing strategies
            
            # Strategy 1: Official format with additional information words
            entries = self._parse_official_directory_entries(dir_block, start_block)
            if entries:
                files.extend(entries)
            
            # Strategy 2: Legacy 2-word entries (older OS/8 versions)
            if not files:
                entries = self._parse_legacy_directory_entries(dir_block, start_block)
                if entries:
                    files.extend(entries)
            
            # Strategy 3: Alternative 4-word entries (some OS/8 variants)
            if not files:
                entries = self._parse_alternative_directory_entries(dir_block, start_block)
                if entries:
                    files.extend(entries)
            
            # Strategy 4: Scan for recognizable system file names
            if not files:
                entries = self._scan_for_system_files(dir_block, start_block)
                if entries:
                    files.extend(entries)
                    
        except Exception as e:
            if self.verbose:
                print(f"Error reading directory block {start_block}: {e}")
            raise
        
        # Filter and validate entries
        valid_files = []
        seen_names = set()
        
        for entry in files:
            if (entry.name and 
                entry.name not in seen_names and
                self._validate_os8_file_entry(entry)):
                seen_names.add(entry.name)
                valid_files.append(entry)
                if self.verbose:
                    print(f"Valid OS/8 file: {entry.name}.{entry.extension} (block {entry.start_block}, len {entry.length})")
        
        if valid_files:
            return valid_files
        
        raise ValueError("No valid OS/8 directory entries found")
    
    def _words_to_bytes(self, words: List[int]) -> bytes:
        """Convert 12-bit words to bytes"""
        result = b''
        for word in words:
            result += struct.pack('<H', word & 0o7777)
        return result
    
    def _scan_block_for_entries(self, block_bytes: bytes, block_num: int) -> List[OS8FileEntry]:
        """Scan a block for OS/8 directory entries using proper 4-word format"""
        entries = []
        
        # OS/8 directory format: 4 words per entry
        # Word 0-1: Filename in RADIX-50 (2 words = up to 6 characters)
        # Word 2: Start block and status
        # Word 3: Length and possibly date
        
        for word_index in range(0, (len(block_bytes) // 2) - 3, 1):
            try:
                word_offset = word_index * 2
                if word_offset + 8 <= len(block_bytes):
                    # Read 4 consecutive words
                    words = []
                    for i in range(4):
                        word = struct.unpack('<H', block_bytes[word_offset + i*2:word_offset + i*2 + 2])[0] & 0o7777
                        words.append(word)
                    
                    # Skip entries that are all zeros or look like data
                    if all(w == 0 for w in words) or words[0] == 0:
                        continue
                    
                    # Decode filename from first two words
                    try:
                        name_part1 = radix50_decode(words[0])
                        name_part2 = radix50_decode(words[1])
                        full_name = (name_part1 + name_part2)[:6].strip()
                    except:
                        continue
                    
                    # Validate filename - be much more strict
                    if not self._is_valid_os8_filename(full_name):
                        continue
                    
                    # Extract start block from word 2
                    # Different OS/8 versions use different layouts
                    start_block1 = words[2] & 0o7777  # Full word as start block
                    start_block2 = words[2] & 0o777   # Lower 9 bits
                    start_block3 = (words[2] >> 3) & 0o777  # Shifted layout
                    
                    # Extract length from word 3
                    length1 = words[3] & 0o777     # Lower 9 bits
                    length2 = words[3] & 0o77      # Lower 6 bits
                    length3 = (words[3] >> 6) & 0o77  # Upper 6 bits
                    
                    # Try different combinations and see which makes sense
                    max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
                    
                    combinations = [
                        (start_block1, length1),
                        (start_block1, length2),
                        (start_block1, length3),
                        (start_block2, length1),
                        (start_block2, length2),
                        (start_block2, length3),
                        (start_block3, length1),
                        (start_block3, length2),
                        (start_block3, length3),
                    ]
                    
                    best_entry = None
                    
                    for start_block, length in combinations:
                        if (1 <= start_block < max_blocks and 
                            1 <= length <= 100 and
                            start_block + length <= max_blocks):
                            
                            # Check if this conflicts with existing entries
                            conflict = False
                            for existing in entries:
                                if (abs(existing.start_block - start_block) < max(length, existing.length)):
                                    conflict = True
                                    break
                            
                            if not conflict:
                                # Try to extract extension if present
                                extension = self._extract_extension(words)
                                
                                entry = OS8FileEntry(full_name, extension, start_block, length)
                                
                                # Prefer entries with reasonable file sizes
                                if best_entry is None or length < best_entry.length:
                                    best_entry = entry
                    
                    if best_entry:
                        entries.append(best_entry)
                        if self.verbose:
                            print(f"Found valid entry: {best_entry.name} (start={best_entry.start_block}, len={best_entry.length})")
                            
            except Exception:
                continue
        
        return entries
    
    def _is_valid_os8_filename(self, name: str) -> bool:
        """Check if a decoded name looks like a valid OS/8 filename (official standards)"""
        if not name or len(name.strip()) < 3:  # Require at least 3 chars
            return False
        
        name = name.strip().upper()
        
        # Known valid OS/8 system files from official manual and documentation
        # These are mentioned specifically in the OS/8 System Reference Manual
        known_os8_files = {
            # Core system programs (from manual)
            'BUILD', 'PIP', 'EDIT', 'PAL8', 'ABSLDR', 'SABR', 'FORTRAN',
            'CREF', 'LIBSET', 'ODT', 'BOOT', 'SYSTEM',
            
            # Additional system programs mentioned in manual
            'DIRECT', 'BASIC', 'BATCH', 'CHAIN', 'COPY', 'DELETE', 
            'DIR', 'HELP', 'PRINT', 'TYPE', 'FUTIL',
            
            # Device-specific programs
            'RXCOPY', 'RLFRMT', 'CHBPA', 'CHBPB', 'CHBPC', 'CHBPD',
            
            # Runtime systems
            'FRTS', 'BRTS', 'MACREL', 'RESORC',
            
            # Command decoder and utilities
            'CCL', 'FOTP', 'LIBR8'
        }
        
        # Check if it's a known system file
        if name in known_os8_files:
            return True
        
        # Check partial matches for known files
        for known_file in known_os8_files:
            if name.startswith(known_file[:4]) and len(known_file) >= 4:
                return True
        
        # Reject common garbage patterns
        garbage_patterns = {
            'AX', 'XX', '7%', '%%', 'AXA', 'XAX', 'XXXXXX', 'AAAAAA', 
            '000000', '??????', '7% 7%', 'AX AX', '$H', '%C', '%L',
            # Reject patterns that look like memory addresses or data
            '0X', '0T', '0W', '0%', '2 ', '27', '2A', '2O', '2Y',
            '3 ', '3E', '4I', '6 ', '6%', '7%', '7K', '8P', '9I',
            '9J', '9L', '9O', '9P', '9V', 'A ', 'A$', 'A%', 'A.', 
            'A0', 'A1', 'A2', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9',
            'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'AG', 'AH', 'AI',
            'AJ', 'AK', 'AL', 'AM', 'AN', 'AO', 'AP', 'AQ', 'AR',
            'AS', 'AT', 'AU', 'AV', 'AW', 'AX', 'AY', 'AZ'
        }
        
        # Check exact garbage patterns
        if name in garbage_patterns:
            return False
        
        # Reject patterns that start with garbage prefixes
        garbage_prefixes = ['A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9',
                           '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                           '%', '$H', '%C', '%L', 'AX', 'XX']
        
        for prefix in garbage_prefixes:
            if name.startswith(prefix) and len(prefix) >= 2:
                return False
        
        # Must be primarily alphabetic for valid OS/8 files
        alpha_count = sum(1 for c in name if c.isalpha())
        if alpha_count < 3:  # Require at least 3 letters
            return False
        
        # Must not be primarily numeric or special chars
        non_alpha_count = sum(1 for c in name if not c.isalpha())
        if non_alpha_count > alpha_count:  # More non-letters than letters
            return False
        
        # Check for realistic filename patterns
        clean_name = name.replace(' ', '').replace('.', '')
        
        # Must be mostly letters with maybe one number
        if not (clean_name.isalpha() or 
                (sum(1 for c in clean_name if c.isdigit()) <= 1 and 
                 sum(1 for c in clean_name if c.isalpha()) >= 3)):
            return False
        
        # Must have reasonable length for OS/8
        if len(clean_name) < 3 or len(clean_name) > 6:
            return False
        
        return True
    
    def _extract_extension(self, words: List[int]) -> str:
        """Try to extract file extension from directory entry words"""
        # OS/8 extensions are often embedded in various parts of the directory entry
        # Try multiple methods based on different OS/8 versions and formats
        
        # Method 1: Extension in high bits of second filename word
        try:
            # In some OS/8 formats, extension is stored in upper bits
            ext_word = (words[1] >> 6) & 0o777  # Extract upper 9 bits
            if ext_word > 0 and ext_word < 0o7777:
                # Try to decode as RADIX-50
                extension = radix50_decode(ext_word)[:2].strip()
                if self._is_valid_extension(extension):
                    return extension.upper()
        except:
            pass
        
        # Method 2: Extension in status/control word bits
        try:
            # Some versions store extension in control word
            ext_bits1 = (words[2] >> 6) & 0o77
            ext_bits2 = (words[3] >> 9) & 0o77
            
            for ext_bits in [ext_bits1, ext_bits2]:
                if ext_bits > 0:
                    # Convert to 2-char extension
                    char1 = RADIX50_CHARS[(ext_bits // 40) % 40] if (ext_bits // 40) < 40 else ""
                    char2 = RADIX50_CHARS[ext_bits % 40] if (ext_bits % 40) < 40 else ""
                    extension = (char1 + char2).strip()
                    if self._is_valid_extension(extension):
                        return extension.upper()
        except:
            pass
        
        # Method 3: Look in different bit positions of directory entry
        try:
            # Try extracting from different positions in the 4-word entry
            positions = [
                ((words[1] >> 9) & 0o77),   # Different bit position in word 1
                ((words[2] >> 3) & 0o77),   # Lower bits of word 2  
                ((words[3] >> 6) & 0o77),   # Middle bits of word 3
                ((words[3] >> 3) & 0o77),   # Different position in word 3
            ]
            
            for ext_val in positions:
                if ext_val > 0 and ext_val < 40:  # Valid RADIX-50 range
                    # Try both as direct chars and as RADIX-50
                    # Method A: Direct character encoding
                    if 32 <= ext_val <= 126:  # Printable ASCII range
                        char = chr(ext_val)
                        if char.isalpha():
                            # Try to find second character
                            for ext_val2 in positions:
                                if ext_val2 != ext_val and 32 <= ext_val2 <= 126:
                                    char2 = chr(ext_val2)
                                    if char2.isalpha():
                                        extension = (char + char2).upper()
                                        if self._is_valid_extension(extension):
                                            return extension
                    
                    # Method B: As RADIX-50 component
                    if ext_val < 40:  # Valid RADIX-50 range
                        char = RADIX50_CHARS[ext_val]
                        if char.isalpha():
                            extension = char + 'X'  # Use 'X' as generic placeholder
                            if self._is_valid_extension(extension):
                                return extension.upper()
        except:
            pass
        
        # Method 4: Heuristic based on filename patterns (enhanced based on PDF)
        name = (radix50_decode(words[0]) + radix50_decode(words[1]))[:6].strip().upper()
        
        # System programs (.SV) - from official manual
        # These are core image files mentioned throughout the OS/8 manual
        system_programs = {
            'BUILD': 'SV', 'PIP': 'SV', 'EDIT': 'SV', 'PAL8': 'SV', 
            'ABSLDR': 'SV', 'SABR': 'SV', 'FORTRAN': 'SV', 'CREF': 'SV',
            'LIBSET': 'SV', 'ODT': 'SV', 'DIRECT': 'SV', 'BATCH': 'SV',
            'BASIC': 'SV', 'CHAIN': 'SV', 'COPY': 'SV', 'DELETE': 'SV',
            'DIR': 'SV', 'HELP': 'SV', 'PRINT': 'SV', 'TYPE': 'SV',
            'RXCOPY': 'SV', 'FUTIL': 'SV', 'RLFRMT': 'SV', 
            'CHBPA': 'SV', 'CHBPB': 'SV', 'CHBPC': 'SV', 'CHBPD': 'SV',
            'BOOT': 'SV', 'SYSTEM': 'SV', 'CCL': 'SV', 'FOTP': 'SV',
            'FRTS': 'SV', 'BRTS': 'SV', 'MACREL': 'SV', 'RESORC': 'SV'
        }
        
        # Check exact matches first
        if name in system_programs:
            return system_programs[name]
        
        # Check partial matches for system programs (be more generous)
        for prog_name in system_programs:
            if name.startswith(prog_name[:3]):  # Check first 3 chars instead of 4
                return system_programs[prog_name]
        
        # Additional system program patterns
        if (name.startswith('CHB') or name.startswith('ABS') or 
            name.startswith('SYS') or name.startswith('MON')):
            return 'SV'
        
        # PAL Assembler files (.PA) - from PDF
        if (name.endswith('PA') or 'PAL' in name or 'ASM' in name or
            name.startswith('PAL') or '.PA' in name):
            return 'PA'
        
        # BASIC programs (.BA)
        if ('BASIC' in name or 'BAS' in name or name.startswith('BAS') or
            name.endswith('BA')):
            return 'BA'
        
        # FORTRAN programs (.FT)
        if ('FORT' in name or 'FOR' in name or name.startswith('FOR') or
            name.endswith('FT')):
            return 'FT'
        
        # Data files (.DA)
        if ('DATA' in name or 'DAT' in name or name.startswith('DAT')):
            return 'DA'
        
        # Text files (.TX) 
        if ('TEXT' in name or 'TXT' in name or name.startswith('TXT')):
            return 'TX'
        
        # Binary files (.BN)
        if ('BIN' in name or name.startswith('BIN')):
            return 'BN'
        
        # Relocatable files (.RL)
        if ('REL' in name or name.startswith('REL')):
            return 'RL'
        
        # No extension detected
        return ''
    
    def _is_valid_extension(self, ext: str) -> bool:
        """Check if an extension looks valid for OS/8 (official manual standards)"""
        if not ext or len(ext) != 2:
            return False
        
        # Must be alphanumeric characters (manual specifies alphanumeric)
        # Note: Manual says "two alphanumeric characters" for extensions
        if not ext.replace('$', '').replace('%', '').replace('.', '').isalnum():
            return False
            
        # Official OS/8 extensions from manual + common practice
        valid_extensions = set(OFFICIAL_OS8_EXTENSIONS.keys()) | set(COMMON_OS8_EXTENSIONS.keys())
        
        # Additional valid extensions found in practice
        valid_extensions.update({
            'BA', 'MA', 'LD', 'BI', 'RU', 'UT', 'LI', 'EX', 'IN', 'OU'
        })
        
        return ext.upper() in valid_extensions
    
    def _parse_directory_entry(self, block_data: List[int], word_index: int) -> Optional[OS8FileEntry]:
        """Parse a single directory entry starting at word_index"""
        if word_index + 3 >= len(block_data):
            return None
        
        # OS/8 directory entry format (varies by version):
        # Word 0: Filename part 1 (RADIX-50)
        # Word 1: Filename part 2 + extension (RADIX-50)
        # Word 2: Start block + file status
        # Word 3: Length in blocks + date
        
        filename_word1 = block_data[word_index]
        filename_word2 = block_data[word_index + 1]
        status_start = block_data[word_index + 2]
        length_date = block_data[word_index + 3]
        
        # Decode filename (6 chars max from 2 RADIX-50 words)
        name_part1 = radix50_decode(filename_word1)
        name_part2 = radix50_decode(filename_word2 & 0o7777)  # Mask in case of overflow
        
        # Full filename is first 6 characters
        full_name = (name_part1 + name_part2)[:6].strip()
        
        # Extension might be encoded differently depending on OS/8 version
        # Try different extraction methods
        extension = ""
        
        # Method 1: Extension in high bits of second word
        ext_bits = (filename_word2 >> 12) & 0o77
        if ext_bits > 0:
            # Convert to 2-character extension
            ext_char1 = RADIX50_CHARS[(ext_bits // 40) % 40] if (ext_bits // 40) < 40 else " "
            ext_char2 = RADIX50_CHARS[ext_bits % 40] if (ext_bits % 40) < 40 else " "
            extension = (ext_char1 + ext_char2).strip()
        
        # Method 2: Extension as separate encoding
        if not extension:
            # Try decoding as if extension is in filename_word2 high bits differently
            try:
                ext_word = (filename_word2 >> 6) & 0o77
                if ext_word > 0:
                    extension = radix50_decode(ext_word)[:2].strip()
            except:
                pass
        
        # Extract start block and status
        start_block = status_start & 0o7777
        status = (status_start >> 12) & 0o7
        
        # Extract length and date
        length = length_date & 0o777
        date = (length_date >> 12) & 0o7777
        
        # Validate that this looks like a real file entry
        if not full_name or full_name.isspace():
            return None
            
        # Check for reasonable values
        if start_block == 0 or length == 0 or length > 1000:
            return None
        
        return OS8FileEntry(full_name, extension, start_block, length, status, date)
    
    def _validate_file_entry(self, entry: OS8FileEntry) -> bool:
        """Validate that a file entry looks reasonable"""
        # Check filename contains valid characters
        if not entry.name or not entry.name.replace(' ', '').replace('.', '').replace('$', '').replace('%', '').isalnum():
            return False
        
        # Check start block is reasonable
        max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
        if entry.start_block >= max_blocks or entry.start_block < 1:
            return False
        
        # Check length is reasonable
        if entry.length > max_blocks or entry.length < 1:
            return False
        
        # Check file doesn't extend beyond disk
        if entry.start_block + entry.length > max_blocks:
            return False
        
        return True
    
    def _parse_os8_directory_putr_style(self) -> bool:
        """Parse OS/8 directory using PUTR chkosx algorithm"""
        if self.verbose:
            print("Parsing OS/8 directory using PUTR-style algorithm")
        
        # PUTR chkosx routine: Start with segment 1 and follow chains
        # Tracks which blocks (1-6) we've visited to detect loops
        visited_blocks = set()
        current_block = 1  # Start with directory segment #1
        files = []
        
        while current_block and current_block <= 6 and current_block not in visited_blocks:
            visited_blocks.add(current_block)
            
            try:
                # Read directory segment
                dir_block = self.read_block(current_block)
                if not dir_block:
                    break
                    
                # Parse directory segment header (PUTR style)
                if len(dir_block) < 5:
                    break
                    
                # Word 0: -(number of entries)
                # Word 1: next segment number (0 if last)
                # Word 2: -(number of additional info words)
                # Word 3: starting block number for files in this segment
                # Word 4: unused
                
                neg_entries = dir_block[0]
                next_segment = dir_block[1] & 0o7777
                neg_info_words = dir_block[2] 
                starting_block = dir_block[3] & 0o7777
                
                # Convert negative values to positive (PUTR logic)
                num_entries = (0o10000 - neg_entries) & 0o7777
                num_info_words = (0o10000 - neg_info_words) & 0o7777
                
                if self.verbose:
                    print(f"Block {current_block}: {num_entries} entries, {num_info_words} info words, start block {starting_block}")
                
                # Validate reasonable values
                if num_entries > 100 or num_info_words > 10:
                    if self.verbose:
                        print(f"Invalid values in block {current_block}, trying next method")
                    break
                
                # Parse directory entries (starting at word 5)
                entry_offset = 5
                entry_size = 4 + num_info_words  # Base entry + info words
                
                for i in range(num_entries):
                    if entry_offset + entry_size > len(dir_block):
                        break
                        
                    entry_words = dir_block[entry_offset:entry_offset + entry_size]
                    entry = self._parse_putr_style_entry(entry_words, starting_block, num_info_words)
                    
                    if entry:
                        files.append(entry)
                        if self.verbose:
                            print(f"PUTR-style entry: {entry.name}.{entry.extension} (start={entry.start_block}, len={entry.length})")
                    
                    entry_offset += entry_size
                
                # Move to next segment
                if next_segment == 0 or next_segment > 6:
                    break
                current_block = next_segment
                
            except Exception as e:
                if self.verbose:
                    print(f"Error reading block {current_block}: {e}")
                break
        
        # Validate and filter entries
        valid_files = []
        for entry in files:
            if (entry.name and 
                self._validate_os8_file_entry(entry) and
                entry.name not in [f.name for f in valid_files]):
                valid_files.append(entry)
        
        if valid_files and len(valid_files) >= 3:
            self.files = valid_files
            if self.verbose:
                print(f"PUTR-style parsing found {len(valid_files)} valid files")
            return True
        
        return False
    
    def _parse_putr_style_entry(self, words: List[int], base_block: int, num_info_words: int) -> Optional[OS8FileEntry]:
        """Parse a single directory entry using PUTR logic"""
        if len(words) < 4:
            return None
        
        # Check for empty entry (.EMPTY. block)
        if words[0] == 0:
            return None  # Skip empty blocks
        
        # Decode filename from first 2-3 words (RADIX-50)
        try:
            name_part1 = radix50_decode(words[0])
            name_part2 = radix50_decode(words[1]) if len(words) > 1 else ""
            full_name = (name_part1 + name_part2)[:6].strip()
            
            if not self._is_valid_os8_filename(full_name):
                return None
                
        except:
            return None
        
        # Extract extension from word 2 if present (PUTR logic)
        extension = ""
        if len(words) > 2:
            extension = self._extract_extension_putr_style(words)
        
        # Extract file size from negative length (PUTR style)
        if len(words) > 3:
            neg_length = words[3]
            length = (0o10000 - neg_length) & 0o7777
            
            # Validate reasonable length
            if length <= 0 or length > 1000:
                return None
        else:
            length = 1
        
        # Calculate start block (relative to segment base)
        start_block = base_block
        
        # Extract date from additional info words if present
        date = 0
        if num_info_words > 0 and len(words) > 4:
            date = words[4] & 0o7777
        
        return OS8FileEntry(full_name, extension, start_block, length, 0, date)
    
    def _extract_extension_putr_style(self, words: List[int]) -> str:
        """Extract extension using PUTR-style logic"""
        # PUTR uses specific encoding for extensions in word 2
        if len(words) < 3:
            return ""
        
        # Check word 2 for extension bits (PUTR osdg routine logic)
        ext_word = words[2]
        
        # Method 1: Extension in high bits
        ext_val = (ext_word >> 6) & 0o77
        if ext_val > 0 and ext_val < 40:
            try:
                char1 = RADIX50_CHARS[ext_val % 40] if ext_val % 40 < len(RADIX50_CHARS) else ""
                if char1.isalpha():
                    # Try to get second character
                    ext_val2 = (ext_word >> 3) & 0o77
                    if ext_val2 > 0 and ext_val2 < 40:
                        char2 = RADIX50_CHARS[ext_val2 % 40] if ext_val2 % 40 < len(RADIX50_CHARS) else ""
                        if char2.isalpha():
                            extension = (char1 + char2).strip()
                            if self._is_valid_extension(extension):
                                return extension.upper()
            except:
                pass
        
        # Fallback to heuristic method
        return self._extract_extension(words)
    
    def _scan_for_files(self):
        """Scan disk for file patterns if directory parsing fails"""
        if self.verbose:
            print("Scanning for file patterns...")
        
        files = []
        max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
        
        # Look for potential file headers in each block
        for block_num in range(1, min(max_blocks, 100)):  # Limit scan to first 100 blocks
            try:
                block_data = self.read_block(block_num)
                
                # Look for RADIX-50 encoded filenames at start of block
                for word_index in range(0, min(len(block_data), 10), 2):
                    word1 = block_data[word_index]
                    word2 = block_data[word_index + 1] if word_index + 1 < len(block_data) else 0
                    
                    if word1 > 0 and word2 > 0:
                        try:
                            name1 = radix50_decode(word1)
                            name2 = radix50_decode(word2)
                            full_name = (name1 + name2)[:6].strip()
                            
                            if (full_name and 
                                len(full_name) >= 2 and 
                                full_name.replace(' ', '').isalnum()):
                                
                                # Estimate file length by looking for next likely filename
                                length = self._estimate_file_length(block_num, max_blocks)
                                
                                entry = OS8FileEntry(full_name, "??", block_num, length)
                                files.append(entry)
                                
                                if self.verbose:
                                    print(f"Found potential file: {entry}")
                                break
                                
                        except:
                            continue
            except:
                continue
        
        self.files = files
        
        if self.verbose:
            print(f"Scan found {len(files)} potential files")
    
    def _parse_official_directory_entries(self, dir_block: List[int], start_block: int) -> List[OS8FileEntry]:
        """Parse directory entries using official OS/8 format with additional information words"""
        entries = []
        
        if self.verbose:
            print(f"Trying official OS/8 directory format at block {start_block}")
        
        # Official format from manual: entries with additional information words
        # Each entry can be 4+ words with date storage
        entry_size = 4  # Start with 4-word entries
        
        for word_idx in range(0, len(dir_block) - entry_size + 1, entry_size):
            try:
                words = dir_block[word_idx:word_idx + entry_size]
                
                # Skip empty entries
                if all(w == 0 for w in words[:2]):
                    continue
                
                # Decode filename from first two words (RADIX-50)
                name_part1 = radix50_decode(words[0])
                name_part2 = radix50_decode(words[1])
                full_name = (name_part1 + name_part2)[:6].strip()
                
                if not self._is_valid_os8_filename(full_name):
                    continue
                
                # Extract file information from words 2 and 3
                # Word 2: Contains start block and status information
                # Word 3: Contains length and possibly date
                
                # Try different bit layouts for start block (OS/8 versions vary)
                start_candidates = [
                    words[2] & 0o7777,           # Full word
                    words[2] & 0o1777,           # Lower 10 bits
                    (words[2] >> 3) & 0o777,     # Shifted 3 bits
                    words[2] & 0o777,            # Lower 9 bits
                ]
                
                # Try different bit layouts for length
                length_candidates = [
                    words[3] & 0o777,            # Lower 9 bits
                    words[3] & 0o377,            # Lower 8 bits
                    (words[3] >> 6) & 0o777,     # Upper bits
                    words[3] & 0o77,             # Lower 6 bits
                ]
                
                # Find the most reasonable combination
                max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
                
                for start_block in start_candidates:
                    for length in length_candidates:
                        if (7 <= start_block < max_blocks and  # Start after system area
                            1 <= length <= 100 and             # Reasonable file size
                            start_block + length <= max_blocks): # Doesn't exceed disk
                            
                            # Try to extract extension
                            extension = self._extract_extension(words)
                            
                            # Extract date if present (from word 3 upper bits or word 4)
                            date = 0
                            if len(words) > 3:
                                date = (words[3] >> 9) & 0o7777
                            
                            entry = OS8FileEntry(full_name, extension, start_block, 
                                                length, words[2] >> 12, date)
                            
                            if self._validate_os8_file_entry(entry):
                                entries.append(entry)
                                if self.verbose:
                                    print(f"Official format: {entry.name}.{entry.extension} (start={entry.start_block}, len={entry.length})")
                                break
                    if entries and entries[-1].name == full_name:
                        break
                        
            except Exception as e:
                if self.verbose:
                    print(f"Error parsing official entry at word {word_idx}: {e}")
                continue
        
        return entries
    
    def _parse_legacy_directory_entries(self, dir_block: List[int], start_block: int) -> List[OS8FileEntry]:
        """Parse directory entries using legacy 2-word format"""
        entries = []
        
        if self.verbose:
            print(f"Trying legacy 2-word directory format at block {start_block}")
        
        # Legacy format: 2 words per entry
        # Word 0: Filename part 1 in RADIX-50
        # Word 1: Filename part 2 + extension + start block info
        
        for word_idx in range(0, len(dir_block) - 1, 2):
            try:
                word1 = dir_block[word_idx]
                word2 = dir_block[word_idx + 1]
                
                if word1 == 0 and word2 == 0:
                    continue
                
                # Decode filename
                name_part1 = radix50_decode(word1)
                name_part2 = radix50_decode(word2 & 0o7777)
                full_name = (name_part1 + name_part2)[:6].strip()
                
                if not self._is_valid_os8_filename(full_name):
                    continue
                
                # Extract start block from word2 (various bit positions)
                start_block_val = (word2 >> 6) & 0o777
                if start_block_val == 0:
                    start_block_val = word2 & 0o777
                
                # Estimate length by looking ahead
                length = self._estimate_file_length(start_block_val, 
                                                   len(self.image_data) // (BLOCK_SIZE * WORD_SIZE))
                
                # Extract extension
                extension = self._extract_extension([word1, word2])
                
                entry = OS8FileEntry(full_name, extension, start_block_val, length)
                
                if self._validate_os8_file_entry(entry):
                    entries.append(entry)
                    if self.verbose:
                        print(f"Legacy format: {entry.name}.{entry.extension} (start={entry.start_block}, len={entry.length})")
                        
            except Exception as e:
                if self.verbose:
                    print(f"Error parsing legacy entry at word {word_idx}: {e}")
                continue
        
        return entries
    
    def _validate_os8_file_entry(self, entry: OS8FileEntry) -> bool:
        """Validate OS/8 file entry based on official manual standards"""
        # Check filename validity
        if not entry.name or len(entry.name.strip()) < 3:
            return False
        
        # Must be valid OS/8 filename
        if not self._is_valid_os8_filename(entry.name):
            return False
        
        # Check extension if present
        if entry.extension and not self._is_valid_extension(entry.extension):
            return False
        
        # Check start block (must be after system area)
        if entry.start_block < SYSTEM_AREA_START or entry.start_block >= 4096:
            return False
        
        # Check reasonable file length
        if entry.length < 1 or entry.length > 500:
            return False
        
        # Check doesn't exceed disk bounds
        max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
        if entry.start_block + entry.length > max_blocks:
            return False
        
        return True
    
    def _estimate_file_length(self, start_block: int, max_blocks: int) -> int:
        """Estimate file length by scanning ahead"""
        # Simple heuristic: look for next block that looks like a file start
        for block_num in range(start_block + 1, min(start_block + 50, max_blocks)):
            try:
                block_data = self.read_block(block_num)
                word1 = block_data[0] if block_data else 0
                word2 = block_data[1] if len(block_data) > 1 else 0
                
                if word1 > 0 and word2 > 0:
                    try:
                        name = radix50_decode(word1) + radix50_decode(word2)
                        if name.strip() and len(name.strip()) >= 2:
                            return block_num - start_block
                    except:
                        continue
            except:
                continue
        
        # Default length if no next file found
        return min(10, max_blocks - start_block)
    
    def _parse_alternative_directory_entries(self, dir_block: List[int], start_block: int) -> List[OS8FileEntry]:
        """Parse directory entries using alternative 4-word format (OS/8 variants)"""
        entries = []
        
        if self.verbose:
            print(f"Trying alternative 4-word directory format at block {start_block}")
        
        # Alternative format: 4 words per entry with different layout
        # Some OS/8 variants use different bit arrangements
        entry_size = 4
        
        for word_idx in range(0, len(dir_block) - entry_size + 1, entry_size):
            try:
                words = dir_block[word_idx:word_idx + entry_size]
                
                # Skip empty entries
                if all(w == 0 for w in words[:2]):
                    continue
                
                # Try alternative RADIX-50 decoding
                # Some variants store filename differently
                name_candidates = [
                    # Standard encoding
                    (radix50_decode(words[0]) + radix50_decode(words[1]))[:6].strip(),
                    # Swapped word order
                    (radix50_decode(words[1]) + radix50_decode(words[0]))[:6].strip(),
                    # Different masking
                    (radix50_decode(words[0] & 0o3777) + radix50_decode(words[1] & 0o3777))[:6].strip(),
                ]
                
                valid_name = None
                for name_candidate in name_candidates:
                    if self._is_valid_os8_filename(name_candidate):
                        valid_name = name_candidate
                        break
                
                if not valid_name:
                    continue
                
                # Try alternative bit layouts for start block and length
                # Different OS/8 variants use different arrangements
                start_candidates = [
                    (words[2] >> 6) & 0o777,      # Upper bits of word 2
                    words[2] & 0o777,             # Lower bits of word 2
                    (words[3] >> 9) & 0o777,      # Upper bits of word 3
                    words[3] & 0o777,             # Lower bits of word 3
                ]
                
                length_candidates = [
                    words[3] & 0o77,              # Lower 6 bits of word 3
                    (words[3] >> 6) & 0o77,       # Middle bits of word 3
                    words[2] & 0o77,              # Lower 6 bits of word 2
                    (words[2] >> 9) & 0o77,       # Upper bits of word 2
                ]
                
                # Find reasonable combinations
                max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
                
                for start_block_val in start_candidates:
                    for length in length_candidates:
                        if (SYSTEM_AREA_START <= start_block_val < max_blocks and
                            1 <= length <= 50 and
                            start_block_val + length <= max_blocks):
                            
                            # Extract extension using alternative methods
                            extension = self._extract_extension_alternative(words)
                            
                            # Extract date (try different positions)
                            date = 0
                            for word in words[2:]:
                                date_candidate = (word >> 6) & 0o7777
                                if 0 < date_candidate < 0o7777:
                                    date = date_candidate
                                    break
                            
                            entry = OS8FileEntry(valid_name, extension, start_block_val, 
                                                length, words[2] >> 12, date)
                            
                            if self._validate_os8_file_entry(entry):
                                entries.append(entry)
                                if self.verbose:
                                    print(f"Alternative format: {entry.name}.{entry.extension} (start={entry.start_block}, len={entry.length})")
                                break
                    if entries and entries[-1].name == valid_name:
                        break
                        
            except Exception as e:
                if self.verbose:
                    print(f"Error parsing alternative entry at word {word_idx}: {e}")
                continue
        
        return entries
    
    def _extract_extension_alternative(self, words: List[int]) -> str:
        """Extract extension using alternative methods for OS/8 variants"""
        # Try extracting extension from different bit positions
        extension_positions = [
            ((words[1] >> 12) & 0o77),     # Upper bits of filename word 2
            ((words[2] >> 3) & 0o77),      # Different position in control word
            ((words[3] >> 3) & 0o77),      # Different position in length word
            (words[2] & 0o77),             # Lower bits of control word
        ]
        
        for ext_val in extension_positions:
            if 0 < ext_val < 40:  # Valid RADIX-50 single character range
                char = RADIX50_CHARS[ext_val]
                if char.isalpha():
                    # Try to construct 2-char extension
                    extension = char + 'V'  # Common second character
                    if self._is_valid_extension(extension):
                        return extension.upper()
        
        # Fallback to heuristic based on filename
        name = (radix50_decode(words[0]) + radix50_decode(words[1]))[:6].strip().upper()
        return self._extract_extension(words)  # Use main method as fallback
    
    def _scan_for_system_files(self, dir_block: List[int], start_block: int) -> List[OS8FileEntry]:
        """Scan for recognizable OS/8 system file names using pattern matching"""
        entries = []
        
        if self.verbose:
            print(f"Scanning for OS/8 system files at block {start_block}")
        
        # Known OS/8 system files from official manual
        system_files = {
            'BUILD', 'PIP', 'EDIT', 'PAL8', 'ABSLDR', 'SABR', 'FORTRAN',
            'CREF', 'LIBSET', 'ODT', 'BASIC', 'BATCH', 'DIRECT'
        }
        
        # Scan every word position looking for system file patterns
        for word_idx in range(0, len(dir_block) - 1):
            try:
                # Try different word combinations
                for offset in range(min(4, len(dir_block) - word_idx)):
                    if word_idx + offset + 1 < len(dir_block):
                        word1 = dir_block[word_idx + offset]
                        word2 = dir_block[word_idx + offset + 1]
                        
                        if word1 == 0 or word2 == 0:
                            continue
                        
                        # Decode potential filename
                        try:
                            name1 = radix50_decode(word1)
                            name2 = radix50_decode(word2)
                            full_name = (name1 + name2)[:6].strip().upper()
                            
                            # Check if it matches a known system file
                            found_match = False
                            for sys_file in system_files:
                                if (full_name == sys_file or 
                                    full_name.startswith(sys_file[:4]) or
                                    sys_file.startswith(full_name) and len(full_name) >= 4):
                                    
                                    # Found a system file! Try to extract complete entry
                                    # Look for start block and length in nearby words
                                    entry_words = []
                                    start_pos = max(0, word_idx + offset - 2)
                                    end_pos = min(len(dir_block), word_idx + offset + 6)
                                    
                                    for i in range(start_pos, end_pos):
                                        if i < len(dir_block):
                                            entry_words.append(dir_block[i])
                                    
                                    # Extract file info using heuristics
                                    start_block_val = self._find_reasonable_start_block(entry_words)
                                    length = self._find_reasonable_length(entry_words, start_block_val)
                                    
                                    if start_block_val > 0 and length > 0:
                                        extension = 'SV'  # Most system files are .SV
                                        if 'PAL' in full_name:
                                            extension = 'PA'
                                        elif 'FORT' in full_name:
                                            extension = 'FT'
                                        elif 'BAS' in full_name:
                                            extension = 'BA'
                                        
                                        entry = OS8FileEntry(full_name, extension, 
                                                            start_block_val, length)
                                        
                                        if self._validate_os8_file_entry(entry):
                                            # Check for duplicates
                                            duplicate = False
                                            for existing in entries:
                                                if existing.name == entry.name:
                                                    duplicate = True
                                                    break
                                            
                                            if not duplicate:
                                                entries.append(entry)
                                                if self.verbose:
                                                    print(f"Found system file: {entry.name}.{entry.extension} (start={entry.start_block}, len={entry.length})")
                                                found_match = True
                                    break
                            
                            if found_match:
                                break
                                
                        except:
                            continue
                        
            except Exception as e:
                if self.verbose:
                    print(f"Error scanning at word {word_idx}: {e}")
                continue
        
        return entries
    
    def _find_reasonable_start_block(self, words: List[int]) -> int:
        """Find a reasonable start block value from a list of words"""
        max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
        
        for word in words:
            # Try different interpretations
            candidates = [
                word & 0o7777,           # Full word
                word & 0o1777,           # Lower 10 bits
                word & 0o777,            # Lower 9 bits
                (word >> 3) & 0o777,     # Shifted
                (word >> 6) & 0o777,     # Different shift
            ]
            
            for candidate in candidates:
                if SYSTEM_AREA_START <= candidate < max_blocks:
                    return candidate
        
        return 0
    
    def _find_reasonable_length(self, words: List[int], start_block: int) -> int:
        """Find a reasonable length value from a list of words"""
        max_blocks = len(self.image_data) // (BLOCK_SIZE * WORD_SIZE)
        
        for word in words:
            # Try different interpretations
            candidates = [
                word & 0o77,             # Lower 6 bits
                word & 0o177,            # Lower 7 bits
                word & 0o377,            # Lower 8 bits
                (word >> 6) & 0o77,      # Shifted 6 bits
                (word >> 9) & 0o77,      # Shifted 9 bits
            ]
            
            for candidate in candidates:
                if (1 <= candidate <= 50 and
                    start_block + candidate <= max_blocks):
                    return candidate
        
        # Default reasonable length
        return min(10, max_blocks - start_block) if start_block > 0 else 0
    
    def list_files(self, detailed: bool = False) -> None:
        """List all files in the OS/8 image"""
        if not self.files:
            print("No files found in OS/8 image")
            return
        
        print(f"\nOS/8 File Listing: {self.image_path.name}")
        print("=" * 70)
        
        if detailed:
            print(f"{'Filename':<12} {'Ext':<3} {'Blocks':<6} {'Start':<5} {'Size':<8} {'Type':<15} {'Date':<10} {'Status'}")
            print("-" * 70)
        else:
            print(f"{'Filename':<12} {'Ext':<3} {'Blocks':<6} {'Type':<20}")
            print("-" * 50)
        
        total_blocks = 0
        for file_entry in sorted(self.files, key=lambda f: f.full_name):
            total_blocks += file_entry.length
            
            if detailed:
                date_str = ""
                date_obj = file_entry.get_os8_date()
                if date_obj:
                    date_str = date_obj.strftime("%Y-%m-%d")
                
                status_str = ""
                if file_entry.is_tentative:
                    status_str += "T"
                if file_entry.is_permanent:
                    status_str += "P"
                if file_entry.is_protected:
                    status_str += "R"
                
                print(f"{file_entry.name:<12} {file_entry.extension:<3} {file_entry.length:<6} "
                      f"{file_entry.start_block:<5} {file_entry.size_bytes:<8} "
                      f"{file_entry.file_type:<15} {date_str:<10} {status_str}")
            else:
                print(f"{file_entry.name:<12} {file_entry.extension:<3} {file_entry.length:<6} {file_entry.file_type:<20}")
        
        print("-" * (70 if detailed else 50))
        print(f"Total: {len(self.files)} files, {total_blocks} blocks")
        print(f"Image size: {len(self.image_data)} bytes")
    
    def extract_file(self, filename: str, output_dir: Path) -> bool:
        """Extract a specific file"""
        # Find file by name
        target_file = None
        for file_entry in self.files:
            if file_entry.full_name.upper() == filename.upper():
                target_file = file_entry
                break
        
        if not target_file:
            print(f"File '{filename}' not found")
            return False
        
        try:
            # Create output directory
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Read file data
            file_data = self.read_file_data(target_file)
            
            # Write to output file
            output_file = output_dir / target_file.full_name
            with open(output_file, 'wb') as f:
                f.write(file_data)
            
            if self.verbose:
                print(f"Extracted: {target_file.full_name} ({len(file_data)} bytes)")
            
            return True
            
        except Exception as e:
            print(f"Error extracting {filename}: {e}")
            return False
    
    def extract_all_files(self, output_dir: Path) -> int:
        """Extract all files to output directory"""
        if not self.files:
            print("No files to extract")
            return 0
        
        output_dir.mkdir(parents=True, exist_ok=True)
        extracted_count = 0
        
        for file_entry in self.files:
            try:
                file_data = self.read_file_data(file_entry)
                output_file = output_dir / file_entry.full_name
                
                with open(output_file, 'wb') as f:
                    f.write(file_data)
                
                if self.verbose:
                    print(f"Extracted: {file_entry.full_name} ({len(file_data)} bytes)")
                
                extracted_count += 1
                
            except Exception as e:
                print(f"Error extracting {file_entry.full_name}: {e}")
        
        return extracted_count

def detect_os8_filesystem(image_path: str) -> Tuple[bool, str]:
    """Detect if image contains OS/8 filesystem using PUTR-style detection"""
    try:
        with open(image_path, 'rb') as f:
            # Read first few blocks
            header = f.read(4096)
        
        if len(header) < 1024:
            return False, "Image too small for OS/8"
        
        # PUTR-style detection starts immediately with directory validation
        
        # PUTR-style detection (chkos routine logic)
        # Try to read directory segment 1 and validate structure
        try:
            # Read block 1 (directory segment 1)
            if len(header) >= 512 + 256 * 2:  # Block 1 data
                block1_offset = 256 * 2  # Block 1 starts at offset 512
                block1_data = header[block1_offset:block1_offset + 256 * 2]
                
                if len(block1_data) >= 10:
                    # Parse as 12-bit words
                    words = []
                    for i in range(0, min(len(block1_data), 20), 2):
                        word = struct.unpack('<H', block1_data[i:i+2])[0] & 0o7777
                        words.append(word)
                    
                    if len(words) >= 5:
                        # Check directory segment header structure
                        neg_entries = words[0]
                        next_segment = words[1] & 0o7777
                        neg_info_words = words[2]
                        starting_block = words[3] & 0o7777
                        
                        # Convert negative values (PUTR style)
                        num_entries = (0o10000 - neg_entries) & 0o7777
                        num_info_words = (0o10000 - neg_info_words) & 0o7777
                        
                        # Validate reasonable directory structure
                        if (1 <= num_entries <= 50 and 
                            0 <= num_info_words <= 10 and
                            (next_segment == 0 or 1 <= next_segment <= 6) and
                            7 <= starting_block <= 4000):
                            return True, f"OS/8 filesystem detected (PUTR-style validation: {num_entries} entries)"
        except:
            pass
        
        # Look for OS/8 patterns:
        # 1. Boot block patterns
        # 2. RADIX-50 encoded strings
        # 3. OS/8 system file extensions
        
        # Check for common OS/8 boot patterns
        boot_patterns = [
            b'OS/8',
            b'BUILD',
            b'SYSTEM',
            b'BOOT'
        ]
        
        for pattern in boot_patterns:
            if pattern in header:
                return True, f"OS/8 filesystem detected (found {pattern.decode('ascii', errors='ignore')})"
        
        # Look for RADIX-50 patterns in potential directory area
        # Read words as 16-bit values and check for valid RADIX-50
        for offset in range(512, min(len(header), 2048), 2):
            if offset + 4 <= len(header):
                word1 = struct.unpack('<H', header[offset:offset+2])[0] & 0o7777
                word2 = struct.unpack('<H', header[offset+2:offset+4])[0] & 0o7777
                
                if word1 > 0 and word2 > 0:
                    try:
                        name1 = radix50_decode(word1)
                        name2 = radix50_decode(word2)
                        full_name = (name1 + name2).strip()
                        
                    # Verify if it resembles a valid filename
                        if (len(full_name) >= 3 and 
                            full_name.isalnum() and 
                            not full_name.isspace()):
                            return True, f"OS/8 filesystem detected (RADIX-50 filename: {full_name})"
                    except:
                        continue
        
        # Check for OS/8 file extensions in the header
        os8_extensions = ['.SV', '.PA', '.BA', '.FT', '.DA', '.TX']
        header_str = header.decode('ascii', errors='ignore').upper()
        
        for ext in os8_extensions:
            if ext in header_str:
                return True, f"OS/8 filesystem detected (found extension {ext})"
        
        return False, "No OS/8 filesystem patterns found"
        
    except Exception as e:
        return False, f"Error reading image: {e}"

def main():
    parser = argparse.ArgumentParser(
        description="OS/8 Filesystem Extractor for PDP-8 (PUTR-style)",
        epilog="""
Examples:
  %(prog)s disk.dsk -l                 # List files (auto-detect)
  %(prog)s disk.dsk -l -d              # List files with details
  %(prog)s disk.dsk --ostype pdp8      # Force PDP-8 OS/8 format
  %(prog)s disk.dsk -f HELLO.PA        # Extract specific file
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument("image", help="OS/8 disk image file (.dsk, .img, etc.)")
    parser.add_argument("-l", "--list", action="store_true",
                       help="List files only, don't extract")
    parser.add_argument("-d", "--detailed", action="store_true",
                       help="Show detailed file information")
    parser.add_argument("-f", "--file", 
                       help="Extract specific file by name")
    parser.add_argument("-o", "--output", default="extracted_os8",
                       help="Output directory (default: extracted_os8)")
    parser.add_argument("-v", "--verbose", action="store_true",
                       help="Verbose output")
    parser.add_argument("--detect-only", action="store_true",
                       help="Only detect filesystem type")
    
    args = parser.parse_args()
    
    try:
        # Detect OS/8 filesystem using PUTR-style detection
        is_os8, description = detect_os8_filesystem(args.image)
        
        if args.detect_only:
            if is_os8:
                print(f"✅ {description}")
                return 0
            else:
                print(f"❌ {description}")
                return 1
        
        if not is_os8:
            print(f"❌ Error: {description}")
            print("This image does not appear to contain an OS/8 filesystem")
            return 1
        
        if args.verbose:
            print(f"✅ {description}")
        
        # Load filesystem using PUTR-style parsing
        fs = OS8FileSystem(args.image, args.verbose)
        
        if args.list:
            # List files
            fs.list_files(args.detailed)
        elif args.file:
            # Extract specific file
            output_path = Path(args.output)
            success = fs.extract_file(args.file, output_path)
            if success:
                print(f"✅ File '{args.file}' extracted to {output_path}")
            else:
                print(f"❌ Failed to extract '{args.file}'")
                return 1
        else:
            # Extract all files
            output_path = Path(args.output)
            print(f"🚀 Extracting OS/8 files to {output_path}")
            
            extracted = fs.extract_all_files(output_path)
            print(f"✅ Extracted {extracted} files successfully")
        
        return 0
        
    except KeyboardInterrupt:
        print("\n❌ Operation cancelled")
        return 130
    except Exception as e:
        print(f"❌ Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == '__main__':
    sys.exit(main())
